// Code generated by protoc-gen-go. DO NOT EDIT.
// source: spanner.proto

/*
Package spannerpb is a generated protocol buffer package.

It is generated from these files:
	spanner.proto

It has these top-level messages:
	DigitallySigned
	LogStorageConfig
	MapStorageConfig
	TreeInfo
	TreeHead
*/
package spannerpb

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import google_protobuf "github.com/golang/protobuf/ptypes/any"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// State of the Tree.
// Mirrors trillian.TreeState.
type TreeState int32

const (
	TreeState_UNKNOWN_TREE_STATE TreeState = 0
	TreeState_ACTIVE             TreeState = 1
	TreeState_FROZEN             TreeState = 2
)

var TreeState_name = map[int32]string{
	0: "UNKNOWN_TREE_STATE",
	1: "ACTIVE",
	2: "FROZEN",
}
var TreeState_value = map[string]int32{
	"UNKNOWN_TREE_STATE": 0,
	"ACTIVE":             1,
	"FROZEN":             2,
}

func (x TreeState) String() string {
	return proto.EnumName(TreeState_name, int32(x))
}
func (TreeState) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

// Type of the Tree.
// Mirrors trillian.TreeType.
type TreeType int32

const (
	TreeType_UNKNOWN TreeType = 0
	TreeType_LOG     TreeType = 1
	TreeType_MAP     TreeType = 2
)

var TreeType_name = map[int32]string{
	0: "UNKNOWN",
	1: "LOG",
	2: "MAP",
}
var TreeType_value = map[string]int32{
	"UNKNOWN": 0,
	"LOG":     1,
	"MAP":     2,
}

func (x TreeType) String() string {
	return proto.EnumName(TreeType_name, int32(x))
}
func (TreeType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

// Defines the preimage protection used for tree leaves / nodes.
// Eg, RFC6962 dictates a 0x00 prefix for leaves and 0x01 for nodes.
// Mirrors trillian.HashStrategy.
type HashStrategy int32

const (
	HashStrategy_UNKNOWN_HASH_STRATEGY HashStrategy = 0
	HashStrategy_RFC_6962              HashStrategy = 1
	HashStrategy_TEST_MAP_HASHER       HashStrategy = 2
	HashStrategy_OBJECT_RFC6962_SHA256 HashStrategy = 3
	HashStrategy_CONIKS_SHA512_256     HashStrategy = 4
)

var HashStrategy_name = map[int32]string{
	0: "UNKNOWN_HASH_STRATEGY",
	1: "RFC_6962",
	2: "TEST_MAP_HASHER",
	3: "OBJECT_RFC6962_SHA256",
	4: "CONIKS_SHA512_256",
}
var HashStrategy_value = map[string]int32{
	"UNKNOWN_HASH_STRATEGY": 0,
	"RFC_6962":              1,
	"TEST_MAP_HASHER":       2,
	"OBJECT_RFC6962_SHA256": 3,
	"CONIKS_SHA512_256":     4,
}

func (x HashStrategy) String() string {
	return proto.EnumName(HashStrategy_name, int32(x))
}
func (HashStrategy) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

// Supported hash algorithms.
// The numbering space is the same as for TLS, given in RFC 5246 s7.4.1.4.1. See
// http://www.iana.org/assignments/tls-parameters/tls-parameters.xhtml#tls-parameters-18.
// Mirrors trillian.HashAlgorithm.
type HashAlgorithm int32

const (
	// No hash algorithm is used.
	HashAlgorithm_NONE HashAlgorithm = 0
	// SHA256 is used.
	HashAlgorithm_SHA256 HashAlgorithm = 4
)

var HashAlgorithm_name = map[int32]string{
	0: "NONE",
	4: "SHA256",
}
var HashAlgorithm_value = map[string]int32{
	"NONE":   0,
	"SHA256": 4,
}

func (x HashAlgorithm) String() string {
	return proto.EnumName(HashAlgorithm_name, int32(x))
}
func (HashAlgorithm) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

// Supported signature algorithms.
// The numbering space is the same as for TLS, given in RFC 5246 s7.4.1.4.1. See
// http://www.iana.org/assignments/tls-parameters/tls-parameters.xhtml#tls-parameters-16.
// Mirrors trillian.SignatureAlgorithm.
type SignatureAlgorithm int32

const (
	// Anonymous signature scheme.
	SignatureAlgorithm_ANONYMOUS SignatureAlgorithm = 0
	// RSA signature scheme.
	SignatureAlgorithm_RSA SignatureAlgorithm = 1
	// ECDSA signature scheme.
	SignatureAlgorithm_ECDSA SignatureAlgorithm = 3
)

var SignatureAlgorithm_name = map[int32]string{
	0: "ANONYMOUS",
	1: "RSA",
	3: "ECDSA",
}
var SignatureAlgorithm_value = map[string]int32{
	"ANONYMOUS": 0,
	"RSA":       1,
	"ECDSA":     3,
}

func (x SignatureAlgorithm) String() string {
	return proto.EnumName(SignatureAlgorithm_name, int32(x))
}
func (SignatureAlgorithm) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

// SignatureCipherSuite defines the set of algorithms used for signing.
type SignatureCipherSuite int32

const (
	// Signature and hash algorithm are unknown / not set.
	SignatureCipherSuite_UNKNOWN_CIPHER_SUITE SignatureCipherSuite = 0
	// RSA with SHA256.
	SignatureCipherSuite_RSA_SHA256 SignatureCipherSuite = 1
	// ECDSA with SHA256.
	SignatureCipherSuite_ECDSA_SHA256 SignatureCipherSuite = 2
)

var SignatureCipherSuite_name = map[int32]string{
	0: "UNKNOWN_CIPHER_SUITE",
	1: "RSA_SHA256",
	2: "ECDSA_SHA256",
}
var SignatureCipherSuite_value = map[string]int32{
	"UNKNOWN_CIPHER_SUITE": 0,
	"RSA_SHA256":           1,
	"ECDSA_SHA256":         2,
}

func (x SignatureCipherSuite) String() string {
	return proto.EnumName(SignatureCipherSuite_name, int32(x))
}
func (SignatureCipherSuite) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

// Protocol buffer encoding of the TLS DigitallySigned type, from RFC 5246 ยง4.7.
type DigitallySigned struct {
	// hash_algorithm contains the hash algorithm used.
	HashAlgorithm HashAlgorithm `protobuf:"varint,1,opt,name=hash_algorithm,json=hashAlgorithm,enum=spannerpb.HashAlgorithm" json:"hash_algorithm,omitempty"`
	// signature_algorithm contains the signing algorithm used.
	SignatureAlgorithm SignatureAlgorithm `protobuf:"varint,2,opt,name=signature_algorithm,json=signatureAlgorithm,enum=spannerpb.SignatureAlgorithm" json:"signature_algorithm,omitempty"`
	// cipher_suite contains the combination of ciphers used for this signature.
	SignatureCipherSuite SignatureCipherSuite `protobuf:"varint,4,opt,name=signature_cipher_suite,json=signatureCipherSuite,enum=spannerpb.SignatureCipherSuite" json:"signature_cipher_suite,omitempty"`
	// signature contains the object signature.
	Signature []byte `protobuf:"bytes,3,opt,name=signature,proto3" json:"signature,omitempty"`
}

func (m *DigitallySigned) Reset()                    { *m = DigitallySigned{} }
func (m *DigitallySigned) String() string            { return proto.CompactTextString(m) }
func (*DigitallySigned) ProtoMessage()               {}
func (*DigitallySigned) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *DigitallySigned) GetHashAlgorithm() HashAlgorithm {
	if m != nil {
		return m.HashAlgorithm
	}
	return HashAlgorithm_NONE
}

func (m *DigitallySigned) GetSignatureAlgorithm() SignatureAlgorithm {
	if m != nil {
		return m.SignatureAlgorithm
	}
	return SignatureAlgorithm_ANONYMOUS
}

func (m *DigitallySigned) GetSignatureCipherSuite() SignatureCipherSuite {
	if m != nil {
		return m.SignatureCipherSuite
	}
	return SignatureCipherSuite_UNKNOWN_CIPHER_SUITE
}

func (m *DigitallySigned) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

// LogStorageConfig holds settings which tune the storage implementation for
// a given log tree.
type LogStorageConfig struct {
	// num_unseq_buckets defines the length of the unsequenced time ring buffer.
	// This value must *never* be reduced for any provisioned tree.
	//
	// This value should be >= 1, and there's probably not much benefit in
	// raising it past about 4.
	// TODO(al): test what the effects of various values are here.
	NumUnseqBuckets int64 `protobuf:"varint,1,opt,name=num_unseq_buckets,json=numUnseqBuckets" json:"num_unseq_buckets,omitempty"`
	// num_merkle_buckets defines the number of individual buckets below each
	// unsequenced ring bucket.
	// This value may be changed at any time (so long as you understand the
	// impact it'll have on integration performace!)
	//
	// This value must lie in the range [1..256]
	NumMerkleBuckets int64 `protobuf:"varint,2,opt,name=num_merkle_buckets,json=numMerkleBuckets" json:"num_merkle_buckets,omitempty"`
}

func (m *LogStorageConfig) Reset()                    { *m = LogStorageConfig{} }
func (m *LogStorageConfig) String() string            { return proto.CompactTextString(m) }
func (*LogStorageConfig) ProtoMessage()               {}
func (*LogStorageConfig) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *LogStorageConfig) GetNumUnseqBuckets() int64 {
	if m != nil {
		return m.NumUnseqBuckets
	}
	return 0
}

func (m *LogStorageConfig) GetNumMerkleBuckets() int64 {
	if m != nil {
		return m.NumMerkleBuckets
	}
	return 0
}

// MapStorageConfig holds settings which tune the storage implementation for
// a given map tree.
type MapStorageConfig struct {
}

func (m *MapStorageConfig) Reset()                    { *m = MapStorageConfig{} }
func (m *MapStorageConfig) String() string            { return proto.CompactTextString(m) }
func (*MapStorageConfig) ProtoMessage()               {}
func (*MapStorageConfig) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

// TreeInfo stores information about a Trillian tree.
type TreeInfo struct {
	// tree_id is the ID of the tree, and is used as a primary key.
	TreeId int64 `protobuf:"varint,1,opt,name=tree_id,json=treeId" json:"tree_id,omitempty"`
	// key_id identifies the private key associated with this tree.
	KeyId int64 `protobuf:"varint,2,opt,name=key_id,json=keyId" json:"key_id,omitempty"`
	// name is a short name for this tree.
	Name string `protobuf:"bytes,3,opt,name=name" json:"name,omitempty"`
	// description is a short free form text describing the tree.
	Description string `protobuf:"bytes,4,opt,name=description" json:"description,omitempty"`
	// tree_type identifies whether this is a Log or a Map tree.
	TreeType TreeType `protobuf:"varint,5,opt,name=tree_type,json=treeType,enum=spannerpb.TreeType" json:"tree_type,omitempty"`
	// tree_state is the state of the tree.
	TreeState TreeState `protobuf:"varint,8,opt,name=tree_state,json=treeState,enum=spannerpb.TreeState" json:"tree_state,omitempty"`
	// hash_strategy is the hashing strategy used by the tree.
	HashStrategy HashStrategy `protobuf:"varint,9,opt,name=hash_strategy,json=hashStrategy,enum=spannerpb.HashStrategy" json:"hash_strategy,omitempty"`
	// hash_algorithm is the hash algorithm used by the tree.
	HashAlgorithm HashAlgorithm `protobuf:"varint,10,opt,name=hash_algorithm,json=hashAlgorithm,enum=spannerpb.HashAlgorithm" json:"hash_algorithm,omitempty"`
	// signature_algorithm is the signature algorithm used by the tree.
	SignatureAlgorithm SignatureAlgorithm `protobuf:"varint,11,opt,name=signature_algorithm,json=signatureAlgorithm,enum=spannerpb.SignatureAlgorithm" json:"signature_algorithm,omitempty"`
	// create_time_nanos is the creation timestamp of the tree, in nanos since
	// epoch.
	CreateTimeNanos int64 `protobuf:"varint,13,opt,name=create_time_nanos,json=createTimeNanos" json:"create_time_nanos,omitempty"`
	// update_time_nanos is the last update time of the tree, in nanos since
	// epoch.
	UpdateTimeNanos int64 `protobuf:"varint,14,opt,name=update_time_nanos,json=updateTimeNanos" json:"update_time_nanos,omitempty"`
	// private_key should be used to generate signatures for this tree.
	PrivateKey *google_protobuf.Any `protobuf:"bytes,15,opt,name=private_key,json=privateKey" json:"private_key,omitempty"`
	// public_key_der should be used to verify signatures produced by this tree.
	// It is the key in DER-encoded PKIX form.
	PublicKeyDer []byte `protobuf:"bytes,16,opt,name=public_key_der,json=publicKeyDer,proto3" json:"public_key_der,omitempty"`
	// config contains the log or map specific tree configuration.
	//
	// Types that are valid to be assigned to StorageConfig:
	//	*TreeInfo_LogStorageConfig
	//	*TreeInfo_MapStorageConfig
	StorageConfig isTreeInfo_StorageConfig `protobuf_oneof:"storage_config"`
	// max_root_duration_millis is the interval after which a new signed root is
	// produced even if there have been no submission.  If zero, this behavior is
	// disabled.
	MaxRootDurationMillis int64 `protobuf:"varint,17,opt,name=max_root_duration_millis,json=maxRootDurationMillis" json:"max_root_duration_millis,omitempty"`
	// If true the tree was soft deleted.
	Deleted bool `protobuf:"varint,18,opt,name=deleted" json:"deleted,omitempty"`
	// Time of tree deletion, if any.
	DeleteTimeNanos int64 `protobuf:"varint,19,opt,name=delete_time_nanos,json=deleteTimeNanos" json:"delete_time_nanos,omitempty"`
}

func (m *TreeInfo) Reset()                    { *m = TreeInfo{} }
func (m *TreeInfo) String() string            { return proto.CompactTextString(m) }
func (*TreeInfo) ProtoMessage()               {}
func (*TreeInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

type isTreeInfo_StorageConfig interface{ isTreeInfo_StorageConfig() }

type TreeInfo_LogStorageConfig struct {
	LogStorageConfig *LogStorageConfig `protobuf:"bytes,6,opt,name=log_storage_config,json=logStorageConfig,oneof"`
}
type TreeInfo_MapStorageConfig struct {
	MapStorageConfig *MapStorageConfig `protobuf:"bytes,7,opt,name=map_storage_config,json=mapStorageConfig,oneof"`
}

func (*TreeInfo_LogStorageConfig) isTreeInfo_StorageConfig() {}
func (*TreeInfo_MapStorageConfig) isTreeInfo_StorageConfig() {}

func (m *TreeInfo) GetStorageConfig() isTreeInfo_StorageConfig {
	if m != nil {
		return m.StorageConfig
	}
	return nil
}

func (m *TreeInfo) GetTreeId() int64 {
	if m != nil {
		return m.TreeId
	}
	return 0
}

func (m *TreeInfo) GetKeyId() int64 {
	if m != nil {
		return m.KeyId
	}
	return 0
}

func (m *TreeInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *TreeInfo) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *TreeInfo) GetTreeType() TreeType {
	if m != nil {
		return m.TreeType
	}
	return TreeType_UNKNOWN
}

func (m *TreeInfo) GetTreeState() TreeState {
	if m != nil {
		return m.TreeState
	}
	return TreeState_UNKNOWN_TREE_STATE
}

func (m *TreeInfo) GetHashStrategy() HashStrategy {
	if m != nil {
		return m.HashStrategy
	}
	return HashStrategy_UNKNOWN_HASH_STRATEGY
}

func (m *TreeInfo) GetHashAlgorithm() HashAlgorithm {
	if m != nil {
		return m.HashAlgorithm
	}
	return HashAlgorithm_NONE
}

func (m *TreeInfo) GetSignatureAlgorithm() SignatureAlgorithm {
	if m != nil {
		return m.SignatureAlgorithm
	}
	return SignatureAlgorithm_ANONYMOUS
}

func (m *TreeInfo) GetCreateTimeNanos() int64 {
	if m != nil {
		return m.CreateTimeNanos
	}
	return 0
}

func (m *TreeInfo) GetUpdateTimeNanos() int64 {
	if m != nil {
		return m.UpdateTimeNanos
	}
	return 0
}

func (m *TreeInfo) GetPrivateKey() *google_protobuf.Any {
	if m != nil {
		return m.PrivateKey
	}
	return nil
}

func (m *TreeInfo) GetPublicKeyDer() []byte {
	if m != nil {
		return m.PublicKeyDer
	}
	return nil
}

func (m *TreeInfo) GetLogStorageConfig() *LogStorageConfig {
	if x, ok := m.GetStorageConfig().(*TreeInfo_LogStorageConfig); ok {
		return x.LogStorageConfig
	}
	return nil
}

func (m *TreeInfo) GetMapStorageConfig() *MapStorageConfig {
	if x, ok := m.GetStorageConfig().(*TreeInfo_MapStorageConfig); ok {
		return x.MapStorageConfig
	}
	return nil
}

func (m *TreeInfo) GetMaxRootDurationMillis() int64 {
	if m != nil {
		return m.MaxRootDurationMillis
	}
	return 0
}

func (m *TreeInfo) GetDeleted() bool {
	if m != nil {
		return m.Deleted
	}
	return false
}

func (m *TreeInfo) GetDeleteTimeNanos() int64 {
	if m != nil {
		return m.DeleteTimeNanos
	}
	return 0
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*TreeInfo) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _TreeInfo_OneofMarshaler, _TreeInfo_OneofUnmarshaler, _TreeInfo_OneofSizer, []interface{}{
		(*TreeInfo_LogStorageConfig)(nil),
		(*TreeInfo_MapStorageConfig)(nil),
	}
}

func _TreeInfo_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*TreeInfo)
	// storage_config
	switch x := m.StorageConfig.(type) {
	case *TreeInfo_LogStorageConfig:
		b.EncodeVarint(6<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.LogStorageConfig); err != nil {
			return err
		}
	case *TreeInfo_MapStorageConfig:
		b.EncodeVarint(7<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.MapStorageConfig); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("TreeInfo.StorageConfig has unexpected type %T", x)
	}
	return nil
}

func _TreeInfo_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*TreeInfo)
	switch tag {
	case 6: // storage_config.log_storage_config
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(LogStorageConfig)
		err := b.DecodeMessage(msg)
		m.StorageConfig = &TreeInfo_LogStorageConfig{msg}
		return true, err
	case 7: // storage_config.map_storage_config
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(MapStorageConfig)
		err := b.DecodeMessage(msg)
		m.StorageConfig = &TreeInfo_MapStorageConfig{msg}
		return true, err
	default:
		return false, nil
	}
}

func _TreeInfo_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*TreeInfo)
	// storage_config
	switch x := m.StorageConfig.(type) {
	case *TreeInfo_LogStorageConfig:
		s := proto.Size(x.LogStorageConfig)
		n += proto.SizeVarint(6<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *TreeInfo_MapStorageConfig:
		s := proto.Size(x.MapStorageConfig)
		n += proto.SizeVarint(7<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// TreeHead is the storage format for Trillian's commitment to a particular
// tree state.
type TreeHead struct {
	// tree_id identifies the tree this TreeHead is built from.
	TreeId int64 `protobuf:"varint,1,opt,name=tree_id,json=treeId" json:"tree_id,omitempty"`
	// ts_nanos is the nanosecond resolution timestamp at which the
	// TreeHead was created.
	TsNanos int64 `protobuf:"varint,2,opt,name=ts_nanos,json=tsNanos" json:"ts_nanos,omitempty"`
	// tree_size is the number of entries in the tree.
	TreeSize int64 `protobuf:"varint,3,opt,name=tree_size,json=treeSize" json:"tree_size,omitempty"`
	// root_hash is the root of the tree.
	RootHash []byte `protobuf:"bytes,4,opt,name=root_hash,json=rootHash,proto3" json:"root_hash,omitempty"`
	// signature holds a digital signature across the data in this TreeHead.
	Signature *DigitallySigned `protobuf:"bytes,8,opt,name=signature" json:"signature,omitempty"`
	// tree_revision identifies the revision at which the TreeHead was created.
	TreeRevision int64 `protobuf:"varint,6,opt,name=tree_revision,json=treeRevision" json:"tree_revision,omitempty"`
	// metadata is a blob of opaque data specific to the personality layer that an
	// application associates with each TreeHead, and which must be covered by the
	// tree head signature.  Only used for Maps at present.
	Metadata *google_protobuf.Any `protobuf:"bytes,7,opt,name=metadata" json:"metadata,omitempty"`
}

func (m *TreeHead) Reset()                    { *m = TreeHead{} }
func (m *TreeHead) String() string            { return proto.CompactTextString(m) }
func (*TreeHead) ProtoMessage()               {}
func (*TreeHead) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *TreeHead) GetTreeId() int64 {
	if m != nil {
		return m.TreeId
	}
	return 0
}

func (m *TreeHead) GetTsNanos() int64 {
	if m != nil {
		return m.TsNanos
	}
	return 0
}

func (m *TreeHead) GetTreeSize() int64 {
	if m != nil {
		return m.TreeSize
	}
	return 0
}

func (m *TreeHead) GetRootHash() []byte {
	if m != nil {
		return m.RootHash
	}
	return nil
}

func (m *TreeHead) GetSignature() *DigitallySigned {
	if m != nil {
		return m.Signature
	}
	return nil
}

func (m *TreeHead) GetTreeRevision() int64 {
	if m != nil {
		return m.TreeRevision
	}
	return 0
}

func (m *TreeHead) GetMetadata() *google_protobuf.Any {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func init() {
	proto.RegisterType((*DigitallySigned)(nil), "spannerpb.DigitallySigned")
	proto.RegisterType((*LogStorageConfig)(nil), "spannerpb.LogStorageConfig")
	proto.RegisterType((*MapStorageConfig)(nil), "spannerpb.MapStorageConfig")
	proto.RegisterType((*TreeInfo)(nil), "spannerpb.TreeInfo")
	proto.RegisterType((*TreeHead)(nil), "spannerpb.TreeHead")
	proto.RegisterEnum("spannerpb.TreeState", TreeState_name, TreeState_value)
	proto.RegisterEnum("spannerpb.TreeType", TreeType_name, TreeType_value)
	proto.RegisterEnum("spannerpb.HashStrategy", HashStrategy_name, HashStrategy_value)
	proto.RegisterEnum("spannerpb.HashAlgorithm", HashAlgorithm_name, HashAlgorithm_value)
	proto.RegisterEnum("spannerpb.SignatureAlgorithm", SignatureAlgorithm_name, SignatureAlgorithm_value)
	proto.RegisterEnum("spannerpb.SignatureCipherSuite", SignatureCipherSuite_name, SignatureCipherSuite_value)
}

func init() { proto.RegisterFile("spanner.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 1054 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x56, 0xdd, 0x6e, 0xdb, 0x46,
	0x13, 0xb5, 0x7e, 0x2c, 0x51, 0x63, 0x49, 0xa6, 0xd7, 0x76, 0xc2, 0x24, 0xdf, 0x87, 0x1a, 0x6e,
	0x0b, 0xb8, 0x42, 0x21, 0xa5, 0x0e, 0xec, 0x34, 0x48, 0x81, 0x82, 0x96, 0xe5, 0x48, 0x56, 0x24,
	0x19, 0x4b, 0xba, 0x45, 0x72, 0xb3, 0x58, 0x89, 0x6b, 0x8a, 0x30, 0xff, 0x4a, 0x2e, 0x83, 0x28,
	0x17, 0x7d, 0x82, 0x02, 0xbd, 0xec, 0xeb, 0x16, 0xbb, 0xa4, 0x64, 0x5a, 0x76, 0x6f, 0x8a, 0xde,
	0xed, 0x9e, 0x39, 0x33, 0xa3, 0x1d, 0x9e, 0x33, 0x36, 0x34, 0xe2, 0x90, 0xfa, 0x3e, 0x8b, 0xda,
	0x61, 0x14, 0xf0, 0x00, 0xd5, 0xb2, 0x6b, 0x38, 0x7d, 0xfe, 0xcc, 0x0e, 0x02, 0xdb, 0x65, 0x1d,
	0x19, 0x98, 0x26, 0x37, 0x1d, 0xea, 0x2f, 0x52, 0xd6, 0xe1, 0x5f, 0x45, 0xd8, 0x3e, 0x77, 0x6c,
	0x87, 0x53, 0xd7, 0x5d, 0x18, 0x8e, 0xed, 0x33, 0x0b, 0xfd, 0x0c, 0xcd, 0x39, 0x8d, 0xe7, 0x84,
	0xba, 0x76, 0x10, 0x39, 0x7c, 0xee, 0x69, 0x85, 0x83, 0xc2, 0x51, 0xf3, 0x58, 0x6b, 0xaf, 0x4a,
	0xb6, 0xfb, 0x34, 0x9e, 0xeb, 0xcb, 0x38, 0x6e, 0xcc, 0xf3, 0x57, 0x34, 0x86, 0xdd, 0xd8, 0xb1,
	0x7d, 0xca, 0x93, 0x88, 0xe5, 0xaa, 0x14, 0x65, 0x95, 0xff, 0xe7, 0xaa, 0x18, 0x4b, 0xd6, 0x5d,
	0x29, 0x14, 0x3f, 0xc0, 0xd0, 0x35, 0x3c, 0xb9, 0xab, 0x37, 0x73, 0xc2, 0x39, 0x8b, 0x48, 0x9c,
	0x38, 0x9c, 0x69, 0x65, 0x59, 0xf2, 0xab, 0xc7, 0x4a, 0x76, 0x25, 0xcf, 0x10, 0x34, 0xbc, 0x17,
	0x3f, 0x82, 0xa2, 0xff, 0x41, 0x6d, 0x85, 0x6b, 0xa5, 0x83, 0xc2, 0x51, 0x1d, 0xdf, 0x01, 0x87,
	0x2e, 0xa8, 0xef, 0x03, 0xdb, 0xe0, 0x41, 0x44, 0x6d, 0xd6, 0x0d, 0xfc, 0x1b, 0xc7, 0x46, 0x2d,
	0xd8, 0xf1, 0x13, 0x8f, 0x24, 0x7e, 0xcc, 0x7e, 0x23, 0xd3, 0x64, 0x76, 0xcb, 0x78, 0x2c, 0x87,
	0x53, 0xc2, 0xdb, 0x7e, 0xe2, 0x5d, 0x0b, 0xfc, 0x2c, 0x85, 0xd1, 0xf7, 0x80, 0x04, 0xd7, 0x63,
	0xd1, 0xad, 0xcb, 0x56, 0xe4, 0xa2, 0x24, 0xab, 0x7e, 0xe2, 0x8d, 0x64, 0x20, 0x63, 0x1f, 0x22,
	0x50, 0x47, 0x34, 0xbc, 0xd7, 0xed, 0xf0, 0x8f, 0x2a, 0x28, 0x66, 0xc4, 0xd8, 0xc0, 0xbf, 0x09,
	0xd0, 0x53, 0xa8, 0xf2, 0x88, 0x31, 0xe2, 0x58, 0x59, 0xc3, 0x8a, 0xb8, 0x0e, 0x2c, 0xb4, 0x0f,
	0x95, 0x5b, 0xb6, 0x10, 0x78, 0x5a, 0x7b, 0xf3, 0x96, 0x2d, 0x06, 0x16, 0x42, 0x50, 0xf6, 0xa9,
	0x97, 0xbe, 0xab, 0x86, 0xe5, 0x19, 0x1d, 0xc0, 0x96, 0xc5, 0xe2, 0x59, 0xe4, 0x84, 0xdc, 0x09,
	0x7c, 0x39, 0xbc, 0x1a, 0xce, 0x43, 0xe8, 0x25, 0xd4, 0x64, 0x17, 0xbe, 0x08, 0x99, 0xb6, 0x29,
	0x87, 0xbb, 0x9b, 0x1b, 0xae, 0xf8, 0x35, 0xe6, 0x22, 0x64, 0x58, 0xe1, 0xd9, 0x09, 0xbd, 0x02,
	0x90, 0x19, 0x31, 0xa7, 0x9c, 0x69, 0x8a, 0x4c, 0xd9, 0x5b, 0x4b, 0x31, 0x44, 0x0c, 0xcb, 0xca,
	0xf2, 0x88, 0x7e, 0x02, 0xa9, 0x18, 0x12, 0xf3, 0x88, 0x72, 0x66, 0x2f, 0xb4, 0x9a, 0xcc, 0x7b,
	0xba, 0x26, 0x30, 0x23, 0x0b, 0xe3, 0xfa, 0x3c, 0x77, 0x7b, 0x44, 0x9f, 0xf0, 0x9f, 0xe8, 0x73,
	0xeb, 0xdf, 0xea, 0xb3, 0x05, 0x3b, 0xb3, 0x88, 0x51, 0xce, 0x08, 0x77, 0x3c, 0x46, 0x7c, 0xea,
	0x07, 0xb1, 0xd6, 0x48, 0x65, 0x91, 0x06, 0x4c, 0xc7, 0x63, 0x63, 0x01, 0x0b, 0x6e, 0x12, 0x5a,
	0x6b, 0xdc, 0x66, 0xca, 0x4d, 0x03, 0x77, 0xdc, 0x13, 0xd8, 0x0a, 0x23, 0xe7, 0x93, 0x20, 0xdf,
	0xb2, 0x85, 0xb6, 0x7d, 0x50, 0x38, 0xda, 0x3a, 0xde, 0x6b, 0xa7, 0x6e, 0x6e, 0x2f, 0xdd, 0xdc,
	0xd6, 0xfd, 0x05, 0x86, 0x8c, 0x38, 0x64, 0x0b, 0xf4, 0x0d, 0x34, 0xc3, 0x64, 0xea, 0x3a, 0x33,
	0x91, 0x45, 0x2c, 0x16, 0x69, 0xaa, 0x14, 0x77, 0x3d, 0x45, 0x87, 0x6c, 0x71, 0xce, 0x22, 0x34,
	0x04, 0xe4, 0x06, 0x36, 0x89, 0x53, 0xc9, 0x91, 0x99, 0xd4, 0x9c, 0x56, 0x91, 0x3d, 0x5e, 0xe4,
	0x66, 0xb0, 0x6e, 0x82, 0xfe, 0x06, 0x56, 0xdd, 0x75, 0x63, 0x0c, 0x01, 0x79, 0x34, 0x5c, 0x2f,
	0x56, 0x7d, 0x50, 0x6c, 0x5d, 0xe3, 0xa2, 0x98, 0xb7, 0x86, 0xa1, 0xd7, 0xa0, 0x79, 0xf4, 0x33,
	0x89, 0x82, 0x80, 0x13, 0x2b, 0x89, 0xa8, 0x50, 0x26, 0xf1, 0x1c, 0xd7, 0x75, 0x62, 0x6d, 0x47,
	0x4e, 0x6a, 0xdf, 0xa3, 0x9f, 0x71, 0x10, 0xf0, 0xf3, 0x2c, 0x3a, 0x92, 0x41, 0xa4, 0x41, 0xd5,
	0x62, 0x2e, 0xe3, 0xcc, 0xd2, 0xd0, 0x41, 0xe1, 0x48, 0xc1, 0xcb, 0xab, 0x98, 0x7a, 0x7a, 0xcc,
	0x4f, 0x7d, 0x37, 0x9d, 0x7a, 0x1a, 0x58, 0x4d, 0xfd, 0x4c, 0x85, 0xe6, 0xfd, 0x77, 0x5c, 0x96,
	0x95, 0xba, 0xda, 0x38, 0xfc, 0xb3, 0x98, 0xda, 0xb1, 0xcf, 0xa8, 0xf5, 0xcf, 0x76, 0x7c, 0x06,
	0x0a, 0x8f, 0xb3, 0x06, 0xa9, 0x21, 0xab, 0x3c, 0x4e, 0x3f, 0xe7, 0x8b, 0xcc, 0x5c, 0xb1, 0xf3,
	0x25, 0xf5, 0x65, 0x29, 0xf5, 0x91, 0xe1, 0x7c, 0x61, 0x22, 0x28, 0x1f, 0x2c, 0x94, 0x2a, 0x9d,
	0x59, 0xc7, 0x8a, 0x00, 0x84, 0x90, 0xd1, 0x8f, 0xf9, 0x4d, 0xa5, 0xc8, 0xa9, 0x3e, 0xcf, 0x4d,
	0x75, 0x6d, 0x81, 0xe7, 0xb6, 0x18, 0xfa, 0x1a, 0x1a, 0xb2, 0x67, 0xc4, 0x3e, 0x39, 0xb1, 0x30,
	0x7d, 0x45, 0xf6, 0xad, 0x0b, 0x10, 0x67, 0x18, 0x7a, 0x09, 0x8a, 0xc7, 0x38, 0xb5, 0x28, 0xa7,
	0xd9, 0x37, 0x7b, 0x5c, 0x64, 0x2b, 0xd6, 0x65, 0x59, 0xd9, 0x54, 0x2b, 0xad, 0xb7, 0x50, 0x5b,
	0xd9, 0x1b, 0x3d, 0x01, 0x74, 0x3d, 0x1e, 0x8e, 0x27, 0xbf, 0x8e, 0x89, 0x89, 0x7b, 0x3d, 0x62,
	0x98, 0xba, 0xd9, 0x53, 0x37, 0x10, 0x40, 0x45, 0xef, 0x9a, 0x83, 0x5f, 0x7a, 0x6a, 0x41, 0x9c,
	0x2f, 0xf0, 0xe4, 0x63, 0x6f, 0xac, 0x16, 0x5b, 0xdf, 0xa5, 0xd3, 0x94, 0x4b, 0x64, 0x0b, 0xaa,
	0x59, 0xae, 0xba, 0x81, 0xaa, 0x50, 0x7a, 0x3f, 0x79, 0xa7, 0x16, 0xc4, 0x61, 0xa4, 0x5f, 0xa9,
	0xc5, 0xd6, 0xef, 0x50, 0xcf, 0xaf, 0x03, 0xf4, 0x0c, 0xf6, 0x97, 0xad, 0xfa, 0xba, 0xd1, 0x27,
	0x86, 0x89, 0x75, 0xb3, 0xf7, 0xee, 0x83, 0xba, 0x81, 0xea, 0xa0, 0xe0, 0x8b, 0x2e, 0x39, 0x7d,
	0x73, 0x7a, 0xac, 0x16, 0xd0, 0x2e, 0x6c, 0x9b, 0x3d, 0xc3, 0x24, 0x23, 0xfd, 0x4a, 0x32, 0x7b,
	0x58, 0x2d, 0x8a, 0xec, 0xc9, 0xd9, 0x65, 0xaf, 0x6b, 0x12, 0x7c, 0xd1, 0x15, 0x44, 0x62, 0xf4,
	0xf5, 0xe3, 0x93, 0x53, 0xb5, 0x84, 0xf6, 0x61, 0xa7, 0x3b, 0x19, 0x0f, 0x86, 0x86, 0x80, 0x4e,
	0x7e, 0x38, 0x26, 0x02, 0x2e, 0xb7, 0xbe, 0x85, 0xc6, 0xbd, 0x7d, 0x82, 0x14, 0x28, 0x8f, 0x27,
	0xe3, 0xec, 0x75, 0x59, 0x76, 0xb9, 0xf5, 0x1a, 0xd0, 0xc3, 0x85, 0x81, 0x1a, 0x50, 0xd3, 0xc7,
	0x93, 0xf1, 0x87, 0xd1, 0xe4, 0xda, 0x48, 0x5f, 0x87, 0x0d, 0x5d, 0x2d, 0xa0, 0x1a, 0x6c, 0xf6,
	0xba, 0xe7, 0x86, 0xae, 0x96, 0x5a, 0x18, 0xf6, 0x1e, 0xfb, 0xb3, 0x85, 0x34, 0xd8, 0x5b, 0xbe,
	0xb3, 0x3b, 0xb8, 0xea, 0xf7, 0x30, 0x31, 0xae, 0x07, 0x72, 0xa8, 0x4d, 0x00, 0x6c, 0xe8, 0xcb,
	0x1f, 0x5e, 0x40, 0x2a, 0xd4, 0x65, 0xb1, 0x25, 0x52, 0x3c, 0x7b, 0xfb, 0xf1, 0x8d, 0xed, 0xf0,
	0x79, 0x32, 0x6d, 0xcf, 0x02, 0xaf, 0x93, 0xfd, 0x03, 0xc0, 0x23, 0x61, 0x14, 0xea, 0x77, 0x32,
	0x81, 0x77, 0x66, 0x6e, 0x90, 0x58, 0x99, 0x90, 0x3a, 0x2b, 0x41, 0x4d, 0x2b, 0xf2, 0xb3, 0xbf,
	0xfa, 0x3b, 0x00, 0x00, 0xff, 0xff, 0x1b, 0x65, 0xa4, 0x03, 0x53, 0x08, 0x00, 0x00,
}
