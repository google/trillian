// Code generated by protoc-gen-go. DO NOT EDIT.
// source: tile.proto

package tilepb

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// Tile represents a perfect subtree covering the whole height of a stratum
// within a sparse map.
type Tile struct {
	// The path from the root of the map to the root of this tile.
	Path []byte `protobuf:"bytes,1,opt,name=path,proto3" json:"path,omitempty"`
	// The computed hash of this subtree.
	// TODO(mhutchinson): Consider removing this.
	RootHash []byte `protobuf:"bytes,2,opt,name=root_hash,json=rootHash,proto3" json:"root_hash,omitempty"`
	// All non-empty leaves in this tile, sorted left-to-right.
	Leaves               []*TileLeaf `protobuf:"bytes,3,rep,name=leaves,proto3" json:"leaves,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *Tile) Reset()         { *m = Tile{} }
func (m *Tile) String() string { return proto.CompactTextString(m) }
func (*Tile) ProtoMessage()    {}
func (*Tile) Descriptor() ([]byte, []int) {
	return fileDescriptor_00eb11d7cb77dd46, []int{0}
}

func (m *Tile) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Tile.Unmarshal(m, b)
}
func (m *Tile) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Tile.Marshal(b, m, deterministic)
}
func (m *Tile) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Tile.Merge(m, src)
}
func (m *Tile) XXX_Size() int {
	return xxx_messageInfo_Tile.Size(m)
}
func (m *Tile) XXX_DiscardUnknown() {
	xxx_messageInfo_Tile.DiscardUnknown(m)
}

var xxx_messageInfo_Tile proto.InternalMessageInfo

func (m *Tile) GetPath() []byte {
	if m != nil {
		return m.Path
	}
	return nil
}

func (m *Tile) GetRootHash() []byte {
	if m != nil {
		return m.RootHash
	}
	return nil
}

func (m *Tile) GetLeaves() []*TileLeaf {
	if m != nil {
		return m.Leaves
	}
	return nil
}

// TileLeaf is a leaf value of a Tile.
// If it belongs to a leaf tile then this represents one of the values that the
// map commits to. Otherwise, this leaf represents the root of the subtree in
// the stratum below.
type TileLeaf struct {
	// The path from the root of the container Tile to this leaf.
	Path []byte `protobuf:"bytes,1,opt,name=path,proto3" json:"path,omitempty"`
	// The hash value being committed to.
	Hash                 []byte   `protobuf:"bytes,2,opt,name=hash,proto3" json:"hash,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TileLeaf) Reset()         { *m = TileLeaf{} }
func (m *TileLeaf) String() string { return proto.CompactTextString(m) }
func (*TileLeaf) ProtoMessage()    {}
func (*TileLeaf) Descriptor() ([]byte, []int) {
	return fileDescriptor_00eb11d7cb77dd46, []int{1}
}

func (m *TileLeaf) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_TileLeaf.Unmarshal(m, b)
}
func (m *TileLeaf) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_TileLeaf.Marshal(b, m, deterministic)
}
func (m *TileLeaf) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TileLeaf.Merge(m, src)
}
func (m *TileLeaf) XXX_Size() int {
	return xxx_messageInfo_TileLeaf.Size(m)
}
func (m *TileLeaf) XXX_DiscardUnknown() {
	xxx_messageInfo_TileLeaf.DiscardUnknown(m)
}

var xxx_messageInfo_TileLeaf proto.InternalMessageInfo

func (m *TileLeaf) GetPath() []byte {
	if m != nil {
		return m.Path
	}
	return nil
}

func (m *TileLeaf) GetHash() []byte {
	if m != nil {
		return m.Hash
	}
	return nil
}

// Entry is a single key/value to be committed to by the map.
type Entry struct {
	// The key that uniquely identifies this key/value.
	// These keys must be distributed uniformly and randomly across the key space.
	HashKey []byte `protobuf:"bytes,1,opt,name=hash_key,json=hashKey,proto3" json:"hash_key,omitempty"`
	// Hash of the value to be committed to. This will literally be set as a hash
	// of a TileLeaf in a leaf Tile.
	// It is the job of the code constructing this Entry to ensure that this has
	// appropriate preimage protection and domain separation. This means this will
	// likely be set to something like H(salt || data).
	//
	// TODO(mhutchinson): Revisit this. My preference is that this is set to
	// H(data), and the map synthesis will set the hash to H(salt||H(data)).
	// This allows the map to always be constructed with good security.
	HashValue            []byte   `protobuf:"bytes,2,opt,name=hash_value,json=hashValue,proto3" json:"hash_value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Entry) Reset()         { *m = Entry{} }
func (m *Entry) String() string { return proto.CompactTextString(m) }
func (*Entry) ProtoMessage()    {}
func (*Entry) Descriptor() ([]byte, []int) {
	return fileDescriptor_00eb11d7cb77dd46, []int{2}
}

func (m *Entry) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Entry.Unmarshal(m, b)
}
func (m *Entry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Entry.Marshal(b, m, deterministic)
}
func (m *Entry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Entry.Merge(m, src)
}
func (m *Entry) XXX_Size() int {
	return xxx_messageInfo_Entry.Size(m)
}
func (m *Entry) XXX_DiscardUnknown() {
	xxx_messageInfo_Entry.DiscardUnknown(m)
}

var xxx_messageInfo_Entry proto.InternalMessageInfo

func (m *Entry) GetHashKey() []byte {
	if m != nil {
		return m.HashKey
	}
	return nil
}

func (m *Entry) GetHashValue() []byte {
	if m != nil {
		return m.HashValue
	}
	return nil
}

func init() {
	proto.RegisterType((*Tile)(nil), "tilepb.Tile")
	proto.RegisterType((*TileLeaf)(nil), "tilepb.TileLeaf")
	proto.RegisterType((*Entry)(nil), "tilepb.Entry")
}

func init() { proto.RegisterFile("tile.proto", fileDescriptor_00eb11d7cb77dd46) }

var fileDescriptor_00eb11d7cb77dd46 = []byte{
	// 192 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe2, 0xe2, 0x2a, 0xc9, 0xcc, 0x49,
	0xd5, 0x2b, 0x28, 0xca, 0x2f, 0xc9, 0x17, 0x62, 0x03, 0xb1, 0x0b, 0x92, 0x94, 0x12, 0xb9, 0x58,
	0x42, 0x32, 0x73, 0x52, 0x85, 0x84, 0xb8, 0x58, 0x0a, 0x12, 0x4b, 0x32, 0x24, 0x18, 0x15, 0x18,
	0x35, 0x78, 0x82, 0xc0, 0x6c, 0x21, 0x69, 0x2e, 0xce, 0xa2, 0xfc, 0xfc, 0x92, 0xf8, 0x8c, 0xc4,
	0xe2, 0x0c, 0x09, 0x26, 0xb0, 0x04, 0x07, 0x48, 0xc0, 0x23, 0xb1, 0x38, 0x43, 0x48, 0x83, 0x8b,
	0x2d, 0x27, 0x35, 0xb1, 0x2c, 0xb5, 0x58, 0x82, 0x59, 0x81, 0x59, 0x83, 0xdb, 0x48, 0x40, 0x0f,
	0x62, 0xa2, 0x1e, 0xc8, 0x38, 0x9f, 0xd4, 0xc4, 0xb4, 0x20, 0xa8, 0xbc, 0x92, 0x11, 0x17, 0x07,
	0x4c, 0x0c, 0xab, 0x35, 0x42, 0x5c, 0x2c, 0x48, 0x36, 0x80, 0xd9, 0x4a, 0x8e, 0x5c, 0xac, 0xae,
	0x79, 0x25, 0x45, 0x95, 0x42, 0x92, 0x5c, 0x1c, 0x20, 0x81, 0xf8, 0xec, 0xd4, 0x4a, 0xa8, 0x26,
	0x76, 0x10, 0xdf, 0x3b, 0xb5, 0x52, 0x48, 0x96, 0x8b, 0x0b, 0x2c, 0x55, 0x96, 0x98, 0x53, 0x9a,
	0x0a, 0xd5, 0xcd, 0x09, 0x12, 0x09, 0x03, 0x09, 0x38, 0x71, 0x44, 0x41, 0xfd, 0x98, 0xc4, 0x06,
	0xf6, 0xb2, 0x31, 0x20, 0x00, 0x00, 0xff, 0xff, 0xa1, 0x74, 0xee, 0x30, 0x00, 0x01, 0x00, 0x00,
}
