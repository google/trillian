// Licensed to the Apache Software Foundation (ASF) under one or more
// contributor license agreements.  See the NOTICE file distributed with
// this work for additional information regarding copyright ownership.
// The ASF licenses this file to You under the Apache License, Version 2.0
// (the "License"); you may not use this file except in compliance with
// the License.  You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by starcgen. DO NOT EDIT.
// File: batchmap.shims.go

package batchmap

import (
	"fmt"
	"io"
	"reflect"

	// Library imports
	"context"
	"github.com/apache/beam/sdks/go/pkg/beam/core/runtime"
	"github.com/apache/beam/sdks/go/pkg/beam/core/runtime/exec"
	"github.com/apache/beam/sdks/go/pkg/beam/core/util/reflectx"
	"github.com/google/trillian/experimental/batchmap/tilepb"
)

func init() {
	runtime.RegisterFunction(entryToNodeHashFn)
	runtime.RegisterFunction(partitionByPrefixLenFn)
	runtime.RegisterFunction(tileToNodeHashFn)
	runtime.RegisterType(reflect.TypeOf((*context.Context)(nil)).Elem())
	runtime.RegisterType(reflect.TypeOf((*leafShardFn)(nil)).Elem())
	runtime.RegisterType(reflect.TypeOf((*nodeHash)(nil)).Elem())
	runtime.RegisterType(reflect.TypeOf((*tileHashFn)(nil)).Elem())
	runtime.RegisterType(reflect.TypeOf((*tileUpdateFn)(nil)).Elem())
	runtime.RegisterType(reflect.TypeOf((*tilepb.Entry)(nil)).Elem())
	runtime.RegisterType(reflect.TypeOf((*tilepb.Tile)(nil)).Elem())
	reflectx.RegisterStructWrapper(reflect.TypeOf((*leafShardFn)(nil)).Elem(), wrapMakerLeafShardFn)
	reflectx.RegisterStructWrapper(reflect.TypeOf((*tileHashFn)(nil)).Elem(), wrapMakerTileHashFn)
	reflectx.RegisterStructWrapper(reflect.TypeOf((*tileUpdateFn)(nil)).Elem(), wrapMakerTileUpdateFn)
	reflectx.RegisterFunc(reflect.TypeOf((*func(context.Context,[]byte,func(*nodeHash) bool) (*tilepb.Tile,error))(nil)).Elem(), funcMakerContext۰ContextSliceOfByteIterNodeHashГᏘTilepb۰TileError)
	reflectx.RegisterFunc(reflect.TypeOf((*func(context.Context,[]byte,func(**tilepb.Tile) bool,func(*nodeHash) bool) (*tilepb.Tile,error))(nil)).Elem(), funcMakerContext۰ContextSliceOfByteIterᏘTilepb۰TileIterNodeHashГᏘTilepb۰TileError)
	reflectx.RegisterFunc(reflect.TypeOf((*func(nodeHash) ([]byte,nodeHash))(nil)).Elem(), funcMakerNodeHashГSliceOfByteNodeHash)
	reflectx.RegisterFunc(reflect.TypeOf((*func() ())(nil)).Elem(), funcMakerГ)
	reflectx.RegisterFunc(reflect.TypeOf((*func(*tilepb.Entry) (nodeHash))(nil)).Elem(), funcMakerᏘTilepb۰EntryГNodeHash)
	reflectx.RegisterFunc(reflect.TypeOf((*func(*tilepb.Tile) (int))(nil)).Elem(), funcMakerᏘTilepb۰TileГInt)
	reflectx.RegisterFunc(reflect.TypeOf((*func(*tilepb.Tile) (nodeHash))(nil)).Elem(), funcMakerᏘTilepb۰TileГNodeHash)
	exec.RegisterInput(reflect.TypeOf((*func(*nodeHash) (bool))(nil)).Elem(), iterMakerNodeHash)
	exec.RegisterInput(reflect.TypeOf((*func(**tilepb.Tile) (bool))(nil)).Elem(), iterMakerᏘTilepb۰Tile)
}

func wrapMakerLeafShardFn(fn interface{}) map[string]reflectx.Func {
	dfn := fn.(*leafShardFn)
	return map[string]reflectx.Func{
		"ProcessElement": reflectx.MakeFunc(func(a0 nodeHash) ([]byte, nodeHash) { return dfn.ProcessElement(a0) }),
	}
}

func wrapMakerTileHashFn(fn interface{}) map[string]reflectx.Func {
	dfn := fn.(*tileHashFn)
	return map[string]reflectx.Func{
		"ProcessElement": reflectx.MakeFunc(func(a0 context.Context, a1 []byte, a2 func(*nodeHash) bool) (*tilepb.Tile, error) { return dfn.ProcessElement(a0, a1, a2) }),
		"Setup": reflectx.MakeFunc(func() { dfn.Setup() }),
	}
}

func wrapMakerTileUpdateFn(fn interface{}) map[string]reflectx.Func {
	dfn := fn.(*tileUpdateFn)
	return map[string]reflectx.Func{
		"ProcessElement": reflectx.MakeFunc(func(a0 context.Context, a1 []byte, a2 func(**tilepb.Tile) bool, a3 func(*nodeHash) bool) (*tilepb.Tile, error) { return dfn.ProcessElement(a0, a1, a2, a3) }),
		"Setup": reflectx.MakeFunc(func() { dfn.Setup() }),
	}
}

type callerContext۰ContextSliceOfByteIterNodeHashГᏘTilepb۰TileError struct {
	fn func(context.Context,[]byte,func(*nodeHash) bool) (*tilepb.Tile,error)
}

func funcMakerContext۰ContextSliceOfByteIterNodeHashГᏘTilepb۰TileError(fn interface{}) reflectx.Func {
	f := fn.(func(context.Context,[]byte,func(*nodeHash) bool) (*tilepb.Tile,error))
	return &callerContext۰ContextSliceOfByteIterNodeHashГᏘTilepb۰TileError{fn: f}
}

func (c *callerContext۰ContextSliceOfByteIterNodeHashГᏘTilepb۰TileError) Name() string {
	return reflectx.FunctionName(c.fn)
}

func (c *callerContext۰ContextSliceOfByteIterNodeHashГᏘTilepb۰TileError) Type() reflect.Type {
	return reflect.TypeOf(c.fn)
}

func (c *callerContext۰ContextSliceOfByteIterNodeHashГᏘTilepb۰TileError) Call(args []interface{}) []interface{} {
	out0, out1 := c.fn(args[0].(context.Context), args[1].([]byte), args[2].(func(*nodeHash) bool))
	return []interface{}{out0, out1}
}

func (c *callerContext۰ContextSliceOfByteIterNodeHashГᏘTilepb۰TileError) Call3x2(arg0, arg1, arg2 interface{}) (interface{}, interface{}) {
	return c.fn(arg0.(context.Context), arg1.([]byte), arg2.(func(*nodeHash) bool))
}

type callerContext۰ContextSliceOfByteIterᏘTilepb۰TileIterNodeHashГᏘTilepb۰TileError struct {
	fn func(context.Context,[]byte,func(**tilepb.Tile) bool,func(*nodeHash) bool) (*tilepb.Tile,error)
}

func funcMakerContext۰ContextSliceOfByteIterᏘTilepb۰TileIterNodeHashГᏘTilepb۰TileError(fn interface{}) reflectx.Func {
	f := fn.(func(context.Context,[]byte,func(**tilepb.Tile) bool,func(*nodeHash) bool) (*tilepb.Tile,error))
	return &callerContext۰ContextSliceOfByteIterᏘTilepb۰TileIterNodeHashГᏘTilepb۰TileError{fn: f}
}

func (c *callerContext۰ContextSliceOfByteIterᏘTilepb۰TileIterNodeHashГᏘTilepb۰TileError) Name() string {
	return reflectx.FunctionName(c.fn)
}

func (c *callerContext۰ContextSliceOfByteIterᏘTilepb۰TileIterNodeHashГᏘTilepb۰TileError) Type() reflect.Type {
	return reflect.TypeOf(c.fn)
}

func (c *callerContext۰ContextSliceOfByteIterᏘTilepb۰TileIterNodeHashГᏘTilepb۰TileError) Call(args []interface{}) []interface{} {
	out0, out1 := c.fn(args[0].(context.Context), args[1].([]byte), args[2].(func(**tilepb.Tile) bool), args[3].(func(*nodeHash) bool))
	return []interface{}{out0, out1}
}

func (c *callerContext۰ContextSliceOfByteIterᏘTilepb۰TileIterNodeHashГᏘTilepb۰TileError) Call4x2(arg0, arg1, arg2, arg3 interface{}) (interface{}, interface{}) {
	return c.fn(arg0.(context.Context), arg1.([]byte), arg2.(func(**tilepb.Tile) bool), arg3.(func(*nodeHash) bool))
}

type callerNodeHashГSliceOfByteNodeHash struct {
	fn func(nodeHash) ([]byte,nodeHash)
}

func funcMakerNodeHashГSliceOfByteNodeHash(fn interface{}) reflectx.Func {
	f := fn.(func(nodeHash) ([]byte,nodeHash))
	return &callerNodeHashГSliceOfByteNodeHash{fn: f}
}

func (c *callerNodeHashГSliceOfByteNodeHash) Name() string {
	return reflectx.FunctionName(c.fn)
}

func (c *callerNodeHashГSliceOfByteNodeHash) Type() reflect.Type {
	return reflect.TypeOf(c.fn)
}

func (c *callerNodeHashГSliceOfByteNodeHash) Call(args []interface{}) []interface{} {
	out0, out1 := c.fn(args[0].(nodeHash))
	return []interface{}{out0, out1}
}

func (c *callerNodeHashГSliceOfByteNodeHash) Call1x2(arg0 interface{}) (interface{}, interface{}) {
	return c.fn(arg0.(nodeHash))
}

type callerГ struct {
	fn func() ()
}

func funcMakerГ(fn interface{}) reflectx.Func {
	f := fn.(func() ())
	return &callerГ{fn: f}
}

func (c *callerГ) Name() string {
	return reflectx.FunctionName(c.fn)
}

func (c *callerГ) Type() reflect.Type {
	return reflect.TypeOf(c.fn)
}

func (c *callerГ) Call(args []interface{}) []interface{} {
	c.fn()
	return []interface{}{}
}

func (c *callerГ) Call0x0() () {
	c.fn()
}

type callerᏘTilepb۰EntryГNodeHash struct {
	fn func(*tilepb.Entry) (nodeHash)
}

func funcMakerᏘTilepb۰EntryГNodeHash(fn interface{}) reflectx.Func {
	f := fn.(func(*tilepb.Entry) (nodeHash))
	return &callerᏘTilepb۰EntryГNodeHash{fn: f}
}

func (c *callerᏘTilepb۰EntryГNodeHash) Name() string {
	return reflectx.FunctionName(c.fn)
}

func (c *callerᏘTilepb۰EntryГNodeHash) Type() reflect.Type {
	return reflect.TypeOf(c.fn)
}

func (c *callerᏘTilepb۰EntryГNodeHash) Call(args []interface{}) []interface{} {
	out0 := c.fn(args[0].(*tilepb.Entry))
	return []interface{}{out0}
}

func (c *callerᏘTilepb۰EntryГNodeHash) Call1x1(arg0 interface{}) (interface{}) {
	return c.fn(arg0.(*tilepb.Entry))
}

type callerᏘTilepb۰TileГInt struct {
	fn func(*tilepb.Tile) (int)
}

func funcMakerᏘTilepb۰TileГInt(fn interface{}) reflectx.Func {
	f := fn.(func(*tilepb.Tile) (int))
	return &callerᏘTilepb۰TileГInt{fn: f}
}

func (c *callerᏘTilepb۰TileГInt) Name() string {
	return reflectx.FunctionName(c.fn)
}

func (c *callerᏘTilepb۰TileГInt) Type() reflect.Type {
	return reflect.TypeOf(c.fn)
}

func (c *callerᏘTilepb۰TileГInt) Call(args []interface{}) []interface{} {
	out0 := c.fn(args[0].(*tilepb.Tile))
	return []interface{}{out0}
}

func (c *callerᏘTilepb۰TileГInt) Call1x1(arg0 interface{}) (interface{}) {
	return c.fn(arg0.(*tilepb.Tile))
}

type callerᏘTilepb۰TileГNodeHash struct {
	fn func(*tilepb.Tile) (nodeHash)
}

func funcMakerᏘTilepb۰TileГNodeHash(fn interface{}) reflectx.Func {
	f := fn.(func(*tilepb.Tile) (nodeHash))
	return &callerᏘTilepb۰TileГNodeHash{fn: f}
}

func (c *callerᏘTilepb۰TileГNodeHash) Name() string {
	return reflectx.FunctionName(c.fn)
}

func (c *callerᏘTilepb۰TileГNodeHash) Type() reflect.Type {
	return reflect.TypeOf(c.fn)
}

func (c *callerᏘTilepb۰TileГNodeHash) Call(args []interface{}) []interface{} {
	out0 := c.fn(args[0].(*tilepb.Tile))
	return []interface{}{out0}
}

func (c *callerᏘTilepb۰TileГNodeHash) Call1x1(arg0 interface{}) (interface{}) {
	return c.fn(arg0.(*tilepb.Tile))
}

type iterNative struct {
	s     exec.ReStream
	fn    interface{}

	// cur is the "current" stream, if any.
	cur exec.Stream
}

func (v *iterNative) Init() error {
	cur, err := v.s.Open()
	if err != nil {
		return err
	}
	v.cur = cur
	return nil
}

func (v *iterNative) Value() interface{} {
	return v.fn
}

func (v *iterNative) Reset() error {
	if err := v.cur.Close(); err != nil {
		return err
	}
	v.cur = nil
	return nil
}

func iterMakerNodeHash(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readNodeHash
	return ret
}

func (v *iterNative) readNodeHash(value *nodeHash) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*value = elm.Elm.(nodeHash)
	return true
}

func iterMakerᏘTilepb۰Tile(s exec.ReStream) exec.ReusableInput {
	ret := &iterNative{s: s}
	ret.fn = ret.readᏘTilepb۰Tile
	return ret
}

func (v *iterNative) readᏘTilepb۰Tile(value **tilepb.Tile) bool {
	elm, err := v.cur.Read()
	if err != nil {
		if err == io.EOF {
			return false
		}
		panic(fmt.Sprintf("broken stream: %v", err))
	}
	*value = elm.Elm.(*tilepb.Tile)
	return true
}


// DO NOT MODIFY: GENERATED CODE
