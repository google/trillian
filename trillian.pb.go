// Code generated by protoc-gen-go.
// source: trillian.proto
// DO NOT EDIT!

package trillian

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type SignatureAlgorithm int32

const (
	SignatureAlgorithm_ECDSA SignatureAlgorithm = 0
	SignatureAlgorithm_RSA   SignatureAlgorithm = 1
)

var SignatureAlgorithm_name = map[int32]string{
	0: "ECDSA",
	1: "RSA",
}
var SignatureAlgorithm_value = map[string]int32{
	"ECDSA": 0,
	"RSA":   1,
}

func (x SignatureAlgorithm) Enum() *SignatureAlgorithm {
	p := new(SignatureAlgorithm)
	*p = x
	return p
}
func (x SignatureAlgorithm) String() string {
	return proto.EnumName(SignatureAlgorithm_name, int32(x))
}
func (x *SignatureAlgorithm) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(SignatureAlgorithm_value, data, "SignatureAlgorithm")
	if err != nil {
		return err
	}
	*x = SignatureAlgorithm(value)
	return nil
}
func (SignatureAlgorithm) EnumDescriptor() ([]byte, []int) { return fileDescriptor1, []int{0} }

type HashAlgorithm int32

const (
	HashAlgorithm_SHA256 HashAlgorithm = 0
)

var HashAlgorithm_name = map[int32]string{
	0: "SHA256",
}
var HashAlgorithm_value = map[string]int32{
	"SHA256": 0,
}

func (x HashAlgorithm) Enum() *HashAlgorithm {
	p := new(HashAlgorithm)
	*p = x
	return p
}
func (x HashAlgorithm) String() string {
	return proto.EnumName(HashAlgorithm_name, int32(x))
}
func (x *HashAlgorithm) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(HashAlgorithm_value, data, "HashAlgorithm")
	if err != nil {
		return err
	}
	*x = HashAlgorithm(value)
	return nil
}
func (HashAlgorithm) EnumDescriptor() ([]byte, []int) { return fileDescriptor1, []int{1} }

type DigitallySigned struct {
	SignatureAlgorithm *SignatureAlgorithm `protobuf:"varint,1,opt,name=signature_algorithm,enum=trillian.SignatureAlgorithm" json:"signature_algorithm,omitempty"`
	HashAlgorithm      *HashAlgorithm      `protobuf:"varint,2,opt,name=hash_algorithm,enum=trillian.HashAlgorithm" json:"hash_algorithm,omitempty"`
	Signature          []byte              `protobuf:"bytes,3,opt,name=signature" json:"signature,omitempty"`
	XXX_unrecognized   []byte              `json:"-"`
}

func (m *DigitallySigned) Reset()                    { *m = DigitallySigned{} }
func (m *DigitallySigned) String() string            { return proto.CompactTextString(m) }
func (*DigitallySigned) ProtoMessage()               {}
func (*DigitallySigned) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{0} }

func (m *DigitallySigned) GetSignatureAlgorithm() SignatureAlgorithm {
	if m != nil && m.SignatureAlgorithm != nil {
		return *m.SignatureAlgorithm
	}
	return SignatureAlgorithm_ECDSA
}

func (m *DigitallySigned) GetHashAlgorithm() HashAlgorithm {
	if m != nil && m.HashAlgorithm != nil {
		return *m.HashAlgorithm
	}
	return HashAlgorithm_SHA256
}

func (m *DigitallySigned) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

type SignedEntryTimestamp struct {
	TimestampNanos   *int64           `protobuf:"varint,1,opt,name=timestamp_nanos" json:"timestamp_nanos,omitempty"`
	LogId            []byte           `protobuf:"bytes,2,opt,name=log_id" json:"log_id,omitempty"`
	Signature        *DigitallySigned `protobuf:"bytes,3,opt,name=signature" json:"signature,omitempty"`
	XXX_unrecognized []byte           `json:"-"`
}

func (m *SignedEntryTimestamp) Reset()                    { *m = SignedEntryTimestamp{} }
func (m *SignedEntryTimestamp) String() string            { return proto.CompactTextString(m) }
func (*SignedEntryTimestamp) ProtoMessage()               {}
func (*SignedEntryTimestamp) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{1} }

func (m *SignedEntryTimestamp) GetTimestampNanos() int64 {
	if m != nil && m.TimestampNanos != nil {
		return *m.TimestampNanos
	}
	return 0
}

func (m *SignedEntryTimestamp) GetLogId() []byte {
	if m != nil {
		return m.LogId
	}
	return nil
}

func (m *SignedEntryTimestamp) GetSignature() *DigitallySigned {
	if m != nil {
		return m.Signature
	}
	return nil
}

// SignedLogRoot represents a commitment by a Log to a particular tree.
type SignedLogRoot struct {
	// epoch nanoseconds, good until 2500ish
	TimestampNanos *int64 `protobuf:"varint,1,opt,name=timestamp_nanos" json:"timestamp_nanos,omitempty"`
	RootHash       []byte `protobuf:"bytes,2,opt,name=root_hash" json:"root_hash,omitempty"`
	// TreeSize is the number of entries in the tree.
	TreeSize *int64 `protobuf:"varint,3,opt,name=tree_size" json:"tree_size,omitempty"`
	// TODO(al): define serialised format for the signature scheme.
	Signature        *DigitallySigned `protobuf:"bytes,4,opt,name=signature" json:"signature,omitempty"`
	LogId            []byte           `protobuf:"bytes,5,opt,name=log_id" json:"log_id,omitempty"`
	TreeRevision     *int64           `protobuf:"varint,6,opt,name=tree_revision" json:"tree_revision,omitempty"`
	XXX_unrecognized []byte           `json:"-"`
}

func (m *SignedLogRoot) Reset()                    { *m = SignedLogRoot{} }
func (m *SignedLogRoot) String() string            { return proto.CompactTextString(m) }
func (*SignedLogRoot) ProtoMessage()               {}
func (*SignedLogRoot) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{2} }

func (m *SignedLogRoot) GetTimestampNanos() int64 {
	if m != nil && m.TimestampNanos != nil {
		return *m.TimestampNanos
	}
	return 0
}

func (m *SignedLogRoot) GetRootHash() []byte {
	if m != nil {
		return m.RootHash
	}
	return nil
}

func (m *SignedLogRoot) GetTreeSize() int64 {
	if m != nil && m.TreeSize != nil {
		return *m.TreeSize
	}
	return 0
}

func (m *SignedLogRoot) GetSignature() *DigitallySigned {
	if m != nil {
		return m.Signature
	}
	return nil
}

func (m *SignedLogRoot) GetLogId() []byte {
	if m != nil {
		return m.LogId
	}
	return nil
}

func (m *SignedLogRoot) GetTreeRevision() int64 {
	if m != nil && m.TreeRevision != nil {
		return *m.TreeRevision
	}
	return 0
}

// SignedMapRoot represents a commitment by a Map to a particular tree.
type SignedMapRoot struct {
	TimestampNanos *int64 `protobuf:"varint,1,opt,name=timestamp_nanos" json:"timestamp_nanos,omitempty"`
	RootHash       []byte `protobuf:"bytes,2,opt,name=root_hash" json:"root_hash,omitempty"`
	// TODO(al) add Metadata e.g. list of Log STHs included under a Map's Signed Root etc.?
	// TODO(al): define serialised format for the signature scheme.
	Signature        *DigitallySigned `protobuf:"bytes,3,opt,name=signature" json:"signature,omitempty"`
	MapId            []byte           `protobuf:"bytes,4,opt,name=map_id" json:"map_id,omitempty"`
	TreeRevision     *int64           `protobuf:"varint,5,opt,name=tree_revision" json:"tree_revision,omitempty"`
	XXX_unrecognized []byte           `json:"-"`
}

func (m *SignedMapRoot) Reset()                    { *m = SignedMapRoot{} }
func (m *SignedMapRoot) String() string            { return proto.CompactTextString(m) }
func (*SignedMapRoot) ProtoMessage()               {}
func (*SignedMapRoot) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{3} }

func (m *SignedMapRoot) GetTimestampNanos() int64 {
	if m != nil && m.TimestampNanos != nil {
		return *m.TimestampNanos
	}
	return 0
}

func (m *SignedMapRoot) GetRootHash() []byte {
	if m != nil {
		return m.RootHash
	}
	return nil
}

func (m *SignedMapRoot) GetSignature() *DigitallySigned {
	if m != nil {
		return m.Signature
	}
	return nil
}

func (m *SignedMapRoot) GetMapId() []byte {
	if m != nil {
		return m.MapId
	}
	return nil
}

func (m *SignedMapRoot) GetTreeRevision() int64 {
	if m != nil && m.TreeRevision != nil {
		return *m.TreeRevision
	}
	return 0
}

func init() {
	proto.RegisterType((*DigitallySigned)(nil), "trillian.DigitallySigned")
	proto.RegisterType((*SignedEntryTimestamp)(nil), "trillian.SignedEntryTimestamp")
	proto.RegisterType((*SignedLogRoot)(nil), "trillian.SignedLogRoot")
	proto.RegisterType((*SignedMapRoot)(nil), "trillian.SignedMapRoot")
	proto.RegisterEnum("trillian.SignatureAlgorithm", SignatureAlgorithm_name, SignatureAlgorithm_value)
	proto.RegisterEnum("trillian.HashAlgorithm", HashAlgorithm_name, HashAlgorithm_value)
}

var fileDescriptor1 = []byte{
	// 327 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x94, 0x92, 0xd1, 0x4e, 0xf2, 0x30,
	0x14, 0xc7, 0xd9, 0x37, 0xe0, 0x93, 0x23, 0x0c, 0xac, 0x1a, 0x30, 0x7a, 0x61, 0xb8, 0x22, 0xc4,
	0x60, 0xb2, 0x44, 0x13, 0x2f, 0x17, 0x21, 0xe1, 0x42, 0x6f, 0x98, 0xf7, 0x4b, 0x13, 0x9a, 0xad,
	0x49, 0xd7, 0x2e, 0x6d, 0x35, 0xc1, 0xa7, 0xf0, 0x1d, 0x7c, 0x51, 0xdb, 0x8d, 0x31, 0x20, 0x18,
	0xc3, 0xdd, 0xe9, 0x76, 0xce, 0xff, 0xf7, 0xeb, 0xce, 0xc0, 0xd3, 0x92, 0x32, 0x46, 0x31, 0x9f,
	0x64, 0x52, 0x68, 0x81, 0x4e, 0xca, 0xf3, 0xf0, 0xcb, 0x81, 0xee, 0x94, 0xc6, 0x54, 0x63, 0xc6,
	0x56, 0x21, 0x8d, 0x39, 0x59, 0xa2, 0x27, 0x38, 0x57, 0xa6, 0xc2, 0xfa, 0x5d, 0x92, 0x08, 0xb3,
	0x58, 0x48, 0xaa, 0x93, 0x74, 0xe0, 0xdc, 0x3a, 0x23, 0xcf, 0xbf, 0x99, 0x6c, 0xb2, 0xc2, 0xb2,
	0x29, 0x28, 0x7b, 0xd0, 0x3d, 0x78, 0x09, 0x56, 0xc9, 0xd6, 0xd4, 0xbf, 0x7c, 0xaa, 0x5f, 0x4d,
	0xcd, 0xcd, 0xfb, 0x6a, 0xe0, 0x0c, 0x5a, 0x1b, 0xd6, 0xc0, 0x35, 0xbd, 0xed, 0x61, 0x0a, 0x17,
	0x85, 0xc8, 0x8c, 0x6b, 0xb9, 0x7a, 0xa3, 0x29, 0x51, 0x1a, 0xa7, 0x19, 0xea, 0x43, 0x57, 0x97,
	0x87, 0x88, 0x63, 0x2e, 0x54, 0xae, 0xe4, 0x22, 0x0f, 0x9a, 0x4c, 0xc4, 0x11, 0x5d, 0xe6, 0xb0,
	0x36, 0xba, 0xdb, 0xcf, 0x3c, 0xf5, 0xaf, 0x2a, 0xfe, 0xde, 0x6d, 0x87, 0xdf, 0x0e, 0x74, 0x8a,
	0xf2, 0x45, 0xc4, 0x0b, 0x21, 0xf4, 0xef, 0x20, 0x23, 0x2b, 0x4d, 0x43, 0x64, 0xaf, 0xb8, 0x66,
	0x99, 0x47, 0x5a, 0x12, 0x12, 0x29, 0xfa, 0x59, 0xb0, 0xdc, 0x5d, 0x7c, 0xfd, 0x0f, 0xfc, 0x96,
	0x7c, 0x23, 0x0f, 0xbc, 0x84, 0x4e, 0x1e, 0x28, 0xc9, 0x07, 0x55, 0x54, 0xf0, 0x41, 0xd3, 0x86,
	0xda, 0x3d, 0xad, 0x2d, 0x5f, 0x71, 0x76, 0xb4, 0xe5, 0x51, 0x5f, 0xc4, 0x2a, 0xa5, 0x38, 0xb3,
	0x4a, 0xf5, 0xc3, 0x4a, 0xd6, 0xd4, 0x1d, 0x8f, 0x00, 0x1d, 0xf8, 0x03, 0x5a, 0xd0, 0x98, 0x3d,
	0x4f, 0xc3, 0xa0, 0x57, 0x43, 0xff, 0xc1, 0x5d, 0x98, 0xc2, 0x19, 0x5f, 0x43, 0x67, 0x77, 0xeb,
	0x00, 0xcd, 0x70, 0x1e, 0xf8, 0x0f, 0x8f, 0xbd, 0xda, 0x4f, 0x00, 0x00, 0x00, 0xff, 0xff, 0xb2,
	0x92, 0xab, 0x17, 0x9c, 0x02, 0x00, 0x00,
}
