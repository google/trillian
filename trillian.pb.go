// Code generated by protoc-gen-go.
// source: trillian.proto
// DO NOT EDIT!

package trillian

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// Supported hash algorithms. The numbering space is the same as for TLS,
// given in RFC 5246 s7.4.1.4.1 and at:
// http://www.iana.org/assignments/tls-parameters/tls-parameters.xhtml#tls-parameters-18
type HashAlgorithm int32

const (
	HashAlgorithm_NONE   HashAlgorithm = 0
	HashAlgorithm_SHA256 HashAlgorithm = 4
)

var HashAlgorithm_name = map[int32]string{
	0: "NONE",
	4: "SHA256",
}
var HashAlgorithm_value = map[string]int32{
	"NONE":   0,
	"SHA256": 4,
}

func (x HashAlgorithm) String() string {
	return proto.EnumName(HashAlgorithm_name, int32(x))
}
func (HashAlgorithm) EnumDescriptor() ([]byte, []int) { return fileDescriptor1, []int{0} }

// Defines the way empty / node / leaf hashes are constructed incorporating
// preimage protection, which can be application specific.
type HashStrategy int32

const (
	// Hash strategy cannot be determined. Included to enable detection of
	// mismatched proto versions being used. Represents an invalid value.
	HashStrategy_UNKNOWN_HASH_STRATEGY HashStrategy = 0
	// Certificate Transparency strategy: leaf hash prefix = 0x00, node prefix =
	// 0x01, empty hash is digest([]byte{}), as defined in the specification.
	HashStrategy_RFC_6962 HashStrategy = 1
)

var HashStrategy_name = map[int32]string{
	0: "UNKNOWN_HASH_STRATEGY",
	1: "RFC_6962",
}
var HashStrategy_value = map[string]int32{
	"UNKNOWN_HASH_STRATEGY": 0,
	"RFC_6962":              1,
}

func (x HashStrategy) String() string {
	return proto.EnumName(HashStrategy_name, int32(x))
}
func (HashStrategy) EnumDescriptor() ([]byte, []int) { return fileDescriptor1, []int{1} }

// Supported signature algorithms. The numbering space is the same as for TLS,
// given in RFC 5246 s7.4.1.4.1 and at:
// http://www.iana.org/assignments/tls-parameters/tls-parameters.xhtml#tls-parameters-16
type SignatureAlgorithm int32

const (
	SignatureAlgorithm_ANONYMOUS SignatureAlgorithm = 0
	SignatureAlgorithm_RSA       SignatureAlgorithm = 1
	SignatureAlgorithm_ECDSA     SignatureAlgorithm = 3
)

var SignatureAlgorithm_name = map[int32]string{
	0: "ANONYMOUS",
	1: "RSA",
	3: "ECDSA",
}
var SignatureAlgorithm_value = map[string]int32{
	"ANONYMOUS": 0,
	"RSA":       1,
	"ECDSA":     3,
}

func (x SignatureAlgorithm) String() string {
	return proto.EnumName(SignatureAlgorithm_name, int32(x))
}
func (SignatureAlgorithm) EnumDescriptor() ([]byte, []int) { return fileDescriptor1, []int{2} }

// State of the tree.
type TreeState int32

const (
	// Tree state cannot be determined. Included to enable detection of
	// mismatched proto versions being used. Represents an invalid value.
	TreeState_UNKNOWN_TREE_STATE TreeState = 0
	// Active trees are able to respond to both read and write requests.
	TreeState_ACTIVE TreeState = 1
	// Frozen trees are only able to respond to read requests, writting to a
	// frozen tree is forbidden.
	TreeState_FROZEN TreeState = 2
	// Tree was been deleted, therefore is invisible and acts similarly to a
	// non-existing tree for all requests.
	// A soft deleted tree may be undeleted while the soft-deletion period has not
	// passed.
	TreeState_SOFT_DELETED TreeState = 3
	// A hard deleted tree was been definitely deleted and cannot be recovered.
	// Acts an a non-existing tree for all read and write requests, but blocks the
	// tree ID from ever being reused.
	TreeState_HARD_DELETED TreeState = 4
)

var TreeState_name = map[int32]string{
	0: "UNKNOWN_TREE_STATE",
	1: "ACTIVE",
	2: "FROZEN",
	3: "SOFT_DELETED",
	4: "HARD_DELETED",
}
var TreeState_value = map[string]int32{
	"UNKNOWN_TREE_STATE": 0,
	"ACTIVE":             1,
	"FROZEN":             2,
	"SOFT_DELETED":       3,
	"HARD_DELETED":       4,
}

func (x TreeState) String() string {
	return proto.EnumName(TreeState_name, int32(x))
}
func (TreeState) EnumDescriptor() ([]byte, []int) { return fileDescriptor1, []int{3} }

// Type of the tree.
type TreeType int32

const (
	// Tree type cannot be determined. Included to enable detection of
	// mismatched proto versions being used. Represents an invalid value.
	TreeType_UNKNOWN_TREE_TYPE TreeType = 0
	// Tree represents a verifiable log.
	TreeType_LOG TreeType = 1
	// Tree represents a verifiable map.
	TreeType_MAP TreeType = 2
)

var TreeType_name = map[int32]string{
	0: "UNKNOWN_TREE_TYPE",
	1: "LOG",
	2: "MAP",
}
var TreeType_value = map[string]int32{
	"UNKNOWN_TREE_TYPE": 0,
	"LOG":               1,
	"MAP":               2,
}

func (x TreeType) String() string {
	return proto.EnumName(TreeType_name, int32(x))
}
func (TreeType) EnumDescriptor() ([]byte, []int) { return fileDescriptor1, []int{4} }

// Duplicate policy of a tree.
type DuplicatePolicy int32

const (
	// Policy cannot be determined. Included to enable detection of
	// mismatched proto versions being used. Represents an invalid value.
	DuplicatePolicy_UNKNOWN_DUPLICATE_POLICY DuplicatePolicy = 0
	// Duplicates are not allowed in the tree and will cause errors on insertion.
	DuplicatePolicy_DUPLICATES_NOT_ALLOWED DuplicatePolicy = 1
	// Duplicates are allowed in the tree.
	DuplicatePolicy_DUPLICATES_ALLOWED DuplicatePolicy = 2
)

var DuplicatePolicy_name = map[int32]string{
	0: "UNKNOWN_DUPLICATE_POLICY",
	1: "DUPLICATES_NOT_ALLOWED",
	2: "DUPLICATES_ALLOWED",
}
var DuplicatePolicy_value = map[string]int32{
	"UNKNOWN_DUPLICATE_POLICY": 0,
	"DUPLICATES_NOT_ALLOWED":   1,
	"DUPLICATES_ALLOWED":       2,
}

func (x DuplicatePolicy) String() string {
	return proto.EnumName(DuplicatePolicy_name, int32(x))
}
func (DuplicatePolicy) EnumDescriptor() ([]byte, []int) { return fileDescriptor1, []int{5} }

// Represents a tree, which may be either a verifiable log or map.
// Readonly attributes are assigned at tree creation, after which they may not
// be modified.
type Tree struct {
	// ID of the tree.
	// Readonly.
	TreeId int64 `protobuf:"varint,1,opt,name=tree_id,json=treeId" json:"tree_id,omitempty"`
	// State of the tree.
	// Trees are active after creation. At any point the tree may transition
	// between ACTIVE and FROZEN.
	// Deleted trees are set as SOFT_DELETED for a certain time period, after
	// which they'll automatically transition to HARD_DELETED.
	State TreeState `protobuf:"varint,2,opt,name=state,enum=trillian.TreeState" json:"state,omitempty"`
	// Type of the tree.
	// Readonly.
	TreeType TreeType `protobuf:"varint,3,opt,name=tree_type,json=treeType,enum=trillian.TreeType" json:"tree_type,omitempty"`
	// Hash strategy to be used by the tree.
	// Readonly.
	HashStrategy HashStrategy `protobuf:"varint,4,opt,name=hash_strategy,json=hashStrategy,enum=trillian.HashStrategy" json:"hash_strategy,omitempty"`
	// Hash algorithm to be used by the tree.
	// Readonly.
	HashAlgorithm HashAlgorithm `protobuf:"varint,5,opt,name=hash_algorithm,json=hashAlgorithm,enum=trillian.HashAlgorithm" json:"hash_algorithm,omitempty"`
	// Signature algorithm to be used by the tree.
	// Readonly.
	SignatureAlgorithm SignatureAlgorithm `protobuf:"varint,6,opt,name=signature_algorithm,json=signatureAlgorithm,enum=trillian.SignatureAlgorithm" json:"signature_algorithm,omitempty"`
	// Duplicate policy to be used by the tree.
	// Readonly.
	DuplicatePolicy DuplicatePolicy `protobuf:"varint,7,opt,name=duplicate_policy,json=duplicatePolicy,enum=trillian.DuplicatePolicy" json:"duplicate_policy,omitempty"`
	// Display name of the tree.
	// Optional.
	DisplayName string `protobuf:"bytes,8,opt,name=display_name,json=displayName" json:"display_name,omitempty"`
	// Description of the tree,
	// Optional.
	Description string `protobuf:"bytes,9,opt,name=description" json:"description,omitempty"`
	// Timestamp of tree creation.
	// Readonly.
	CreateTimeMillisSinceEpoch int64 `protobuf:"varint,10,opt,name=create_time_millis_since_epoch,json=createTimeMillisSinceEpoch" json:"create_time_millis_since_epoch,omitempty"`
	// Timestamp of last tree update.
	// Readonly (automatically assigned on updates).
	UpdateTimeMillisSinceEpoch int64 `protobuf:"varint,11,opt,name=update_time_millis_since_epoch,json=updateTimeMillisSinceEpoch" json:"update_time_millis_since_epoch,omitempty"`
}

func (m *Tree) Reset()                    { *m = Tree{} }
func (m *Tree) String() string            { return proto.CompactTextString(m) }
func (*Tree) ProtoMessage()               {}
func (*Tree) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{0} }

func (m *Tree) GetTreeId() int64 {
	if m != nil {
		return m.TreeId
	}
	return 0
}

func (m *Tree) GetState() TreeState {
	if m != nil {
		return m.State
	}
	return TreeState_UNKNOWN_TREE_STATE
}

func (m *Tree) GetTreeType() TreeType {
	if m != nil {
		return m.TreeType
	}
	return TreeType_UNKNOWN_TREE_TYPE
}

func (m *Tree) GetHashStrategy() HashStrategy {
	if m != nil {
		return m.HashStrategy
	}
	return HashStrategy_UNKNOWN_HASH_STRATEGY
}

func (m *Tree) GetHashAlgorithm() HashAlgorithm {
	if m != nil {
		return m.HashAlgorithm
	}
	return HashAlgorithm_NONE
}

func (m *Tree) GetSignatureAlgorithm() SignatureAlgorithm {
	if m != nil {
		return m.SignatureAlgorithm
	}
	return SignatureAlgorithm_ANONYMOUS
}

func (m *Tree) GetDuplicatePolicy() DuplicatePolicy {
	if m != nil {
		return m.DuplicatePolicy
	}
	return DuplicatePolicy_UNKNOWN_DUPLICATE_POLICY
}

func (m *Tree) GetDisplayName() string {
	if m != nil {
		return m.DisplayName
	}
	return ""
}

func (m *Tree) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *Tree) GetCreateTimeMillisSinceEpoch() int64 {
	if m != nil {
		return m.CreateTimeMillisSinceEpoch
	}
	return 0
}

func (m *Tree) GetUpdateTimeMillisSinceEpoch() int64 {
	if m != nil {
		return m.UpdateTimeMillisSinceEpoch
	}
	return 0
}

// Protocol buffer encoding of the TLS DigitallySigned type, from
// RFC 5246 s4.7.
type DigitallySigned struct {
	SignatureAlgorithm SignatureAlgorithm `protobuf:"varint,1,opt,name=signature_algorithm,json=signatureAlgorithm,enum=trillian.SignatureAlgorithm" json:"signature_algorithm,omitempty"`
	HashAlgorithm      HashAlgorithm      `protobuf:"varint,2,opt,name=hash_algorithm,json=hashAlgorithm,enum=trillian.HashAlgorithm" json:"hash_algorithm,omitempty"`
	Signature          []byte             `protobuf:"bytes,3,opt,name=signature,proto3" json:"signature,omitempty"`
}

func (m *DigitallySigned) Reset()                    { *m = DigitallySigned{} }
func (m *DigitallySigned) String() string            { return proto.CompactTextString(m) }
func (*DigitallySigned) ProtoMessage()               {}
func (*DigitallySigned) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{1} }

func (m *DigitallySigned) GetSignatureAlgorithm() SignatureAlgorithm {
	if m != nil {
		return m.SignatureAlgorithm
	}
	return SignatureAlgorithm_ANONYMOUS
}

func (m *DigitallySigned) GetHashAlgorithm() HashAlgorithm {
	if m != nil {
		return m.HashAlgorithm
	}
	return HashAlgorithm_NONE
}

func (m *DigitallySigned) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

type SignedEntryTimestamp struct {
	TimestampNanos int64            `protobuf:"varint,1,opt,name=timestamp_nanos,json=timestampNanos" json:"timestamp_nanos,omitempty"`
	LogId          int64            `protobuf:"varint,2,opt,name=log_id,json=logId" json:"log_id,omitempty"`
	Signature      *DigitallySigned `protobuf:"bytes,3,opt,name=signature" json:"signature,omitempty"`
}

func (m *SignedEntryTimestamp) Reset()                    { *m = SignedEntryTimestamp{} }
func (m *SignedEntryTimestamp) String() string            { return proto.CompactTextString(m) }
func (*SignedEntryTimestamp) ProtoMessage()               {}
func (*SignedEntryTimestamp) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{2} }

func (m *SignedEntryTimestamp) GetTimestampNanos() int64 {
	if m != nil {
		return m.TimestampNanos
	}
	return 0
}

func (m *SignedEntryTimestamp) GetLogId() int64 {
	if m != nil {
		return m.LogId
	}
	return 0
}

func (m *SignedEntryTimestamp) GetSignature() *DigitallySigned {
	if m != nil {
		return m.Signature
	}
	return nil
}

// SignedLogRoot represents a commitment by a Log to a particular tree.
type SignedLogRoot struct {
	// epoch nanoseconds, good until 2500ish
	TimestampNanos int64  `protobuf:"varint,1,opt,name=timestamp_nanos,json=timestampNanos" json:"timestamp_nanos,omitempty"`
	RootHash       []byte `protobuf:"bytes,2,opt,name=root_hash,json=rootHash,proto3" json:"root_hash,omitempty"`
	// TreeSize is the number of entries in the tree.
	TreeSize int64 `protobuf:"varint,3,opt,name=tree_size,json=treeSize" json:"tree_size,omitempty"`
	// TODO(al): define serialized format for the signature scheme.
	Signature    *DigitallySigned `protobuf:"bytes,4,opt,name=signature" json:"signature,omitempty"`
	LogId        int64            `protobuf:"varint,5,opt,name=log_id,json=logId" json:"log_id,omitempty"`
	TreeRevision int64            `protobuf:"varint,6,opt,name=tree_revision,json=treeRevision" json:"tree_revision,omitempty"`
}

func (m *SignedLogRoot) Reset()                    { *m = SignedLogRoot{} }
func (m *SignedLogRoot) String() string            { return proto.CompactTextString(m) }
func (*SignedLogRoot) ProtoMessage()               {}
func (*SignedLogRoot) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{3} }

func (m *SignedLogRoot) GetTimestampNanos() int64 {
	if m != nil {
		return m.TimestampNanos
	}
	return 0
}

func (m *SignedLogRoot) GetRootHash() []byte {
	if m != nil {
		return m.RootHash
	}
	return nil
}

func (m *SignedLogRoot) GetTreeSize() int64 {
	if m != nil {
		return m.TreeSize
	}
	return 0
}

func (m *SignedLogRoot) GetSignature() *DigitallySigned {
	if m != nil {
		return m.Signature
	}
	return nil
}

func (m *SignedLogRoot) GetLogId() int64 {
	if m != nil {
		return m.LogId
	}
	return 0
}

func (m *SignedLogRoot) GetTreeRevision() int64 {
	if m != nil {
		return m.TreeRevision
	}
	return 0
}

type MapperMetadata struct {
	SourceLogId                  []byte `protobuf:"bytes,1,opt,name=source_log_id,json=sourceLogId,proto3" json:"source_log_id,omitempty"`
	HighestFullyCompletedSeq     int64  `protobuf:"varint,2,opt,name=highest_fully_completed_seq,json=highestFullyCompletedSeq" json:"highest_fully_completed_seq,omitempty"`
	HighestPartiallyCompletedSeq int64  `protobuf:"varint,3,opt,name=highest_partially_completed_seq,json=highestPartiallyCompletedSeq" json:"highest_partially_completed_seq,omitempty"`
}

func (m *MapperMetadata) Reset()                    { *m = MapperMetadata{} }
func (m *MapperMetadata) String() string            { return proto.CompactTextString(m) }
func (*MapperMetadata) ProtoMessage()               {}
func (*MapperMetadata) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{4} }

func (m *MapperMetadata) GetSourceLogId() []byte {
	if m != nil {
		return m.SourceLogId
	}
	return nil
}

func (m *MapperMetadata) GetHighestFullyCompletedSeq() int64 {
	if m != nil {
		return m.HighestFullyCompletedSeq
	}
	return 0
}

func (m *MapperMetadata) GetHighestPartiallyCompletedSeq() int64 {
	if m != nil {
		return m.HighestPartiallyCompletedSeq
	}
	return 0
}

// SignedMapRoot represents a commitment by a Map to a particular tree.
type SignedMapRoot struct {
	TimestampNanos int64           `protobuf:"varint,1,opt,name=timestamp_nanos,json=timestampNanos" json:"timestamp_nanos,omitempty"`
	RootHash       []byte          `protobuf:"bytes,2,opt,name=root_hash,json=rootHash,proto3" json:"root_hash,omitempty"`
	Metadata       *MapperMetadata `protobuf:"bytes,3,opt,name=metadata" json:"metadata,omitempty"`
	// TODO(al): define serialized format for the signature scheme.
	Signature   *DigitallySigned `protobuf:"bytes,4,opt,name=signature" json:"signature,omitempty"`
	MapId       int64            `protobuf:"varint,5,opt,name=map_id,json=mapId" json:"map_id,omitempty"`
	MapRevision int64            `protobuf:"varint,6,opt,name=map_revision,json=mapRevision" json:"map_revision,omitempty"`
}

func (m *SignedMapRoot) Reset()                    { *m = SignedMapRoot{} }
func (m *SignedMapRoot) String() string            { return proto.CompactTextString(m) }
func (*SignedMapRoot) ProtoMessage()               {}
func (*SignedMapRoot) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{5} }

func (m *SignedMapRoot) GetTimestampNanos() int64 {
	if m != nil {
		return m.TimestampNanos
	}
	return 0
}

func (m *SignedMapRoot) GetRootHash() []byte {
	if m != nil {
		return m.RootHash
	}
	return nil
}

func (m *SignedMapRoot) GetMetadata() *MapperMetadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *SignedMapRoot) GetSignature() *DigitallySigned {
	if m != nil {
		return m.Signature
	}
	return nil
}

func (m *SignedMapRoot) GetMapId() int64 {
	if m != nil {
		return m.MapId
	}
	return 0
}

func (m *SignedMapRoot) GetMapRevision() int64 {
	if m != nil {
		return m.MapRevision
	}
	return 0
}

func init() {
	proto.RegisterType((*Tree)(nil), "trillian.Tree")
	proto.RegisterType((*DigitallySigned)(nil), "trillian.DigitallySigned")
	proto.RegisterType((*SignedEntryTimestamp)(nil), "trillian.SignedEntryTimestamp")
	proto.RegisterType((*SignedLogRoot)(nil), "trillian.SignedLogRoot")
	proto.RegisterType((*MapperMetadata)(nil), "trillian.MapperMetadata")
	proto.RegisterType((*SignedMapRoot)(nil), "trillian.SignedMapRoot")
	proto.RegisterEnum("trillian.HashAlgorithm", HashAlgorithm_name, HashAlgorithm_value)
	proto.RegisterEnum("trillian.HashStrategy", HashStrategy_name, HashStrategy_value)
	proto.RegisterEnum("trillian.SignatureAlgorithm", SignatureAlgorithm_name, SignatureAlgorithm_value)
	proto.RegisterEnum("trillian.TreeState", TreeState_name, TreeState_value)
	proto.RegisterEnum("trillian.TreeType", TreeType_name, TreeType_value)
	proto.RegisterEnum("trillian.DuplicatePolicy", DuplicatePolicy_name, DuplicatePolicy_value)
}

func init() { proto.RegisterFile("trillian.proto", fileDescriptor1) }

var fileDescriptor1 = []byte{
	// 919 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xac, 0x55, 0xdd, 0x6e, 0xe3, 0x44,
	0x14, 0xae, 0xf3, 0xd7, 0xe4, 0xe4, 0xa7, 0x66, 0x96, 0x76, 0xbd, 0xbb, 0x15, 0x94, 0x20, 0x44,
	0xc9, 0xc5, 0x22, 0x75, 0xa1, 0x15, 0x42, 0x20, 0x99, 0xc4, 0xdd, 0x44, 0x24, 0x76, 0x64, 0xbb,
	0xac, 0xca, 0xcd, 0x68, 0x88, 0x87, 0x64, 0x24, 0x3b, 0x9e, 0xb5, 0x27, 0x48, 0xd9, 0x97, 0xe0,
	0x7d, 0xb8, 0xe0, 0x41, 0x78, 0x01, 0xde, 0x02, 0xa1, 0x19, 0xdb, 0xf9, 0x69, 0x01, 0x15, 0xd8,
	0xbb, 0x99, 0xef, 0x7c, 0xe7, 0x9b, 0x33, 0xe7, 0x67, 0x06, 0x3a, 0x22, 0x61, 0x61, 0xc8, 0xc8,
	0xf2, 0x39, 0x4f, 0x62, 0x11, 0xa3, 0x7a, 0xb1, 0xef, 0xfe, 0x56, 0x81, 0x8a, 0x9f, 0x50, 0x8a,
	0x1e, 0xc3, 0xa1, 0x48, 0x28, 0xc5, 0x2c, 0x30, 0xb4, 0x33, 0xed, 0xbc, 0xec, 0xd6, 0xe4, 0x76,
	0x14, 0xa0, 0x4f, 0xa0, 0x9a, 0x0a, 0x22, 0xa8, 0x51, 0x3a, 0xd3, 0xce, 0x3b, 0x17, 0x8f, 0x9e,
	0x6f, 0xb4, 0xa4, 0x9f, 0x27, 0x4d, 0x6e, 0xc6, 0x40, 0x9f, 0x42, 0x43, 0x69, 0x88, 0x35, 0xa7,
	0x46, 0x59, 0xd1, 0xd1, 0x3e, 0xdd, 0x5f, 0x73, 0xea, 0xd6, 0x45, 0xbe, 0x42, 0x5f, 0x42, 0x7b,
	0x41, 0xd2, 0x05, 0x4e, 0x45, 0x42, 0x04, 0x9d, 0xaf, 0x8d, 0x8a, 0x72, 0x3a, 0xd9, 0x3a, 0x0d,
	0x49, 0xba, 0xf0, 0x72, 0xab, 0xdb, 0x5a, 0xec, 0xec, 0xd0, 0xd7, 0xd0, 0x51, 0xce, 0x24, 0x9c,
	0xc7, 0x09, 0x13, 0x8b, 0xc8, 0xa8, 0x2a, 0xef, 0xc7, 0xfb, 0xde, 0x66, 0x61, 0x76, 0xd5, 0x59,
	0x9b, 0x2d, 0x9a, 0xc0, 0xa3, 0x94, 0xcd, 0x97, 0x44, 0xac, 0x12, 0xba, 0x23, 0x52, 0x53, 0x22,
	0xa7, 0x5b, 0x11, 0xaf, 0x20, 0x6d, 0x95, 0x50, 0x7a, 0x0f, 0x43, 0x03, 0xd0, 0x83, 0x15, 0x0f,
	0xd9, 0x8c, 0x08, 0x8a, 0x79, 0x1c, 0xb2, 0xd9, 0xda, 0x38, 0x54, 0x5a, 0x4f, 0xb6, 0x5a, 0x83,
	0x82, 0x31, 0x55, 0x04, 0xf7, 0x28, 0xd8, 0x07, 0xd0, 0x07, 0xd0, 0x0a, 0x58, 0xca, 0x43, 0xb2,
	0xc6, 0x4b, 0x12, 0x51, 0xa3, 0x7e, 0xa6, 0x9d, 0x37, 0xdc, 0x66, 0x8e, 0xd9, 0x24, 0xa2, 0xe8,
	0x0c, 0x9a, 0x01, 0x4d, 0x67, 0x09, 0xe3, 0x82, 0xc5, 0x4b, 0xa3, 0x91, 0x33, 0xb6, 0x10, 0xfa,
	0x06, 0xde, 0x9b, 0x25, 0x54, 0xc6, 0x21, 0x58, 0x44, 0x71, 0x24, 0x0f, 0x4f, 0x71, 0xca, 0x96,
	0x33, 0x8a, 0x29, 0x8f, 0x67, 0x0b, 0x03, 0x54, 0x89, 0x9f, 0x66, 0x2c, 0x9f, 0x45, 0x74, 0xa2,
	0x38, 0x9e, 0xa4, 0x58, 0x92, 0x21, 0x35, 0x56, 0x3c, 0xf8, 0x27, 0x8d, 0x66, 0xa6, 0x91, 0xb1,
	0xfe, 0x4a, 0xa3, 0xfb, 0xab, 0x06, 0x47, 0x03, 0x36, 0x67, 0x82, 0x84, 0xe1, 0x5a, 0xa6, 0x91,
	0x06, 0x7f, 0x97, 0x75, 0xed, 0x3f, 0x66, 0xfd, 0x7e, 0x13, 0x94, 0xfe, 0x55, 0x13, 0x9c, 0x42,
	0x63, 0xa3, 0xaa, 0x5a, 0xb6, 0xe5, 0x6e, 0x81, 0xee, 0xcf, 0x1a, 0xbc, 0x9b, 0xc5, 0x6d, 0x2d,
	0x45, 0xb2, 0x96, 0x97, 0x4c, 0x05, 0x89, 0x38, 0xfa, 0x18, 0x8e, 0x44, 0xb1, 0xc1, 0x4b, 0xb2,
	0x8c, 0xd3, 0x7c, 0x6a, 0x3a, 0x1b, 0xd8, 0x96, 0x28, 0x3a, 0x86, 0x5a, 0x18, 0xcf, 0xe5, 0x54,
	0x95, 0x94, 0xbd, 0x1a, 0xc6, 0xf3, 0x51, 0x80, 0xae, 0xee, 0x1e, 0xdb, 0xdc, 0xeb, 0x92, 0xfd,
	0x9c, 0xed, 0x46, 0xf4, 0xbb, 0x06, 0xed, 0x0c, 0x1d, 0xc7, 0x73, 0x37, 0x8e, 0xc5, 0xc3, 0x43,
	0x79, 0x06, 0x8d, 0x24, 0x8e, 0x05, 0x96, 0x09, 0x50, 0xd1, 0xb4, 0xdc, 0xba, 0x04, 0x64, 0x7e,
	0xa4, 0x51, 0x8d, 0x6e, 0xca, 0xde, 0x64, 0x01, 0x95, 0xb3, 0x31, 0xf5, 0xd8, 0x1b, 0xba, 0x1f,
	0x6d, 0xe5, 0xe1, 0xd1, 0xee, 0xdc, 0xbe, 0xba, 0x7b, 0xfb, 0x0f, 0xa1, 0xad, 0x0e, 0x4b, 0xe8,
	0x4f, 0x2c, 0x95, 0x3d, 0x5c, 0x53, 0xd6, 0x96, 0x04, 0xdd, 0x1c, 0xeb, 0xfe, 0xa2, 0x41, 0x67,
	0x42, 0x38, 0xa7, 0xc9, 0x84, 0x0a, 0x12, 0x10, 0x41, 0x50, 0x17, 0xda, 0x69, 0xbc, 0x4a, 0x66,
	0x14, 0xe7, 0xaa, 0x9a, 0xba, 0x45, 0x33, 0x03, 0xc7, 0x4a, 0xfb, 0x2b, 0x78, 0xb6, 0x60, 0xf3,
	0x05, 0x4d, 0x05, 0xfe, 0x71, 0x15, 0x86, 0x6b, 0x3c, 0x8b, 0x23, 0x1e, 0x52, 0x41, 0x03, 0x9c,
	0xd2, 0xd7, 0x79, 0x15, 0x8c, 0x9c, 0x72, 0x2d, 0x19, 0xfd, 0x82, 0xe0, 0xd1, 0xd7, 0xc8, 0x82,
	0xf7, 0x0b, 0x77, 0x4e, 0x12, 0xc1, 0xc8, 0x7d, 0x89, 0x2c, 0x3b, 0xa7, 0x39, 0x6d, 0x5a, 0xb0,
	0x76, 0x65, 0xba, 0x7f, 0x6c, 0xca, 0x34, 0x21, 0xfc, 0x2d, 0x96, 0xe9, 0x33, 0xa8, 0x47, 0x79,
	0x36, 0xf2, 0xb6, 0x31, 0xb6, 0x85, 0xd8, 0xcf, 0x96, 0xbb, 0x61, 0xfe, 0xaf, 0xfa, 0x45, 0x84,
	0xef, 0xd4, 0x2f, 0x22, 0x7c, 0x14, 0xc8, 0x47, 0x4a, 0xc2, 0x77, 0xca, 0xd7, 0x8c, 0x08, 0x2f,
	0xaa, 0xd7, 0xfb, 0x08, 0xda, 0x7b, 0x73, 0x87, 0xea, 0x50, 0xb1, 0x1d, 0xdb, 0xd2, 0x0f, 0x10,
	0x40, 0xcd, 0x1b, 0x9a, 0x17, 0x9f, 0x5f, 0xea, 0x95, 0xde, 0x15, 0xb4, 0x76, 0x5f, 0x78, 0xf4,
	0x04, 0x8e, 0x6f, 0xec, 0x6f, 0x6d, 0xe7, 0x95, 0x8d, 0x87, 0xa6, 0x37, 0xc4, 0x9e, 0xef, 0x9a,
	0xbe, 0xf5, 0xf2, 0x56, 0x3f, 0x40, 0x2d, 0xa8, 0xbb, 0xd7, 0x7d, 0x7c, 0xf9, 0xc5, 0xe5, 0x85,
	0xae, 0xf5, 0xae, 0x00, 0xdd, 0x7f, 0x21, 0x50, 0x1b, 0x1a, 0xa6, 0xed, 0xd8, 0xb7, 0x13, 0xe7,
	0xc6, 0xd3, 0x0f, 0xd0, 0x21, 0x94, 0x5d, 0xcf, 0xd4, 0x35, 0xd4, 0x80, 0xaa, 0xd5, 0x1f, 0x78,
	0xa6, 0x5e, 0xee, 0x61, 0x68, 0x6c, 0xfe, 0x2d, 0x74, 0x02, 0xa8, 0x38, 0xce, 0x77, 0x2d, 0x0b,
	0x7b, 0xbe, 0xe9, 0xe7, 0x21, 0x9a, 0x7d, 0x7f, 0xf4, 0x9d, 0xa5, 0x6b, 0x72, 0x7d, 0xed, 0x3a,
	0xdf, 0x5b, 0xb6, 0x5e, 0x42, 0x3a, 0xb4, 0x3c, 0xe7, 0xda, 0xc7, 0x03, 0x6b, 0x6c, 0xf9, 0xd6,
	0x40, 0x2f, 0x4b, 0x64, 0x68, 0xba, 0x83, 0x0d, 0x52, 0xe9, 0xbd, 0x80, 0x7a, 0xf1, 0xd3, 0xa1,
	0x63, 0x78, 0x67, 0x4f, 0xdf, 0xbf, 0x9d, 0x5a, 0x59, 0x5c, 0x63, 0xe7, 0xa5, 0xae, 0xc9, 0xc5,
	0xc4, 0x9c, 0xea, 0xa5, 0xde, 0x0c, 0x8e, 0xee, 0x7c, 0x0d, 0xe8, 0x14, 0x8c, 0xc2, 0x77, 0x70,
	0x33, 0x1d, 0x8f, 0xfa, 0xa6, 0x6f, 0xe1, 0xa9, 0x33, 0x1e, 0xf5, 0x65, 0x36, 0x9e, 0xc2, 0xc9,
	0x06, 0xf5, 0xb0, 0xed, 0xf8, 0xd8, 0x1c, 0x8f, 0x9d, 0x57, 0xd6, 0x40, 0xd7, 0xe4, 0xad, 0x76,
	0x6c, 0x05, 0x5e, 0xfa, 0xa1, 0xa6, 0x3e, 0xff, 0x17, 0x7f, 0x06, 0x00, 0x00, 0xff, 0xff, 0xdb,
	0xea, 0xe7, 0x09, 0x0e, 0x08, 0x00, 0x00,
}
