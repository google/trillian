// Code generated by protoc-gen-go.
// source: trillian.proto
// DO NOT EDIT!

package trillian

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This defines the way empty / node / leaf hashes are constructed incorporating
// preimage protection, which can be application specific.
type TreeHasherPreimageType int32

const (
	// For Certificate transparency leaf hash prefix = 0x00, node prefix = 0x01, empty hash
	// is digest([]byte{}) as defined in the specification
	TreeHasherPreimageType_RFC_6962_PREIMAGE TreeHasherPreimageType = 0
)

var TreeHasherPreimageType_name = map[int32]string{
	0: "RFC_6962_PREIMAGE",
}
var TreeHasherPreimageType_value = map[string]int32{
	"RFC_6962_PREIMAGE": 0,
}

func (x TreeHasherPreimageType) Enum() *TreeHasherPreimageType {
	p := new(TreeHasherPreimageType)
	*p = x
	return p
}
func (x TreeHasherPreimageType) String() string {
	return proto.EnumName(TreeHasherPreimageType_name, int32(x))
}
func (x *TreeHasherPreimageType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(TreeHasherPreimageType_value, data, "TreeHasherPreimageType")
	if err != nil {
		return err
	}
	*x = TreeHasherPreimageType(value)
	return nil
}
func (TreeHasherPreimageType) EnumDescriptor() ([]byte, []int) { return fileDescriptor1, []int{0} }

type SignatureAlgorithm int32

const (
	SignatureAlgorithm_ECDSA SignatureAlgorithm = 0
	SignatureAlgorithm_RSA   SignatureAlgorithm = 1
)

var SignatureAlgorithm_name = map[int32]string{
	0: "ECDSA",
	1: "RSA",
}
var SignatureAlgorithm_value = map[string]int32{
	"ECDSA": 0,
	"RSA":   1,
}

func (x SignatureAlgorithm) Enum() *SignatureAlgorithm {
	p := new(SignatureAlgorithm)
	*p = x
	return p
}
func (x SignatureAlgorithm) String() string {
	return proto.EnumName(SignatureAlgorithm_name, int32(x))
}
func (x *SignatureAlgorithm) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(SignatureAlgorithm_value, data, "SignatureAlgorithm")
	if err != nil {
		return err
	}
	*x = SignatureAlgorithm(value)
	return nil
}
func (SignatureAlgorithm) EnumDescriptor() ([]byte, []int) { return fileDescriptor1, []int{1} }

type HashAlgorithm int32

const (
	HashAlgorithm_SHA256 HashAlgorithm = 0
)

var HashAlgorithm_name = map[int32]string{
	0: "SHA256",
}
var HashAlgorithm_value = map[string]int32{
	"SHA256": 0,
}

func (x HashAlgorithm) Enum() *HashAlgorithm {
	p := new(HashAlgorithm)
	*p = x
	return p
}
func (x HashAlgorithm) String() string {
	return proto.EnumName(HashAlgorithm_name, int32(x))
}
func (x *HashAlgorithm) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(HashAlgorithm_value, data, "HashAlgorithm")
	if err != nil {
		return err
	}
	*x = HashAlgorithm(value)
	return nil
}
func (HashAlgorithm) EnumDescriptor() ([]byte, []int) { return fileDescriptor1, []int{2} }

type DigitallySigned struct {
	SignatureAlgorithm *SignatureAlgorithm `protobuf:"varint,1,opt,name=signature_algorithm,enum=trillian.SignatureAlgorithm" json:"signature_algorithm,omitempty"`
	HashAlgorithm      *HashAlgorithm      `protobuf:"varint,2,opt,name=hash_algorithm,enum=trillian.HashAlgorithm" json:"hash_algorithm,omitempty"`
	Signature          []byte              `protobuf:"bytes,3,opt,name=signature" json:"signature,omitempty"`
	XXX_unrecognized   []byte              `json:"-"`
}

func (m *DigitallySigned) Reset()                    { *m = DigitallySigned{} }
func (m *DigitallySigned) String() string            { return proto.CompactTextString(m) }
func (*DigitallySigned) ProtoMessage()               {}
func (*DigitallySigned) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{0} }

func (m *DigitallySigned) GetSignatureAlgorithm() SignatureAlgorithm {
	if m != nil && m.SignatureAlgorithm != nil {
		return *m.SignatureAlgorithm
	}
	return SignatureAlgorithm_ECDSA
}

func (m *DigitallySigned) GetHashAlgorithm() HashAlgorithm {
	if m != nil && m.HashAlgorithm != nil {
		return *m.HashAlgorithm
	}
	return HashAlgorithm_SHA256
}

func (m *DigitallySigned) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

type SignedEntryTimestamp struct {
	TimestampNanos   *int64           `protobuf:"varint,1,opt,name=timestamp_nanos" json:"timestamp_nanos,omitempty"`
	LogId            []byte           `protobuf:"bytes,2,opt,name=log_id" json:"log_id,omitempty"`
	Signature        *DigitallySigned `protobuf:"bytes,3,opt,name=signature" json:"signature,omitempty"`
	XXX_unrecognized []byte           `json:"-"`
}

func (m *SignedEntryTimestamp) Reset()                    { *m = SignedEntryTimestamp{} }
func (m *SignedEntryTimestamp) String() string            { return proto.CompactTextString(m) }
func (*SignedEntryTimestamp) ProtoMessage()               {}
func (*SignedEntryTimestamp) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{1} }

func (m *SignedEntryTimestamp) GetTimestampNanos() int64 {
	if m != nil && m.TimestampNanos != nil {
		return *m.TimestampNanos
	}
	return 0
}

func (m *SignedEntryTimestamp) GetLogId() []byte {
	if m != nil {
		return m.LogId
	}
	return nil
}

func (m *SignedEntryTimestamp) GetSignature() *DigitallySigned {
	if m != nil {
		return m.Signature
	}
	return nil
}

// SignedLogRoot represents a commitment by a Log to a particular tree.
type SignedLogRoot struct {
	// epoch nanoseconds, good until 2500ish
	TimestampNanos *int64 `protobuf:"varint,1,opt,name=timestamp_nanos" json:"timestamp_nanos,omitempty"`
	RootHash       []byte `protobuf:"bytes,2,opt,name=root_hash" json:"root_hash,omitempty"`
	// TreeSize is the number of entries in the tree.
	TreeSize *int64 `protobuf:"varint,3,opt,name=tree_size" json:"tree_size,omitempty"`
	// TODO(al): define serialised format for the signature scheme.
	Signature        *DigitallySigned `protobuf:"bytes,4,opt,name=signature" json:"signature,omitempty"`
	LogId            []byte           `protobuf:"bytes,5,opt,name=log_id" json:"log_id,omitempty"`
	TreeRevision     *int64           `protobuf:"varint,6,opt,name=tree_revision" json:"tree_revision,omitempty"`
	XXX_unrecognized []byte           `json:"-"`
}

func (m *SignedLogRoot) Reset()                    { *m = SignedLogRoot{} }
func (m *SignedLogRoot) String() string            { return proto.CompactTextString(m) }
func (*SignedLogRoot) ProtoMessage()               {}
func (*SignedLogRoot) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{2} }

func (m *SignedLogRoot) GetTimestampNanos() int64 {
	if m != nil && m.TimestampNanos != nil {
		return *m.TimestampNanos
	}
	return 0
}

func (m *SignedLogRoot) GetRootHash() []byte {
	if m != nil {
		return m.RootHash
	}
	return nil
}

func (m *SignedLogRoot) GetTreeSize() int64 {
	if m != nil && m.TreeSize != nil {
		return *m.TreeSize
	}
	return 0
}

func (m *SignedLogRoot) GetSignature() *DigitallySigned {
	if m != nil {
		return m.Signature
	}
	return nil
}

func (m *SignedLogRoot) GetLogId() []byte {
	if m != nil {
		return m.LogId
	}
	return nil
}

func (m *SignedLogRoot) GetTreeRevision() int64 {
	if m != nil && m.TreeRevision != nil {
		return *m.TreeRevision
	}
	return 0
}

// SignedMapRoot represents a commitment by a Map to a particular tree.
type SignedMapRoot struct {
	TimestampNanos *int64 `protobuf:"varint,1,opt,name=timestamp_nanos" json:"timestamp_nanos,omitempty"`
	RootHash       []byte `protobuf:"bytes,2,opt,name=root_hash" json:"root_hash,omitempty"`
	// TODO(al) add Metadata e.g. list of Log STHs included under a Map's Signed Root etc.?
	// TODO(al): define serialised format for the signature scheme.
	Signature        *DigitallySigned `protobuf:"bytes,3,opt,name=signature" json:"signature,omitempty"`
	MapId            []byte           `protobuf:"bytes,4,opt,name=map_id" json:"map_id,omitempty"`
	MapRevision      *int64           `protobuf:"varint,5,opt,name=map_revision" json:"map_revision,omitempty"`
	XXX_unrecognized []byte           `json:"-"`
}

func (m *SignedMapRoot) Reset()                    { *m = SignedMapRoot{} }
func (m *SignedMapRoot) String() string            { return proto.CompactTextString(m) }
func (*SignedMapRoot) ProtoMessage()               {}
func (*SignedMapRoot) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{3} }

func (m *SignedMapRoot) GetTimestampNanos() int64 {
	if m != nil && m.TimestampNanos != nil {
		return *m.TimestampNanos
	}
	return 0
}

func (m *SignedMapRoot) GetRootHash() []byte {
	if m != nil {
		return m.RootHash
	}
	return nil
}

func (m *SignedMapRoot) GetSignature() *DigitallySigned {
	if m != nil {
		return m.Signature
	}
	return nil
}

func (m *SignedMapRoot) GetMapId() []byte {
	if m != nil {
		return m.MapId
	}
	return nil
}

func (m *SignedMapRoot) GetMapRevision() int64 {
	if m != nil && m.MapRevision != nil {
		return *m.MapRevision
	}
	return 0
}

func init() {
	proto.RegisterType((*DigitallySigned)(nil), "trillian.DigitallySigned")
	proto.RegisterType((*SignedEntryTimestamp)(nil), "trillian.SignedEntryTimestamp")
	proto.RegisterType((*SignedLogRoot)(nil), "trillian.SignedLogRoot")
	proto.RegisterType((*SignedMapRoot)(nil), "trillian.SignedMapRoot")
	proto.RegisterEnum("trillian.TreeHasherPreimageType", TreeHasherPreimageType_name, TreeHasherPreimageType_value)
	proto.RegisterEnum("trillian.SignatureAlgorithm", SignatureAlgorithm_name, SignatureAlgorithm_value)
	proto.RegisterEnum("trillian.HashAlgorithm", HashAlgorithm_name, HashAlgorithm_value)
}

func init() { proto.RegisterFile("trillian.proto", fileDescriptor1) }

var fileDescriptor1 = []byte{
	// 369 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x94, 0x92, 0x6f, 0x4b, 0xc2, 0x50,
	0x14, 0xc6, 0x5d, 0x53, 0xcb, 0x93, 0x4e, 0xbd, 0x59, 0x1a, 0xf5, 0x22, 0xf6, 0x4a, 0x24, 0x14,
	0x06, 0x09, 0xbe, 0x1c, 0xba, 0x32, 0x48, 0x90, 0xcd, 0xf7, 0xe3, 0x82, 0x97, 0x79, 0x61, 0xdb,
	0x1d, 0x77, 0xb7, 0xc0, 0xbe, 0x44, 0x7d, 0x87, 0xbe, 0x68, 0x77, 0xb3, 0xcd, 0x3f, 0x14, 0xe1,
	0xbb, 0x73, 0xb6, 0xf3, 0x3c, 0xcf, 0xef, 0x6c, 0x07, 0x34, 0xc1, 0xa9, 0xef, 0x53, 0x1c, 0xf6,
	0x23, 0xce, 0x04, 0x43, 0x67, 0x59, 0xaf, 0x7f, 0x2a, 0x50, 0x9f, 0x50, 0x8f, 0x0a, 0xec, 0xfb,
	0x6b, 0x87, 0x7a, 0x21, 0x59, 0xa2, 0x11, 0x5c, 0xc4, 0xb2, 0xc2, 0xe2, 0x95, 0x13, 0x17, 0xfb,
	0x1e, 0xe3, 0x54, 0xac, 0x82, 0x8e, 0x72, 0xa7, 0x74, 0x35, 0xe3, 0xb6, 0x9f, 0x7b, 0x39, 0xd9,
	0x90, 0x99, 0xcd, 0xa0, 0x01, 0x68, 0x2b, 0x1c, 0xaf, 0x76, 0x54, 0x27, 0xa9, 0xaa, 0xbd, 0x55,
	0x4d, 0xe5, 0xfb, 0xad, 0xa0, 0x09, 0x95, 0x3c, 0xab, 0xa3, 0xca, 0xd9, 0xaa, 0x1e, 0x40, 0x6b,
	0x03, 0x62, 0x85, 0x82, 0xaf, 0x17, 0x34, 0x20, 0xb1, 0xc0, 0x41, 0x84, 0xda, 0x50, 0x17, 0x59,
	0xe3, 0x86, 0x38, 0x64, 0x71, 0x8a, 0xa4, 0x22, 0x0d, 0xca, 0x3e, 0xf3, 0x5c, 0xba, 0x4c, 0xc3,
	0xaa, 0xe8, 0xfe, 0xd0, 0xf3, 0xdc, 0xb8, 0xde, 0xe6, 0x1f, 0x6c, 0xab, 0x7f, 0x29, 0x50, 0xdb,
	0x94, 0x2f, 0xcc, 0xb3, 0x19, 0x13, 0x7f, 0x07, 0x49, 0x58, 0x2e, 0x07, 0xdc, 0x64, 0xc5, 0x9f,
	0x2c, 0xf9, 0x48, 0x70, 0x42, 0xdc, 0x98, 0xbe, 0x6f, 0xb2, 0xd4, 0xfd, 0xf8, 0xe2, 0x3f, 0xf1,
	0x3b, 0xf0, 0xa5, 0xd4, 0xf0, 0x12, 0x6a, 0xa9, 0x21, 0x27, 0x6f, 0x34, 0xa6, 0x2c, 0xec, 0x94,
	0x13, 0x53, 0xfd, 0x23, 0xa7, 0x9c, 0xe1, 0xe8, 0x68, 0xca, 0xa3, 0xbe, 0x48, 0x82, 0x14, 0xe0,
	0x28, 0x41, 0x2a, 0xa6, 0xea, 0x16, 0x54, 0x93, 0x3e, 0x27, 0x4a, 0x40, 0xd5, 0xde, 0x00, 0xae,
	0x16, 0x12, 0x34, 0xf9, 0x9d, 0x84, 0xcf, 0x39, 0xa1, 0x01, 0xf6, 0xc8, 0x62, 0x1d, 0x11, 0xb9,
	0x42, 0xd3, 0x7e, 0x1c, 0xbb, 0xc3, 0xd1, 0xd0, 0x70, 0xe7, 0xb6, 0xf5, 0x3c, 0x33, 0x9f, 0xac,
	0x46, 0xa1, 0xd7, 0x05, 0xf4, 0xcb, 0xc5, 0x54, 0xa0, 0x64, 0x8d, 0x27, 0x8e, 0xd9, 0x28, 0xa0,
	0x53, 0x50, 0x6d, 0x59, 0x28, 0xbd, 0x1b, 0xa8, 0xed, 0x5f, 0x09, 0x40, 0xd9, 0x99, 0x9a, 0xc6,
	0xc3, 0xb0, 0x51, 0xf8, 0x0e, 0x00, 0x00, 0xff, 0xff, 0x2f, 0x99, 0x18, 0x73, 0xcc, 0x02, 0x00,
	0x00,
}
