// Code generated by protoc-gen-go.
// source: trillian.proto
// DO NOT EDIT!

package trillian

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This defines the way empty / node / leaf hashes are constructed incorporating
// preimage protection, which can be application specific.
type TreeHasherPreimageType int32

const (
	// For Certificate transparency leaf hash prefix = 0x00, node prefix = 0x01, empty hash
	// is digest([]byte{}) as defined in the specification
	TreeHasherPreimageType_RFC_6962_PREIMAGE TreeHasherPreimageType = 0
)

var TreeHasherPreimageType_name = map[int32]string{
	0: "RFC_6962_PREIMAGE",
}
var TreeHasherPreimageType_value = map[string]int32{
	"RFC_6962_PREIMAGE": 0,
}

func (x TreeHasherPreimageType) String() string {
	return proto.EnumName(TreeHasherPreimageType_name, int32(x))
}
func (TreeHasherPreimageType) EnumDescriptor() ([]byte, []int) { return fileDescriptor1, []int{0} }

type SignatureAlgorithm int32

const (
	SignatureAlgorithm_ECDSA SignatureAlgorithm = 0
	SignatureAlgorithm_RSA   SignatureAlgorithm = 1
)

var SignatureAlgorithm_name = map[int32]string{
	0: "ECDSA",
	1: "RSA",
}
var SignatureAlgorithm_value = map[string]int32{
	"ECDSA": 0,
	"RSA":   1,
}

func (x SignatureAlgorithm) String() string {
	return proto.EnumName(SignatureAlgorithm_name, int32(x))
}
func (SignatureAlgorithm) EnumDescriptor() ([]byte, []int) { return fileDescriptor1, []int{1} }

type HashAlgorithm int32

const (
	HashAlgorithm_SHA256 HashAlgorithm = 0
)

var HashAlgorithm_name = map[int32]string{
	0: "SHA256",
}
var HashAlgorithm_value = map[string]int32{
	"SHA256": 0,
}

func (x HashAlgorithm) String() string {
	return proto.EnumName(HashAlgorithm_name, int32(x))
}
func (HashAlgorithm) EnumDescriptor() ([]byte, []int) { return fileDescriptor1, []int{2} }

type DigitallySigned struct {
	SignatureAlgorithm SignatureAlgorithm `protobuf:"varint,1,opt,name=signature_algorithm,json=signatureAlgorithm,enum=trillian.SignatureAlgorithm" json:"signature_algorithm,omitempty"`
	HashAlgorithm      HashAlgorithm      `protobuf:"varint,2,opt,name=hash_algorithm,json=hashAlgorithm,enum=trillian.HashAlgorithm" json:"hash_algorithm,omitempty"`
	Signature          []byte             `protobuf:"bytes,3,opt,name=signature,proto3" json:"signature,omitempty"`
}

func (m *DigitallySigned) Reset()                    { *m = DigitallySigned{} }
func (m *DigitallySigned) String() string            { return proto.CompactTextString(m) }
func (*DigitallySigned) ProtoMessage()               {}
func (*DigitallySigned) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{0} }

type SignedEntryTimestamp struct {
	TimestampNanos int64            `protobuf:"varint,1,opt,name=timestamp_nanos,json=timestampNanos" json:"timestamp_nanos,omitempty"`
	LogId          []byte           `protobuf:"bytes,2,opt,name=log_id,json=logId,proto3" json:"log_id,omitempty"`
	Signature      *DigitallySigned `protobuf:"bytes,3,opt,name=signature" json:"signature,omitempty"`
}

func (m *SignedEntryTimestamp) Reset()                    { *m = SignedEntryTimestamp{} }
func (m *SignedEntryTimestamp) String() string            { return proto.CompactTextString(m) }
func (*SignedEntryTimestamp) ProtoMessage()               {}
func (*SignedEntryTimestamp) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{1} }

func (m *SignedEntryTimestamp) GetSignature() *DigitallySigned {
	if m != nil {
		return m.Signature
	}
	return nil
}

// SignedLogRoot represents a commitment by a Log to a particular tree.
type SignedLogRoot struct {
	// epoch nanoseconds, good until 2500ish
	TimestampNanos int64  `protobuf:"varint,1,opt,name=timestamp_nanos,json=timestampNanos" json:"timestamp_nanos,omitempty"`
	RootHash       []byte `protobuf:"bytes,2,opt,name=root_hash,json=rootHash,proto3" json:"root_hash,omitempty"`
	// TreeSize is the number of entries in the tree.
	TreeSize int64 `protobuf:"varint,3,opt,name=tree_size,json=treeSize" json:"tree_size,omitempty"`
	// TODO(al): define serialised format for the signature scheme.
	Signature    *DigitallySigned `protobuf:"bytes,4,opt,name=signature" json:"signature,omitempty"`
	LogId        []byte           `protobuf:"bytes,5,opt,name=log_id,json=logId,proto3" json:"log_id,omitempty"`
	TreeRevision int64            `protobuf:"varint,6,opt,name=tree_revision,json=treeRevision" json:"tree_revision,omitempty"`
}

func (m *SignedLogRoot) Reset()                    { *m = SignedLogRoot{} }
func (m *SignedLogRoot) String() string            { return proto.CompactTextString(m) }
func (*SignedLogRoot) ProtoMessage()               {}
func (*SignedLogRoot) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{2} }

func (m *SignedLogRoot) GetSignature() *DigitallySigned {
	if m != nil {
		return m.Signature
	}
	return nil
}

// SignedMapRoot represents a commitment by a Map to a particular tree.
type SignedMapRoot struct {
	TimestampNanos int64  `protobuf:"varint,1,opt,name=timestamp_nanos,json=timestampNanos" json:"timestamp_nanos,omitempty"`
	RootHash       []byte `protobuf:"bytes,2,opt,name=root_hash,json=rootHash,proto3" json:"root_hash,omitempty"`
	// TODO(al) add Metadata e.g. list of Log STHs included under a Map's Signed Root etc.?
	// TODO(al): define serialised format for the signature scheme.
	Signature   *DigitallySigned `protobuf:"bytes,3,opt,name=signature" json:"signature,omitempty"`
	MapId       []byte           `protobuf:"bytes,4,opt,name=map_id,json=mapId,proto3" json:"map_id,omitempty"`
	MapRevision int64            `protobuf:"varint,5,opt,name=map_revision,json=mapRevision" json:"map_revision,omitempty"`
}

func (m *SignedMapRoot) Reset()                    { *m = SignedMapRoot{} }
func (m *SignedMapRoot) String() string            { return proto.CompactTextString(m) }
func (*SignedMapRoot) ProtoMessage()               {}
func (*SignedMapRoot) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{3} }

func (m *SignedMapRoot) GetSignature() *DigitallySigned {
	if m != nil {
		return m.Signature
	}
	return nil
}

func init() {
	proto.RegisterType((*DigitallySigned)(nil), "trillian.DigitallySigned")
	proto.RegisterType((*SignedEntryTimestamp)(nil), "trillian.SignedEntryTimestamp")
	proto.RegisterType((*SignedLogRoot)(nil), "trillian.SignedLogRoot")
	proto.RegisterType((*SignedMapRoot)(nil), "trillian.SignedMapRoot")
	proto.RegisterEnum("trillian.TreeHasherPreimageType", TreeHasherPreimageType_name, TreeHasherPreimageType_value)
	proto.RegisterEnum("trillian.SignatureAlgorithm", SignatureAlgorithm_name, SignatureAlgorithm_value)
	proto.RegisterEnum("trillian.HashAlgorithm", HashAlgorithm_name, HashAlgorithm_value)
}

func init() { proto.RegisterFile("trillian.proto", fileDescriptor1) }

var fileDescriptor1 = []byte{
	// 434 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xac, 0x93, 0x4f, 0x6f, 0xd3, 0x30,
	0x18, 0xc6, 0x1b, 0xb2, 0x84, 0xf6, 0x5d, 0x92, 0x15, 0xf3, 0xaf, 0x68, 0x3b, 0x40, 0x39, 0x30,
	0xf5, 0x30, 0xa4, 0x20, 0x8a, 0xb8, 0x20, 0x45, 0x5b, 0x60, 0x93, 0x28, 0x9a, 0x9c, 0xde, 0x23,
	0xa3, 0x5a, 0x89, 0xa5, 0x24, 0x8e, 0x1c, 0x83, 0x54, 0xbe, 0x04, 0xdf, 0x88, 0x33, 0xdf, 0x84,
	0xaf, 0x81, 0x9d, 0x2c, 0x7f, 0xb6, 0x5e, 0x2a, 0xc4, 0xcd, 0xef, 0x63, 0xfb, 0x79, 0x9f, 0xdf,
	0x2b, 0x1b, 0x3c, 0x29, 0x58, 0x96, 0x31, 0x52, 0x9c, 0x95, 0x82, 0x4b, 0x8e, 0xc6, 0x6d, 0x3d,
	0xff, 0x65, 0xc0, 0xd1, 0x05, 0x4b, 0x98, 0x24, 0x59, 0xb6, 0x8d, 0x58, 0x52, 0xd0, 0x0d, 0x5a,
	0xc1, 0xc3, 0x4a, 0xad, 0x88, 0xfc, 0x26, 0x68, 0x4c, 0xb2, 0x84, 0x0b, 0x26, 0xd3, 0x7c, 0x66,
	0x3c, 0x37, 0x4e, 0x3d, 0xff, 0xe4, 0xac, 0xf3, 0x8a, 0xda, 0x43, 0x41, 0x7b, 0x06, 0xa3, 0x6a,
	0x47, 0x43, 0x1f, 0xc0, 0x4b, 0x49, 0x95, 0x0e, 0x9c, 0xee, 0xd5, 0x4e, 0x4f, 0x7b, 0xa7, 0x4b,
	0xb5, 0xdf, 0x9b, 0xb8, 0xe9, 0xb0, 0x44, 0x27, 0x30, 0xe9, 0x5c, 0x67, 0xa6, 0xba, 0xea, 0xe0,
	0x5e, 0x98, 0xff, 0x34, 0xe0, 0x51, 0x93, 0x3b, 0x2c, 0xa4, 0xd8, 0xae, 0x59, 0x4e, 0x2b, 0x49,
	0xf2, 0x12, 0xbd, 0x82, 0x23, 0xd9, 0x16, 0x71, 0x41, 0x0a, 0x5e, 0xd5, 0x04, 0x26, 0xf6, 0x3a,
	0xf9, 0x8b, 0x56, 0xd1, 0x63, 0xb0, 0x33, 0x9e, 0xc4, 0x6c, 0x53, 0xe7, 0x72, 0xb0, 0xa5, 0xaa,
	0xab, 0x0d, 0x7a, 0x77, 0xb7, 0xed, 0xa1, 0xff, 0xac, 0x4f, 0x7c, 0x67, 0x66, 0xc3, 0x44, 0x7f,
	0x0c, 0x70, 0x1b, 0xf5, 0x33, 0x4f, 0x30, 0xe7, 0x72, 0xff, 0x28, 0xc7, 0x30, 0x11, 0xea, 0x42,
	0xac, 0x07, 0x70, 0x93, 0x66, 0xac, 0x05, 0x3d, 0x1f, 0xbd, 0x29, 0x05, 0xa5, 0x71, 0xc5, 0x7e,
	0x34, 0x81, 0x4c, 0x3c, 0xd6, 0x42, 0xa4, 0xea, 0xdb, 0x69, 0x0f, 0xf6, 0x4f, 0x3b, 0xa0, 0xb7,
	0x86, 0xf4, 0x2f, 0xc1, 0xad, 0x9b, 0x09, 0xfa, 0x9d, 0x55, 0x8c, 0x17, 0x33, 0xbb, 0x6e, 0xe8,
	0x68, 0x11, 0xdf, 0x68, 0xf3, 0xdf, 0x1d, 0xe9, 0x8a, 0x94, 0xff, 0x91, 0xf4, 0x5f, 0x47, 0xaf,
	0x61, 0x72, 0x52, 0x6a, 0x98, 0x83, 0x06, 0x46, 0x55, 0x0a, 0xe6, 0x05, 0x38, 0x5a, 0xee, 0x58,
	0xac, 0x3a, 0xd2, 0xa1, 0xd2, 0x5a, 0x94, 0xc5, 0x6b, 0x78, 0xb2, 0x56, 0x68, 0xba, 0x3d, 0x15,
	0xd7, 0x82, 0xb2, 0x9c, 0x24, 0x74, 0xbd, 0x2d, 0xb5, 0xe7, 0x03, 0xfc, 0xf1, 0x3c, 0x5e, 0xbe,
	0x5f, 0xfa, 0xf1, 0x35, 0x0e, 0xaf, 0x56, 0xc1, 0xa7, 0x70, 0x3a, 0x5a, 0x9c, 0x02, 0xda, 0x7d,
	0xff, 0x68, 0x02, 0x56, 0x78, 0x7e, 0x11, 0x05, 0xd3, 0x11, 0xba, 0x0f, 0x26, 0x56, 0x0b, 0x63,
	0x71, 0x0c, 0xee, 0xad, 0xf7, 0x8d, 0x00, 0xec, 0xe8, 0x32, 0xf0, 0xdf, 0x2e, 0xa7, 0xa3, 0xaf,
	0x76, 0xfd, 0x21, 0xdf, 0xfc, 0x0d, 0x00, 0x00, 0xff, 0xff, 0x77, 0x0d, 0x02, 0xa4, 0xa2, 0x03,
	0x00, 0x00,
}
