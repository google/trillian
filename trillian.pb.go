// Code generated by protoc-gen-go. DO NOT EDIT.
// source: trillian.proto

package trillian

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import keyspb "github.com/google/trillian/crypto/keyspb"
import sigpb "github.com/google/trillian/crypto/sigpb"
import google_protobuf2 "github.com/golang/protobuf/ptypes/any"
import google_protobuf3 "github.com/golang/protobuf/ptypes/duration"
import google_protobuf1 "github.com/golang/protobuf/ptypes/timestamp"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// LogSignatureFormat specifies the fields that are covered by the
// SignedLogRoot signature, as well as their ordering and formats.
type LogSignatureFormat int32

const (
	LogSignatureFormat_LOG_SIG_FORMAT_UNKNOWN LogSignatureFormat = 0
	LogSignatureFormat_LOG_SIG_FORMAT_V1      LogSignatureFormat = 1
)

var LogSignatureFormat_name = map[int32]string{
	0: "LOG_SIG_FORMAT_UNKNOWN",
	1: "LOG_SIG_FORMAT_V1",
}
var LogSignatureFormat_value = map[string]int32{
	"LOG_SIG_FORMAT_UNKNOWN": 0,
	"LOG_SIG_FORMAT_V1":      1,
}

func (x LogSignatureFormat) String() string {
	return proto.EnumName(LogSignatureFormat_name, int32(x))
}
func (LogSignatureFormat) EnumDescriptor() ([]byte, []int) { return fileDescriptor3, []int{0} }

// MapSignatureFormat specifies the fields that are covered by the
// SignedMapRoot signature, as well as their ordering and formats.
type MapSignatureFormat int32

const (
	MapSignatureFormat_MAP_SIG_FORMAT_UNKNOWN MapSignatureFormat = 0
	MapSignatureFormat_MAP_SIG_FORMAT_V1      MapSignatureFormat = 1
)

var MapSignatureFormat_name = map[int32]string{
	0: "MAP_SIG_FORMAT_UNKNOWN",
	1: "MAP_SIG_FORMAT_V1",
}
var MapSignatureFormat_value = map[string]int32{
	"MAP_SIG_FORMAT_UNKNOWN": 0,
	"MAP_SIG_FORMAT_V1":      1,
}

func (x MapSignatureFormat) String() string {
	return proto.EnumName(MapSignatureFormat_name, int32(x))
}
func (MapSignatureFormat) EnumDescriptor() ([]byte, []int) { return fileDescriptor3, []int{1} }

// Defines the way empty / node / leaf hashes are constructed incorporating
// preimage protection, which can be application specific.
type HashStrategy int32

const (
	// Hash strategy cannot be determined. Included to enable detection of
	// mismatched proto versions being used. Represents an invalid value.
	HashStrategy_UNKNOWN_HASH_STRATEGY HashStrategy = 0
	// Certificate Transparency strategy: leaf hash prefix = 0x00, node prefix =
	// 0x01, empty hash is digest([]byte{}), as defined in the specification.
	HashStrategy_RFC6962_SHA256 HashStrategy = 1
	// Sparse Merkle Tree strategy:  leaf hash prefix = 0x00, node prefix = 0x01,
	// empty branch is recursively computed from empty leaf nodes.
	// NOT secure in a multi tree environment. For testing only.
	HashStrategy_TEST_MAP_HASHER HashStrategy = 2
	// Append-only log strategy where leaf nodes are defined as the ObjectHash.
	// All other properties are equal to RFC6962_SHA256.
	HashStrategy_OBJECT_RFC6962_SHA256 HashStrategy = 3
	// The CONIKS sparse tree hasher with SHA512_256 as the hash algorithm.
	HashStrategy_CONIKS_SHA512_256 HashStrategy = 4
)

var HashStrategy_name = map[int32]string{
	0: "UNKNOWN_HASH_STRATEGY",
	1: "RFC6962_SHA256",
	2: "TEST_MAP_HASHER",
	3: "OBJECT_RFC6962_SHA256",
	4: "CONIKS_SHA512_256",
}
var HashStrategy_value = map[string]int32{
	"UNKNOWN_HASH_STRATEGY": 0,
	"RFC6962_SHA256":        1,
	"TEST_MAP_HASHER":       2,
	"OBJECT_RFC6962_SHA256": 3,
	"CONIKS_SHA512_256":     4,
}

func (x HashStrategy) String() string {
	return proto.EnumName(HashStrategy_name, int32(x))
}
func (HashStrategy) EnumDescriptor() ([]byte, []int) { return fileDescriptor3, []int{2} }

// State of the tree.
type TreeState int32

const (
	// Tree state cannot be determined. Included to enable detection of
	// mismatched proto versions being used. Represents an invalid value.
	TreeState_UNKNOWN_TREE_STATE TreeState = 0
	// Active trees are able to respond to both read and write requests.
	TreeState_ACTIVE TreeState = 1
	// Frozen trees are only able to respond to read requests, writing to a frozen
	// tree is forbidden.
	TreeState_FROZEN TreeState = 2
	// Deprecated in favor of Tree.deleted.
	TreeState_DEPRECATED_SOFT_DELETED TreeState = 3
	// Deprecated in favor of Tree.deleted.
	TreeState_DEPRECATED_HARD_DELETED TreeState = 4
)

var TreeState_name = map[int32]string{
	0: "UNKNOWN_TREE_STATE",
	1: "ACTIVE",
	2: "FROZEN",
	3: "DEPRECATED_SOFT_DELETED",
	4: "DEPRECATED_HARD_DELETED",
}
var TreeState_value = map[string]int32{
	"UNKNOWN_TREE_STATE":      0,
	"ACTIVE":                  1,
	"FROZEN":                  2,
	"DEPRECATED_SOFT_DELETED": 3,
	"DEPRECATED_HARD_DELETED": 4,
}

func (x TreeState) String() string {
	return proto.EnumName(TreeState_name, int32(x))
}
func (TreeState) EnumDescriptor() ([]byte, []int) { return fileDescriptor3, []int{3} }

// Type of the tree.
type TreeType int32

const (
	// Tree type cannot be determined. Included to enable detection of mismatched
	// proto versions being used. Represents an invalid value.
	TreeType_UNKNOWN_TREE_TYPE TreeType = 0
	// Tree represents a verifiable log.
	TreeType_LOG TreeType = 1
	// Tree represents a verifiable map.
	TreeType_MAP TreeType = 2
	// Tree represents a verifiable pre-ordered log, i.e., a log whose entries are
	// placed according to sequence numbers assigned outside of Trillian.
	// TODO(pavelkalinnikov): Support this type.
	TreeType_PREORDERED_LOG TreeType = 3
)

var TreeType_name = map[int32]string{
	0: "UNKNOWN_TREE_TYPE",
	1: "LOG",
	2: "MAP",
	3: "PREORDERED_LOG",
}
var TreeType_value = map[string]int32{
	"UNKNOWN_TREE_TYPE": 0,
	"LOG":               1,
	"MAP":               2,
	"PREORDERED_LOG":    3,
}

func (x TreeType) String() string {
	return proto.EnumName(TreeType_name, int32(x))
}
func (TreeType) EnumDescriptor() ([]byte, []int) { return fileDescriptor3, []int{4} }

// Represents a tree, which may be either a verifiable log or map.
// Readonly attributes are assigned at tree creation, after which they may not
// be modified.
type Tree struct {
	// ID of the tree.
	// Readonly.
	TreeId int64 `protobuf:"varint,1,opt,name=tree_id,json=treeId" json:"tree_id,omitempty"`
	// State of the tree.
	// Trees are active after creation. At any point the tree may transition
	// between ACTIVE and FROZEN.
	TreeState TreeState `protobuf:"varint,2,opt,name=tree_state,json=treeState,enum=trillian.TreeState" json:"tree_state,omitempty"`
	// Type of the tree.
	// Readonly.
	TreeType TreeType `protobuf:"varint,3,opt,name=tree_type,json=treeType,enum=trillian.TreeType" json:"tree_type,omitempty"`
	// Hash strategy to be used by the tree.
	// Readonly.
	HashStrategy HashStrategy `protobuf:"varint,4,opt,name=hash_strategy,json=hashStrategy,enum=trillian.HashStrategy" json:"hash_strategy,omitempty"`
	// Hash algorithm to be used by the tree.
	// Readonly.
	// TODO(gdbelvin): Deprecate in favor of signature_cipher_suite and hash_strategy.
	HashAlgorithm sigpb.DigitallySigned_HashAlgorithm `protobuf:"varint,5,opt,name=hash_algorithm,json=hashAlgorithm,enum=sigpb.DigitallySigned_HashAlgorithm" json:"hash_algorithm,omitempty"`
	// Signature algorithm to be used by the tree.
	// Readonly.
	// TODO(gdbelvin): Deprecate in favor of signature_cipher_suite.
	SignatureAlgorithm sigpb.DigitallySigned_SignatureAlgorithm `protobuf:"varint,6,opt,name=signature_algorithm,json=signatureAlgorithm,enum=sigpb.DigitallySigned_SignatureAlgorithm" json:"signature_algorithm,omitempty"`
	// Signature cipher suite specifies the algorithms used to generate signatures.
	SignatureCipherSuite sigpb.DigitallySigned_SignatureCipherSuite `protobuf:"varint,18,opt,name=signature_cipher_suite,json=signatureCipherSuite,enum=sigpb.DigitallySigned_SignatureCipherSuite" json:"signature_cipher_suite,omitempty"`
	// Display name of the tree.
	// Optional.
	DisplayName string `protobuf:"bytes,8,opt,name=display_name,json=displayName" json:"display_name,omitempty"`
	// Description of the tree,
	// Optional.
	Description string `protobuf:"bytes,9,opt,name=description" json:"description,omitempty"`
	// Identifies the private key used for signing tree heads and entry
	// timestamps.
	// This can be any type of message to accommodate different key management
	// systems, e.g. PEM files, HSMs, etc.
	// Private keys are write-only: they're never returned by RPCs.
	// The private_key message can be changed after a tree is created, but the
	// underlying key must remain the same - this is to enable migrating a key
	// from one provider to another.
	PrivateKey *google_protobuf2.Any `protobuf:"bytes,12,opt,name=private_key,json=privateKey" json:"private_key,omitempty"`
	// Storage-specific settings.
	// Varies according to the storage implementation backing Trillian.
	StorageSettings *google_protobuf2.Any `protobuf:"bytes,13,opt,name=storage_settings,json=storageSettings" json:"storage_settings,omitempty"`
	// The public key used for verifying tree heads and entry timestamps.
	// Readonly.
	PublicKey *keyspb.PublicKey `protobuf:"bytes,14,opt,name=public_key,json=publicKey" json:"public_key,omitempty"`
	// Interval after which a new signed root is produced even if there have been
	// no submission.  If zero, this behavior is disabled.
	MaxRootDuration *google_protobuf3.Duration `protobuf:"bytes,15,opt,name=max_root_duration,json=maxRootDuration" json:"max_root_duration,omitempty"`
	// Time of tree creation.
	// Readonly.
	CreateTime *google_protobuf1.Timestamp `protobuf:"bytes,16,opt,name=create_time,json=createTime" json:"create_time,omitempty"`
	// Time of last tree update.
	// Readonly (automatically assigned on updates).
	UpdateTime *google_protobuf1.Timestamp `protobuf:"bytes,17,opt,name=update_time,json=updateTime" json:"update_time,omitempty"`
	// If true, the tree has been deleted.
	// Deleted trees may be undeleted during a certain time window, after which
	// they're permanently deleted (and unrecoverable).
	// Readonly.
	Deleted bool `protobuf:"varint,19,opt,name=deleted" json:"deleted,omitempty"`
	// Time of tree deletion, if any.
	// Readonly.
	DeleteTime *google_protobuf1.Timestamp `protobuf:"bytes,20,opt,name=delete_time,json=deleteTime" json:"delete_time,omitempty"`
}

func (m *Tree) Reset()                    { *m = Tree{} }
func (m *Tree) String() string            { return proto.CompactTextString(m) }
func (*Tree) ProtoMessage()               {}
func (*Tree) Descriptor() ([]byte, []int) { return fileDescriptor3, []int{0} }

func (m *Tree) GetTreeId() int64 {
	if m != nil {
		return m.TreeId
	}
	return 0
}

func (m *Tree) GetTreeState() TreeState {
	if m != nil {
		return m.TreeState
	}
	return TreeState_UNKNOWN_TREE_STATE
}

func (m *Tree) GetTreeType() TreeType {
	if m != nil {
		return m.TreeType
	}
	return TreeType_UNKNOWN_TREE_TYPE
}

func (m *Tree) GetHashStrategy() HashStrategy {
	if m != nil {
		return m.HashStrategy
	}
	return HashStrategy_UNKNOWN_HASH_STRATEGY
}

func (m *Tree) GetHashAlgorithm() sigpb.DigitallySigned_HashAlgorithm {
	if m != nil {
		return m.HashAlgorithm
	}
	return sigpb.DigitallySigned_NONE
}

func (m *Tree) GetSignatureAlgorithm() sigpb.DigitallySigned_SignatureAlgorithm {
	if m != nil {
		return m.SignatureAlgorithm
	}
	return sigpb.DigitallySigned_ANONYMOUS
}

func (m *Tree) GetSignatureCipherSuite() sigpb.DigitallySigned_SignatureCipherSuite {
	if m != nil {
		return m.SignatureCipherSuite
	}
	return sigpb.DigitallySigned_UNKNOWN_CIPHER_SUITE
}

func (m *Tree) GetDisplayName() string {
	if m != nil {
		return m.DisplayName
	}
	return ""
}

func (m *Tree) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *Tree) GetPrivateKey() *google_protobuf2.Any {
	if m != nil {
		return m.PrivateKey
	}
	return nil
}

func (m *Tree) GetStorageSettings() *google_protobuf2.Any {
	if m != nil {
		return m.StorageSettings
	}
	return nil
}

func (m *Tree) GetPublicKey() *keyspb.PublicKey {
	if m != nil {
		return m.PublicKey
	}
	return nil
}

func (m *Tree) GetMaxRootDuration() *google_protobuf3.Duration {
	if m != nil {
		return m.MaxRootDuration
	}
	return nil
}

func (m *Tree) GetCreateTime() *google_protobuf1.Timestamp {
	if m != nil {
		return m.CreateTime
	}
	return nil
}

func (m *Tree) GetUpdateTime() *google_protobuf1.Timestamp {
	if m != nil {
		return m.UpdateTime
	}
	return nil
}

func (m *Tree) GetDeleted() bool {
	if m != nil {
		return m.Deleted
	}
	return false
}

func (m *Tree) GetDeleteTime() *google_protobuf1.Timestamp {
	if m != nil {
		return m.DeleteTime
	}
	return nil
}

type SignedEntryTimestamp struct {
	TimestampNanos int64                  `protobuf:"varint,1,opt,name=timestamp_nanos,json=timestampNanos" json:"timestamp_nanos,omitempty"`
	LogId          int64                  `protobuf:"varint,2,opt,name=log_id,json=logId" json:"log_id,omitempty"`
	Signature      *sigpb.DigitallySigned `protobuf:"bytes,3,opt,name=signature" json:"signature,omitempty"`
}

func (m *SignedEntryTimestamp) Reset()                    { *m = SignedEntryTimestamp{} }
func (m *SignedEntryTimestamp) String() string            { return proto.CompactTextString(m) }
func (*SignedEntryTimestamp) ProtoMessage()               {}
func (*SignedEntryTimestamp) Descriptor() ([]byte, []int) { return fileDescriptor3, []int{1} }

func (m *SignedEntryTimestamp) GetTimestampNanos() int64 {
	if m != nil {
		return m.TimestampNanos
	}
	return 0
}

func (m *SignedEntryTimestamp) GetLogId() int64 {
	if m != nil {
		return m.LogId
	}
	return 0
}

func (m *SignedEntryTimestamp) GetSignature() *sigpb.DigitallySigned {
	if m != nil {
		return m.Signature
	}
	return nil
}

// SignedLogRoot represents a commitment by a Log to a particular tree.
type SignedLogRoot struct {
	// epoch nanoseconds, good until 2500ish
	TimestampNanos int64  `protobuf:"varint,1,opt,name=timestamp_nanos,json=timestampNanos" json:"timestamp_nanos,omitempty"`
	RootHash       []byte `protobuf:"bytes,2,opt,name=root_hash,json=rootHash,proto3" json:"root_hash,omitempty"`
	// TreeSize is the number of entries in the tree.
	TreeSize     int64                  `protobuf:"varint,3,opt,name=tree_size,json=treeSize" json:"tree_size,omitempty"`
	Signature    *sigpb.DigitallySigned `protobuf:"bytes,4,opt,name=signature" json:"signature,omitempty"`
	LogId        int64                  `protobuf:"varint,5,opt,name=log_id,json=logId" json:"log_id,omitempty"`
	TreeRevision int64                  `protobuf:"varint,6,opt,name=tree_revision,json=treeRevision" json:"tree_revision,omitempty"`
}

func (m *SignedLogRoot) Reset()                    { *m = SignedLogRoot{} }
func (m *SignedLogRoot) String() string            { return proto.CompactTextString(m) }
func (*SignedLogRoot) ProtoMessage()               {}
func (*SignedLogRoot) Descriptor() ([]byte, []int) { return fileDescriptor3, []int{2} }

func (m *SignedLogRoot) GetTimestampNanos() int64 {
	if m != nil {
		return m.TimestampNanos
	}
	return 0
}

func (m *SignedLogRoot) GetRootHash() []byte {
	if m != nil {
		return m.RootHash
	}
	return nil
}

func (m *SignedLogRoot) GetTreeSize() int64 {
	if m != nil {
		return m.TreeSize
	}
	return 0
}

func (m *SignedLogRoot) GetSignature() *sigpb.DigitallySigned {
	if m != nil {
		return m.Signature
	}
	return nil
}

func (m *SignedLogRoot) GetLogId() int64 {
	if m != nil {
		return m.LogId
	}
	return 0
}

func (m *SignedLogRoot) GetTreeRevision() int64 {
	if m != nil {
		return m.TreeRevision
	}
	return 0
}

// SignedMapRoot represents a commitment by a Map to a particular tree.
type SignedMapRoot struct {
	TimestampNanos int64  `protobuf:"varint,1,opt,name=timestamp_nanos,json=timestampNanos" json:"timestamp_nanos,omitempty"`
	RootHash       []byte `protobuf:"bytes,2,opt,name=root_hash,json=rootHash,proto3" json:"root_hash,omitempty"`
	// TODO(al): define serialized format for the signature scheme.
	Signature   *sigpb.DigitallySigned `protobuf:"bytes,4,opt,name=signature" json:"signature,omitempty"`
	MapId       int64                  `protobuf:"varint,5,opt,name=map_id,json=mapId" json:"map_id,omitempty"`
	MapRevision int64                  `protobuf:"varint,6,opt,name=map_revision,json=mapRevision" json:"map_revision,omitempty"`
	// Metadata associated with the Map root.  This is set by the map personality
	// layer in a SetLeaves map request.  It could be used to persist state
	// needed to recreate the Map from an external data source.
	Metadata *google_protobuf2.Any `protobuf:"bytes,7,opt,name=metadata" json:"metadata,omitempty"`
}

func (m *SignedMapRoot) Reset()                    { *m = SignedMapRoot{} }
func (m *SignedMapRoot) String() string            { return proto.CompactTextString(m) }
func (*SignedMapRoot) ProtoMessage()               {}
func (*SignedMapRoot) Descriptor() ([]byte, []int) { return fileDescriptor3, []int{3} }

func (m *SignedMapRoot) GetTimestampNanos() int64 {
	if m != nil {
		return m.TimestampNanos
	}
	return 0
}

func (m *SignedMapRoot) GetRootHash() []byte {
	if m != nil {
		return m.RootHash
	}
	return nil
}

func (m *SignedMapRoot) GetSignature() *sigpb.DigitallySigned {
	if m != nil {
		return m.Signature
	}
	return nil
}

func (m *SignedMapRoot) GetMapId() int64 {
	if m != nil {
		return m.MapId
	}
	return 0
}

func (m *SignedMapRoot) GetMapRevision() int64 {
	if m != nil {
		return m.MapRevision
	}
	return 0
}

func (m *SignedMapRoot) GetMetadata() *google_protobuf2.Any {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func init() {
	proto.RegisterType((*Tree)(nil), "trillian.Tree")
	proto.RegisterType((*SignedEntryTimestamp)(nil), "trillian.SignedEntryTimestamp")
	proto.RegisterType((*SignedLogRoot)(nil), "trillian.SignedLogRoot")
	proto.RegisterType((*SignedMapRoot)(nil), "trillian.SignedMapRoot")
	proto.RegisterEnum("trillian.LogSignatureFormat", LogSignatureFormat_name, LogSignatureFormat_value)
	proto.RegisterEnum("trillian.MapSignatureFormat", MapSignatureFormat_name, MapSignatureFormat_value)
	proto.RegisterEnum("trillian.HashStrategy", HashStrategy_name, HashStrategy_value)
	proto.RegisterEnum("trillian.TreeState", TreeState_name, TreeState_value)
	proto.RegisterEnum("trillian.TreeType", TreeType_name, TreeType_value)
}

func init() { proto.RegisterFile("trillian.proto", fileDescriptor3) }

var fileDescriptor3 = []byte{
	// 1075 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x56, 0x5d, 0x6f, 0xe2, 0x46,
	0x14, 0x5d, 0x03, 0x0b, 0x66, 0x20, 0xc4, 0x99, 0x7c, 0xac, 0x43, 0xa5, 0x2e, 0x4d, 0x2b, 0x35,
	0x4d, 0x25, 0xb2, 0x4b, 0x9b, 0x48, 0xd5, 0x3e, 0x54, 0x0e, 0x38, 0x40, 0x3e, 0x00, 0x8d, 0xdd,
	0xad, 0x36, 0x2f, 0xa3, 0x01, 0x4f, 0x8d, 0xb5, 0x36, 0xb6, 0xec, 0x61, 0xb5, 0x5e, 0xa9, 0x6f,
	0x7d, 0xec, 0xcf, 0xac, 0xfa, 0x2f, 0x2a, 0x55, 0x33, 0xfe, 0x08, 0x21, 0xd9, 0xcd, 0xaa, 0xea,
	0x4b, 0x32, 0xf7, 0xdc, 0x73, 0xce, 0xdc, 0x8b, 0xef, 0x8c, 0x0d, 0x1a, 0x2c, 0x74, 0x5c, 0xd7,
	0x21, 0x8b, 0x76, 0x10, 0xfa, 0xcc, 0x87, 0x72, 0x16, 0x37, 0x9b, 0xb3, 0x30, 0x0e, 0x98, 0x7f,
	0xfc, 0x96, 0xc6, 0x51, 0x30, 0x4d, 0xff, 0x25, 0xac, 0xa6, 0x9a, 0xe6, 0x22, 0xc7, 0x0e, 0xa6,
	0xc9, 0xdf, 0x34, 0xb3, 0x6f, 0xfb, 0xbe, 0xed, 0xd2, 0x63, 0x11, 0x4d, 0x97, 0xbf, 0x1d, 0x93,
	0x45, 0x9c, 0xa6, 0xbe, 0x5c, 0x4f, 0x59, 0xcb, 0x90, 0x30, 0xc7, 0x4f, 0xb7, 0x6e, 0x3e, 0x5f,
	0xcf, 0x33, 0xc7, 0xa3, 0x11, 0x23, 0x5e, 0x90, 0x10, 0x0e, 0xfe, 0xae, 0x80, 0x92, 0x19, 0x52,
	0x0a, 0x9f, 0x81, 0x0a, 0x0b, 0x29, 0xc5, 0x8e, 0xa5, 0x4a, 0x2d, 0xe9, 0xb0, 0x88, 0xca, 0x3c,
	0x1c, 0x5a, 0xb0, 0x03, 0x80, 0x48, 0x44, 0x8c, 0x30, 0xaa, 0x16, 0x5a, 0xd2, 0x61, 0xa3, 0xb3,
	0xdd, 0xce, 0x5b, 0xe4, 0x62, 0x83, 0xa7, 0x50, 0x95, 0x65, 0x4b, 0x78, 0x0c, 0x44, 0x80, 0x59,
	0x1c, 0x50, 0xb5, 0x28, 0x24, 0xf0, 0xae, 0xc4, 0x8c, 0x03, 0x8a, 0x64, 0x96, 0xae, 0xe0, 0x2b,
	0xb0, 0x31, 0x27, 0xd1, 0x1c, 0x47, 0x2c, 0x24, 0x8c, 0xda, 0xb1, 0x5a, 0x12, 0xa2, 0xbd, 0x5b,
	0xd1, 0x80, 0x44, 0x73, 0x23, 0xcd, 0xa2, 0xfa, 0x7c, 0x25, 0x82, 0x97, 0xa0, 0x21, 0xc4, 0xc4,
	0xb5, 0xfd, 0xd0, 0x61, 0x73, 0x4f, 0x7d, 0x2a, 0xd4, 0xdf, 0xb4, 0x93, 0x5f, 0xb1, 0xe7, 0xd8,
	0x0e, 0x23, 0xae, 0x1b, 0x1b, 0x8e, 0xbd, 0xa0, 0x96, 0xb0, 0xd2, 0x32, 0x2e, 0x12, 0x1b, 0xe7,
	0x21, 0xbc, 0x01, 0xdb, 0x91, 0x63, 0x2f, 0x08, 0x5b, 0x86, 0x74, 0xc5, 0xb1, 0x2c, 0x1c, 0xbf,
	0xfb, 0x88, 0xa3, 0x91, 0x29, 0x6e, 0x6d, 0x61, 0x74, 0x0f, 0x83, 0x04, 0xec, 0xdd, 0x7a, 0xcf,
	0x9c, 0x60, 0x4e, 0x43, 0x1c, 0x2d, 0x1d, 0x46, 0x55, 0x28, 0xec, 0xbf, 0x7f, 0xcc, 0xbe, 0x2b,
	0x34, 0x06, 0x97, 0xa0, 0x9d, 0xe8, 0x01, 0x14, 0x7e, 0x05, 0xea, 0x96, 0x13, 0x05, 0x2e, 0x89,
	0xf1, 0x82, 0x78, 0x54, 0x95, 0x5b, 0xd2, 0x61, 0x15, 0xd5, 0x52, 0x6c, 0x44, 0x3c, 0x0a, 0x5b,
	0xa0, 0x66, 0xd1, 0x68, 0x16, 0x3a, 0x01, 0x1f, 0x14, 0xb5, 0x9a, 0x32, 0x6e, 0x21, 0x78, 0x02,
	0x6a, 0x41, 0xe8, 0xbc, 0x23, 0x8c, 0xe2, 0xb7, 0x34, 0x56, 0xeb, 0x2d, 0xe9, 0xb0, 0xd6, 0xd9,
	0x69, 0x27, 0xb3, 0xd4, 0xce, 0x66, 0xa9, 0xad, 0x2d, 0x62, 0x04, 0x52, 0xe2, 0x25, 0x8d, 0xe1,
	0xcf, 0x40, 0x89, 0x98, 0x1f, 0x12, 0x9b, 0xe2, 0x88, 0x32, 0xe6, 0x2c, 0xec, 0x48, 0xdd, 0xf8,
	0x84, 0x76, 0x33, 0x65, 0x1b, 0x29, 0x19, 0xbe, 0x00, 0x20, 0x58, 0x4e, 0x5d, 0x67, 0x26, 0xb6,
	0x6d, 0x08, 0xe9, 0x56, 0x3b, 0x3d, 0x25, 0x13, 0x91, 0xb9, 0xa4, 0x31, 0xaa, 0x06, 0xd9, 0x12,
	0xea, 0x60, 0xcb, 0x23, 0xef, 0x71, 0xe8, 0xfb, 0x0c, 0x67, 0xa3, 0xaf, 0x6e, 0x0a, 0xe1, 0xfe,
	0xbd, 0x3d, 0x7b, 0x29, 0x01, 0x6d, 0x7a, 0xe4, 0x3d, 0xf2, 0x7d, 0x96, 0x01, 0xf0, 0x15, 0xa8,
	0xcd, 0x42, 0xca, 0xfb, 0xe5, 0xe7, 0x43, 0x55, 0x84, 0x41, 0xf3, 0x9e, 0x81, 0x99, 0x1d, 0x1e,
	0x04, 0x12, 0x3a, 0x07, 0xb8, 0x78, 0x19, 0x58, 0xb9, 0x78, 0xeb, 0x71, 0x71, 0x42, 0x17, 0x62,
	0x15, 0x54, 0x2c, 0xea, 0x52, 0x46, 0x2d, 0x75, 0xbb, 0x25, 0x1d, 0xca, 0x28, 0x0b, 0xb9, 0x6d,
	0xb2, 0x4c, 0x6c, 0x77, 0x1e, 0xb7, 0x4d, 0xe8, 0x1c, 0xb8, 0x28, 0xc9, 0x15, 0x45, 0xbe, 0x28,
	0xc9, 0x40, 0xa9, 0x5d, 0x94, 0xe4, 0x9a, 0x52, 0x3f, 0xf8, 0x53, 0x02, 0x3b, 0xc9, 0x38, 0xe9,
	0x0b, 0x16, 0xc6, 0xb9, 0x0c, 0x7e, 0x0b, 0x36, 0xf3, 0x4b, 0x01, 0x2f, 0xc8, 0xc2, 0x8f, 0xd2,
	0x0b, 0xa0, 0x91, 0xc3, 0x23, 0x8e, 0xc2, 0x5d, 0x50, 0x76, 0x7d, 0x9b, 0x5f, 0x10, 0x05, 0x91,
	0x7f, 0xea, 0xfa, 0xf6, 0xd0, 0x82, 0x3f, 0x82, 0x6a, 0x3e, 0x89, 0xe2, 0xac, 0xd7, 0x3a, 0x7b,
	0x0f, 0xcf, 0x31, 0xba, 0x25, 0x1e, 0xfc, 0x25, 0x81, 0x8d, 0x04, 0xbd, 0xf2, 0x6d, 0xfe, 0x2c,
	0x3e, 0xbf, 0x8e, 0x2f, 0x40, 0x55, 0x3c, 0x6f, 0x7e, 0x6e, 0x45, 0x29, 0x75, 0x24, 0x73, 0x80,
	0x1f, 0x6b, 0x9e, 0x4c, 0x6e, 0x2b, 0xe7, 0x43, 0x52, 0x4d, 0x31, 0xb9, 0x65, 0x0c, 0xe7, 0x03,
	0xbd, 0x5b, 0x6a, 0xe9, 0x33, 0x4b, 0x5d, 0xe9, 0xfb, 0xe9, 0x6a, 0xdf, 0x5f, 0x83, 0x0d, 0xb1,
	0x53, 0x48, 0xdf, 0x39, 0x11, 0x1f, 0xbb, 0xb2, 0xc8, 0xd6, 0x39, 0x88, 0x52, 0xec, 0xe0, 0x9f,
	0xbc, 0xcd, 0x6b, 0x12, 0xfc, 0x8f, 0x6d, 0xfe, 0xe7, 0x4e, 0x3c, 0x12, 0xac, 0x74, 0xe2, 0x91,
	0x60, 0x68, 0xf1, 0x3b, 0x83, 0xc3, 0x6b, 0x8d, 0xd4, 0x3c, 0x12, 0x64, 0x7d, 0xc0, 0x17, 0x40,
	0xf6, 0x28, 0x23, 0x16, 0x61, 0x44, 0xad, 0x7c, 0xe2, 0x48, 0xe7, 0xac, 0x8b, 0x92, 0x5c, 0x54,
	0x4a, 0x47, 0x7d, 0x00, 0xaf, 0x7c, 0x3b, 0xbf, 0xbf, 0xce, 0xfd, 0xd0, 0x23, 0x0c, 0x36, 0xc1,
	0xde, 0xd5, 0xb8, 0x8f, 0x8d, 0x61, 0x1f, 0x9f, 0x8f, 0xd1, 0xb5, 0x66, 0xe2, 0x5f, 0x46, 0x97,
	0xa3, 0xf1, 0xaf, 0x23, 0xe5, 0x09, 0xdc, 0x05, 0x5b, 0x6b, 0xb9, 0xd7, 0x2f, 0x15, 0x89, 0x1b,
	0x5d, 0x93, 0xe0, 0x01, 0xa3, 0x6b, 0x6d, 0xf2, 0x51, 0xa3, 0xb5, 0x9c, 0x30, 0xfa, 0x43, 0x02,
	0xf5, 0xd5, 0x77, 0x09, 0xdc, 0x07, 0xbb, 0xa9, 0x08, 0x0f, 0x34, 0x63, 0x80, 0x0d, 0x13, 0x69,
	0xa6, 0xde, 0x7f, 0xa3, 0x3c, 0x81, 0x10, 0x34, 0xd0, 0x79, 0xf7, 0xf4, 0xa7, 0xd3, 0x0e, 0x36,
	0x06, 0x5a, 0xe7, 0xe4, 0x54, 0x91, 0xe0, 0x36, 0xd8, 0x34, 0x75, 0xc3, 0xc4, 0xdc, 0x9b, 0xf3,
	0x75, 0xa4, 0x14, 0xb8, 0xc7, 0xf8, 0xec, 0x42, 0xef, 0x9a, 0x78, 0x8d, 0x5f, 0xe4, 0x65, 0x74,
	0xc7, 0xa3, 0xe1, 0xa5, 0xc1, 0xa1, 0x93, 0x97, 0x1d, 0xcc, 0xe1, 0xd2, 0xd1, 0xef, 0xa0, 0x9a,
	0xbf, 0x39, 0xe1, 0x1e, 0x80, 0x59, 0x09, 0x26, 0xd2, 0x75, 0x6c, 0x98, 0x9a, 0xa9, 0x2b, 0x4f,
	0x20, 0x00, 0x65, 0xad, 0x6b, 0x0e, 0x5f, 0xeb, 0x8a, 0xc4, 0xd7, 0xe7, 0x68, 0x7c, 0xa3, 0x8f,
	0x94, 0x02, 0x7c, 0x0e, 0x9e, 0xf5, 0xf4, 0x09, 0xd2, 0xbb, 0x9a, 0xa9, 0xf7, 0xb0, 0x31, 0x3e,
	0x37, 0x71, 0x4f, 0xbf, 0xd2, 0x4d, 0xbd, 0xa7, 0x14, 0x9b, 0x05, 0x59, 0x5a, 0x23, 0x0c, 0x34,
	0xd4, 0xcb, 0x09, 0x25, 0x4e, 0x38, 0xea, 0x03, 0x39, 0x7b, 0x0b, 0xf3, 0x0a, 0xef, 0xec, 0x6e,
	0xbe, 0x99, 0xf0, 0xcd, 0x2b, 0xa0, 0x78, 0x35, 0xee, 0x2b, 0x12, 0x5f, 0x5c, 0x6b, 0x13, 0xa5,
	0xc0, 0x7f, 0x8e, 0x09, 0xd2, 0xc7, 0xa8, 0xa7, 0x23, 0xbd, 0x87, 0x79, 0xb2, 0x78, 0x36, 0x00,
	0xfb, 0x33, 0xdf, 0xcb, 0x66, 0xe1, 0xee, 0x87, 0xcf, 0xd9, 0x86, 0x99, 0xc6, 0x13, 0x1e, 0x4e,
	0xa4, 0x9b, 0xa6, 0xed, 0xb0, 0xf9, 0x72, 0xda, 0x9e, 0xf9, 0xde, 0x71, 0xfa, 0x65, 0x92, 0x49,
	0xa6, 0x65, 0xa1, 0xf9, 0xe1, 0xdf, 0x00, 0x00, 0x00, 0xff, 0xff, 0x77, 0xff, 0x6e, 0x8e, 0x3e,
	0x09, 0x00, 0x00,
}
