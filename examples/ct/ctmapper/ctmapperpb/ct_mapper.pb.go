// Code generated by protoc-gen-go. DO NOT EDIT.
// source: ct_mapper.proto

/*
Package ctmapperpb is a generated protocol buffer package.

It is generated from these files:
	ct_mapper.proto

It has these top-level messages:
	MapperMetadata
	EntryList
*/
package ctmapperpb

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// MapperMetadata represents the state of the CT Mapper after it
// completes a run of loading the Map from the CT Log being watched.
// It is effectively a cursor over the source CT Log.
type MapperMetadata struct {
	// LogID of the CT log source.
	SourceLogId []byte `protobuf:"bytes,1,opt,name=source_log_id,json=sourceLogId,proto3" json:"source_log_id,omitempty"`
	// Log Index in the source log of the highest entry mapped
	// in an earlier run.
	HighestFullyCompletedSeq int64 `protobuf:"varint,2,opt,name=highest_fully_completed_seq,json=highestFullyCompletedSeq" json:"highest_fully_completed_seq,omitempty"`
}

func (m *MapperMetadata) Reset()                    { *m = MapperMetadata{} }
func (m *MapperMetadata) String() string            { return proto.CompactTextString(m) }
func (*MapperMetadata) ProtoMessage()               {}
func (*MapperMetadata) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *MapperMetadata) GetSourceLogId() []byte {
	if m != nil {
		return m.SourceLogId
	}
	return nil
}

func (m *MapperMetadata) GetHighestFullyCompletedSeq() int64 {
	if m != nil {
		return m.HighestFullyCompletedSeq
	}
	return 0
}

// EntryList represents a mapping stored in the Map after a source
// CT Log has been fetched and mapped.  It holds the entry indices
// from the Log for all certificates and all pre-certificates that
// reference a particular domain.
type EntryList struct {
	// The domain referenced by entries in the mapped CT Log.
	Domain string `protobuf:"bytes,1,opt,name=domain" json:"domain,omitempty"`
	// All log indexes of mapped Log entries referencing domain in
	// X.509 certs.
	CertIndex []int64 `protobuf:"varint,2,rep,packed,name=cert_index,json=certIndex" json:"cert_index,omitempty"`
	// All log indexes of mapped Log entries referencing domain in
	// pre-certs.
	PrecertIndex []int64 `protobuf:"varint,3,rep,packed,name=precert_index,json=precertIndex" json:"precert_index,omitempty"`
}

func (m *EntryList) Reset()                    { *m = EntryList{} }
func (m *EntryList) String() string            { return proto.CompactTextString(m) }
func (*EntryList) ProtoMessage()               {}
func (*EntryList) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *EntryList) GetDomain() string {
	if m != nil {
		return m.Domain
	}
	return ""
}

func (m *EntryList) GetCertIndex() []int64 {
	if m != nil {
		return m.CertIndex
	}
	return nil
}

func (m *EntryList) GetPrecertIndex() []int64 {
	if m != nil {
		return m.PrecertIndex
	}
	return nil
}

func init() {
	proto.RegisterType((*MapperMetadata)(nil), "ctmapperpb.MapperMetadata")
	proto.RegisterType((*EntryList)(nil), "ctmapperpb.EntryList")
}

func init() { proto.RegisterFile("ct_mapper.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 215 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x4c, 0xcf, 0xc1, 0x4b, 0xc3, 0x30,
	0x14, 0xc7, 0x71, 0xba, 0xc2, 0xa0, 0xcf, 0x4d, 0x21, 0x07, 0x09, 0x88, 0x50, 0xea, 0xa5, 0x27,
	0x2f, 0x9e, 0x3d, 0x89, 0xc2, 0x60, 0xbb, 0xc4, 0x3f, 0x20, 0x64, 0xc9, 0x33, 0x0b, 0xa4, 0x4d,
	0x96, 0xbc, 0x81, 0xfb, 0xef, 0xa5, 0x69, 0x85, 0xdd, 0xf2, 0xfb, 0xf2, 0x81, 0xf0, 0xe0, 0x41,
	0x93, 0x1c, 0x54, 0x8c, 0x98, 0x5e, 0x63, 0x0a, 0x14, 0x18, 0x68, 0x9a, 0x77, 0x3c, 0x76, 0x19,
	0xee, 0x0f, 0xe5, 0x7d, 0x40, 0x52, 0x46, 0x91, 0x62, 0x1d, 0x6c, 0x73, 0xb8, 0x24, 0x8d, 0xd2,
	0x07, 0x2b, 0x9d, 0xe1, 0x55, 0x5b, 0xf5, 0x1b, 0x71, 0x37, 0xc7, 0x7d, 0xb0, 0x3b, 0xc3, 0xde,
	0xe1, 0xe9, 0xe4, 0xec, 0x09, 0x33, 0xc9, 0x9f, 0x8b, 0xf7, 0x57, 0xa9, 0xc3, 0x10, 0x3d, 0x12,
	0x1a, 0x99, 0xf1, 0xcc, 0x57, 0x6d, 0xd5, 0xd7, 0x82, 0x2f, 0xe4, 0x6b, 0x12, 0x1f, 0xff, 0xe0,
	0x1b, 0xcf, 0x9d, 0x85, 0xe6, 0x73, 0xa4, 0x74, 0xdd, 0xbb, 0x4c, 0xec, 0x11, 0xd6, 0x26, 0x0c,
	0xca, 0x8d, 0xe5, 0xa3, 0x46, 0x2c, 0x8b, 0x3d, 0x03, 0x68, 0x4c, 0x24, 0xdd, 0x68, 0xf0, 0x97,
	0xaf, 0xda, 0xba, 0xaf, 0x45, 0x33, 0x95, 0xdd, 0x14, 0xd8, 0x0b, 0x6c, 0x63, 0xc2, 0x1b, 0x51,
	0x17, 0xb1, 0x59, 0x62, 0x41, 0xc7, 0x75, 0x39, 0xf8, 0xed, 0x2f, 0x00, 0x00, 0xff, 0xff, 0xa7,
	0x09, 0xed, 0x2c, 0x03, 0x01, 0x00, 0x00,
}
