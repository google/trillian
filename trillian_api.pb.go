// Code generated by protoc-gen-go.
// source: trillian_api.proto
// DO NOT EDIT!

/*
Package trillian is a generated protocol buffer package.

It is generated from these files:
	trillian_api.proto
	trillian.proto

It has these top-level messages:
	LogLeaf
	Node
	Proof
	QueueLeavesRequest
	QueueLeafRequest
	QueueLeavesResponse
	GetInclusionProofRequest
	GetInclusionProofResponse
	GetInclusionProofByHashRequest
	GetInclusionProofByHashResponse
	GetConsistencyProofRequest
	GetConsistencyProofResponse
	GetLeavesByHashRequest
	GetLeavesByHashResponse
	GetLeavesByIndexRequest
	GetLeavesByIndexResponse
	GetSequencedLeafCountRequest
	GetSequencedLeafCountResponse
	GetLatestSignedLogRootRequest
	GetLatestSignedLogRootResponse
	GetEntryAndProofRequest
	GetEntryAndProofResponse
	MapLeaf
	IndexValue
	IndexValueInclusion
	GetMapLeavesRequest
	GetMapLeavesResponse
	SetMapLeavesRequest
	SetMapLeavesResponse
	GetSignedMapRootRequest
	GetSignedMapRootResponse
	ListTreesRequest
	ListTreesResponse
	GetTreeRequest
	CreateTreeRequest
	UpdateTreeRequest
	DeleteTreeRequest
	Tree
	SignedEntryTimestamp
	SignedLogRoot
	MapperMetadata
	SignedMapRoot
*/
package trillian

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import google_protobuf "github.com/golang/protobuf/ptypes/empty"
import google_protobuf1 "google.golang.org/genproto/protobuf/field_mask"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type LogLeaf struct {
	// merkle_leaf_hash is over leaf data and optional extra_data.
	MerkleLeafHash []byte `protobuf:"bytes,1,opt,name=merkle_leaf_hash,json=merkleLeafHash,proto3" json:"merkle_leaf_hash,omitempty"`
	// leaf_value contains arbitrary data.
	LeafValue []byte `protobuf:"bytes,2,opt,name=leaf_value,json=leafValue,proto3" json:"leaf_value,omitempty"`
	// extra_data is optional metadata. e.g. a timestamp.
	ExtraData []byte `protobuf:"bytes,3,opt,name=extra_data,json=extraData,proto3" json:"extra_data,omitempty"`
	// leaf_index is optional. Trillian will assign the next available index when unset.
	// TODO: remove this into separate AddSequencedLeaves API.
	LeafIndex int64 `protobuf:"varint,4,opt,name=leaf_index,json=leafIndex" json:"leaf_index,omitempty"`
	// leaf_identity_hash is a hash over the identity of this leaf.
	// It's intended to provide a mechanism for the personality to provide a
	// hint to Trillian that two leaves should be considered "duplicates" even
	// though their leaf_values differ.
	//
	// E.g. in a CT personality multiple add-chain calls for an identical
	// certificate would produce differing leaf_data bytes (due to the presence
	// of SCT elements), with just this information Trillian would be unable to
	// determine that, within the context of the personality, these entries are
	// dupes, so the CT personality sets leaf_identity_hash to H(cert),
	// which allows Trillian to detect the duplicates.
	//
	// Continuing the CT example, for a CT mirror personality (which must allow
	// dupes since the source log could contain them), the part of the
	// personality which fetches and submits the entries might set
	// leaf_identity_hash to H(seq||certdata).
	LeafIdentityHash []byte `protobuf:"bytes,5,opt,name=leaf_identity_hash,json=leafIdentityHash,proto3" json:"leaf_identity_hash,omitempty"`
}

func (m *LogLeaf) Reset()                    { *m = LogLeaf{} }
func (m *LogLeaf) String() string            { return proto.CompactTextString(m) }
func (*LogLeaf) ProtoMessage()               {}
func (*LogLeaf) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *LogLeaf) GetMerkleLeafHash() []byte {
	if m != nil {
		return m.MerkleLeafHash
	}
	return nil
}

func (m *LogLeaf) GetLeafValue() []byte {
	if m != nil {
		return m.LeafValue
	}
	return nil
}

func (m *LogLeaf) GetExtraData() []byte {
	if m != nil {
		return m.ExtraData
	}
	return nil
}

func (m *LogLeaf) GetLeafIndex() int64 {
	if m != nil {
		return m.LeafIndex
	}
	return 0
}

func (m *LogLeaf) GetLeafIdentityHash() []byte {
	if m != nil {
		return m.LeafIdentityHash
	}
	return nil
}

type Node struct {
	// TODO(Martin2112): remove node_id and node_revision
	NodeId       []byte `protobuf:"bytes,1,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
	NodeHash     []byte `protobuf:"bytes,2,opt,name=node_hash,json=nodeHash,proto3" json:"node_hash,omitempty"`
	NodeRevision int64  `protobuf:"varint,3,opt,name=node_revision,json=nodeRevision" json:"node_revision,omitempty"`
}

func (m *Node) Reset()                    { *m = Node{} }
func (m *Node) String() string            { return proto.CompactTextString(m) }
func (*Node) ProtoMessage()               {}
func (*Node) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *Node) GetNodeId() []byte {
	if m != nil {
		return m.NodeId
	}
	return nil
}

func (m *Node) GetNodeHash() []byte {
	if m != nil {
		return m.NodeHash
	}
	return nil
}

func (m *Node) GetNodeRevision() int64 {
	if m != nil {
		return m.NodeRevision
	}
	return 0
}

type Proof struct {
	LeafIndex int64   `protobuf:"varint,1,opt,name=leaf_index,json=leafIndex" json:"leaf_index,omitempty"`
	ProofNode []*Node `protobuf:"bytes,2,rep,name=proof_node,json=proofNode" json:"proof_node,omitempty"`
}

func (m *Proof) Reset()                    { *m = Proof{} }
func (m *Proof) String() string            { return proto.CompactTextString(m) }
func (*Proof) ProtoMessage()               {}
func (*Proof) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *Proof) GetLeafIndex() int64 {
	if m != nil {
		return m.LeafIndex
	}
	return 0
}

func (m *Proof) GetProofNode() []*Node {
	if m != nil {
		return m.ProofNode
	}
	return nil
}

type QueueLeavesRequest struct {
	LogId  int64      `protobuf:"varint,1,opt,name=log_id,json=logId" json:"log_id,omitempty"`
	Leaves []*LogLeaf `protobuf:"bytes,2,rep,name=leaves" json:"leaves,omitempty"`
}

func (m *QueueLeavesRequest) Reset()                    { *m = QueueLeavesRequest{} }
func (m *QueueLeavesRequest) String() string            { return proto.CompactTextString(m) }
func (*QueueLeavesRequest) ProtoMessage()               {}
func (*QueueLeavesRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *QueueLeavesRequest) GetLogId() int64 {
	if m != nil {
		return m.LogId
	}
	return 0
}

func (m *QueueLeavesRequest) GetLeaves() []*LogLeaf {
	if m != nil {
		return m.Leaves
	}
	return nil
}

type QueueLeafRequest struct {
	LogId int64    `protobuf:"varint,1,opt,name=log_id,json=logId" json:"log_id,omitempty"`
	Leaf  *LogLeaf `protobuf:"bytes,2,opt,name=leaf" json:"leaf,omitempty"`
}

func (m *QueueLeafRequest) Reset()                    { *m = QueueLeafRequest{} }
func (m *QueueLeafRequest) String() string            { return proto.CompactTextString(m) }
func (*QueueLeafRequest) ProtoMessage()               {}
func (*QueueLeafRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *QueueLeafRequest) GetLogId() int64 {
	if m != nil {
		return m.LogId
	}
	return 0
}

func (m *QueueLeafRequest) GetLeaf() *LogLeaf {
	if m != nil {
		return m.Leaf
	}
	return nil
}

// TODO(Martin2112): This will eventually contain the signed timestamps and stuff that we return for
// the queued leaves
type QueueLeavesResponse struct {
}

func (m *QueueLeavesResponse) Reset()                    { *m = QueueLeavesResponse{} }
func (m *QueueLeavesResponse) String() string            { return proto.CompactTextString(m) }
func (*QueueLeavesResponse) ProtoMessage()               {}
func (*QueueLeavesResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

type GetInclusionProofRequest struct {
	LogId     int64 `protobuf:"varint,1,opt,name=log_id,json=logId" json:"log_id,omitempty"`
	LeafIndex int64 `protobuf:"varint,2,opt,name=leaf_index,json=leafIndex" json:"leaf_index,omitempty"`
	TreeSize  int64 `protobuf:"varint,3,opt,name=tree_size,json=treeSize" json:"tree_size,omitempty"`
}

func (m *GetInclusionProofRequest) Reset()                    { *m = GetInclusionProofRequest{} }
func (m *GetInclusionProofRequest) String() string            { return proto.CompactTextString(m) }
func (*GetInclusionProofRequest) ProtoMessage()               {}
func (*GetInclusionProofRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *GetInclusionProofRequest) GetLogId() int64 {
	if m != nil {
		return m.LogId
	}
	return 0
}

func (m *GetInclusionProofRequest) GetLeafIndex() int64 {
	if m != nil {
		return m.LeafIndex
	}
	return 0
}

func (m *GetInclusionProofRequest) GetTreeSize() int64 {
	if m != nil {
		return m.TreeSize
	}
	return 0
}

type GetInclusionProofResponse struct {
	Proof *Proof `protobuf:"bytes,2,opt,name=proof" json:"proof,omitempty"`
}

func (m *GetInclusionProofResponse) Reset()                    { *m = GetInclusionProofResponse{} }
func (m *GetInclusionProofResponse) String() string            { return proto.CompactTextString(m) }
func (*GetInclusionProofResponse) ProtoMessage()               {}
func (*GetInclusionProofResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *GetInclusionProofResponse) GetProof() *Proof {
	if m != nil {
		return m.Proof
	}
	return nil
}

type GetInclusionProofByHashRequest struct {
	LogId           int64  `protobuf:"varint,1,opt,name=log_id,json=logId" json:"log_id,omitempty"`
	LeafHash        []byte `protobuf:"bytes,2,opt,name=leaf_hash,json=leafHash,proto3" json:"leaf_hash,omitempty"`
	TreeSize        int64  `protobuf:"varint,3,opt,name=tree_size,json=treeSize" json:"tree_size,omitempty"`
	OrderBySequence bool   `protobuf:"varint,4,opt,name=order_by_sequence,json=orderBySequence" json:"order_by_sequence,omitempty"`
}

func (m *GetInclusionProofByHashRequest) Reset()                    { *m = GetInclusionProofByHashRequest{} }
func (m *GetInclusionProofByHashRequest) String() string            { return proto.CompactTextString(m) }
func (*GetInclusionProofByHashRequest) ProtoMessage()               {}
func (*GetInclusionProofByHashRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *GetInclusionProofByHashRequest) GetLogId() int64 {
	if m != nil {
		return m.LogId
	}
	return 0
}

func (m *GetInclusionProofByHashRequest) GetLeafHash() []byte {
	if m != nil {
		return m.LeafHash
	}
	return nil
}

func (m *GetInclusionProofByHashRequest) GetTreeSize() int64 {
	if m != nil {
		return m.TreeSize
	}
	return 0
}

func (m *GetInclusionProofByHashRequest) GetOrderBySequence() bool {
	if m != nil {
		return m.OrderBySequence
	}
	return false
}

type GetInclusionProofByHashResponse struct {
	// Logs can potentially contain leaves with duplicate hashes so it's possible
	// for this to return multiple proofs.
	// TODO(gbelvin) only return one proof.
	Proof []*Proof `protobuf:"bytes,2,rep,name=proof" json:"proof,omitempty"`
}

func (m *GetInclusionProofByHashResponse) Reset()                    { *m = GetInclusionProofByHashResponse{} }
func (m *GetInclusionProofByHashResponse) String() string            { return proto.CompactTextString(m) }
func (*GetInclusionProofByHashResponse) ProtoMessage()               {}
func (*GetInclusionProofByHashResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *GetInclusionProofByHashResponse) GetProof() []*Proof {
	if m != nil {
		return m.Proof
	}
	return nil
}

type GetConsistencyProofRequest struct {
	LogId          int64 `protobuf:"varint,1,opt,name=log_id,json=logId" json:"log_id,omitempty"`
	FirstTreeSize  int64 `protobuf:"varint,2,opt,name=first_tree_size,json=firstTreeSize" json:"first_tree_size,omitempty"`
	SecondTreeSize int64 `protobuf:"varint,3,opt,name=second_tree_size,json=secondTreeSize" json:"second_tree_size,omitempty"`
}

func (m *GetConsistencyProofRequest) Reset()                    { *m = GetConsistencyProofRequest{} }
func (m *GetConsistencyProofRequest) String() string            { return proto.CompactTextString(m) }
func (*GetConsistencyProofRequest) ProtoMessage()               {}
func (*GetConsistencyProofRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *GetConsistencyProofRequest) GetLogId() int64 {
	if m != nil {
		return m.LogId
	}
	return 0
}

func (m *GetConsistencyProofRequest) GetFirstTreeSize() int64 {
	if m != nil {
		return m.FirstTreeSize
	}
	return 0
}

func (m *GetConsistencyProofRequest) GetSecondTreeSize() int64 {
	if m != nil {
		return m.SecondTreeSize
	}
	return 0
}

type GetConsistencyProofResponse struct {
	Proof *Proof `protobuf:"bytes,2,opt,name=proof" json:"proof,omitempty"`
}

func (m *GetConsistencyProofResponse) Reset()                    { *m = GetConsistencyProofResponse{} }
func (m *GetConsistencyProofResponse) String() string            { return proto.CompactTextString(m) }
func (*GetConsistencyProofResponse) ProtoMessage()               {}
func (*GetConsistencyProofResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *GetConsistencyProofResponse) GetProof() *Proof {
	if m != nil {
		return m.Proof
	}
	return nil
}

type GetLeavesByHashRequest struct {
	LogId           int64    `protobuf:"varint,1,opt,name=log_id,json=logId" json:"log_id,omitempty"`
	LeafHash        [][]byte `protobuf:"bytes,2,rep,name=leaf_hash,json=leafHash,proto3" json:"leaf_hash,omitempty"`
	OrderBySequence bool     `protobuf:"varint,3,opt,name=order_by_sequence,json=orderBySequence" json:"order_by_sequence,omitempty"`
}

func (m *GetLeavesByHashRequest) Reset()                    { *m = GetLeavesByHashRequest{} }
func (m *GetLeavesByHashRequest) String() string            { return proto.CompactTextString(m) }
func (*GetLeavesByHashRequest) ProtoMessage()               {}
func (*GetLeavesByHashRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *GetLeavesByHashRequest) GetLogId() int64 {
	if m != nil {
		return m.LogId
	}
	return 0
}

func (m *GetLeavesByHashRequest) GetLeafHash() [][]byte {
	if m != nil {
		return m.LeafHash
	}
	return nil
}

func (m *GetLeavesByHashRequest) GetOrderBySequence() bool {
	if m != nil {
		return m.OrderBySequence
	}
	return false
}

type GetLeavesByHashResponse struct {
	// TODO(gbelvin) reply with error codes.
	Leaves []*LogLeaf `protobuf:"bytes,2,rep,name=leaves" json:"leaves,omitempty"`
}

func (m *GetLeavesByHashResponse) Reset()                    { *m = GetLeavesByHashResponse{} }
func (m *GetLeavesByHashResponse) String() string            { return proto.CompactTextString(m) }
func (*GetLeavesByHashResponse) ProtoMessage()               {}
func (*GetLeavesByHashResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *GetLeavesByHashResponse) GetLeaves() []*LogLeaf {
	if m != nil {
		return m.Leaves
	}
	return nil
}

type GetLeavesByIndexRequest struct {
	LogId     int64   `protobuf:"varint,1,opt,name=log_id,json=logId" json:"log_id,omitempty"`
	LeafIndex []int64 `protobuf:"varint,2,rep,packed,name=leaf_index,json=leafIndex" json:"leaf_index,omitempty"`
}

func (m *GetLeavesByIndexRequest) Reset()                    { *m = GetLeavesByIndexRequest{} }
func (m *GetLeavesByIndexRequest) String() string            { return proto.CompactTextString(m) }
func (*GetLeavesByIndexRequest) ProtoMessage()               {}
func (*GetLeavesByIndexRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

func (m *GetLeavesByIndexRequest) GetLogId() int64 {
	if m != nil {
		return m.LogId
	}
	return 0
}

func (m *GetLeavesByIndexRequest) GetLeafIndex() []int64 {
	if m != nil {
		return m.LeafIndex
	}
	return nil
}

type GetLeavesByIndexResponse struct {
	// TODO(gbelvin) reply with error codes.
	Leaves []*LogLeaf `protobuf:"bytes,2,rep,name=leaves" json:"leaves,omitempty"`
}

func (m *GetLeavesByIndexResponse) Reset()                    { *m = GetLeavesByIndexResponse{} }
func (m *GetLeavesByIndexResponse) String() string            { return proto.CompactTextString(m) }
func (*GetLeavesByIndexResponse) ProtoMessage()               {}
func (*GetLeavesByIndexResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

func (m *GetLeavesByIndexResponse) GetLeaves() []*LogLeaf {
	if m != nil {
		return m.Leaves
	}
	return nil
}

type GetSequencedLeafCountRequest struct {
	LogId int64 `protobuf:"varint,1,opt,name=log_id,json=logId" json:"log_id,omitempty"`
}

func (m *GetSequencedLeafCountRequest) Reset()                    { *m = GetSequencedLeafCountRequest{} }
func (m *GetSequencedLeafCountRequest) String() string            { return proto.CompactTextString(m) }
func (*GetSequencedLeafCountRequest) ProtoMessage()               {}
func (*GetSequencedLeafCountRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{16} }

func (m *GetSequencedLeafCountRequest) GetLogId() int64 {
	if m != nil {
		return m.LogId
	}
	return 0
}

type GetSequencedLeafCountResponse struct {
	LeafCount int64 `protobuf:"varint,2,opt,name=leaf_count,json=leafCount" json:"leaf_count,omitempty"`
}

func (m *GetSequencedLeafCountResponse) Reset()                    { *m = GetSequencedLeafCountResponse{} }
func (m *GetSequencedLeafCountResponse) String() string            { return proto.CompactTextString(m) }
func (*GetSequencedLeafCountResponse) ProtoMessage()               {}
func (*GetSequencedLeafCountResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{17} }

func (m *GetSequencedLeafCountResponse) GetLeafCount() int64 {
	if m != nil {
		return m.LeafCount
	}
	return 0
}

type GetLatestSignedLogRootRequest struct {
	LogId int64 `protobuf:"varint,1,opt,name=log_id,json=logId" json:"log_id,omitempty"`
}

func (m *GetLatestSignedLogRootRequest) Reset()                    { *m = GetLatestSignedLogRootRequest{} }
func (m *GetLatestSignedLogRootRequest) String() string            { return proto.CompactTextString(m) }
func (*GetLatestSignedLogRootRequest) ProtoMessage()               {}
func (*GetLatestSignedLogRootRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{18} }

func (m *GetLatestSignedLogRootRequest) GetLogId() int64 {
	if m != nil {
		return m.LogId
	}
	return 0
}

type GetLatestSignedLogRootResponse struct {
	SignedLogRoot *SignedLogRoot `protobuf:"bytes,2,opt,name=signed_log_root,json=signedLogRoot" json:"signed_log_root,omitempty"`
}

func (m *GetLatestSignedLogRootResponse) Reset()                    { *m = GetLatestSignedLogRootResponse{} }
func (m *GetLatestSignedLogRootResponse) String() string            { return proto.CompactTextString(m) }
func (*GetLatestSignedLogRootResponse) ProtoMessage()               {}
func (*GetLatestSignedLogRootResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{19} }

func (m *GetLatestSignedLogRootResponse) GetSignedLogRoot() *SignedLogRoot {
	if m != nil {
		return m.SignedLogRoot
	}
	return nil
}

type GetEntryAndProofRequest struct {
	LogId     int64 `protobuf:"varint,1,opt,name=log_id,json=logId" json:"log_id,omitempty"`
	LeafIndex int64 `protobuf:"varint,2,opt,name=leaf_index,json=leafIndex" json:"leaf_index,omitempty"`
	TreeSize  int64 `protobuf:"varint,3,opt,name=tree_size,json=treeSize" json:"tree_size,omitempty"`
}

func (m *GetEntryAndProofRequest) Reset()                    { *m = GetEntryAndProofRequest{} }
func (m *GetEntryAndProofRequest) String() string            { return proto.CompactTextString(m) }
func (*GetEntryAndProofRequest) ProtoMessage()               {}
func (*GetEntryAndProofRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{20} }

func (m *GetEntryAndProofRequest) GetLogId() int64 {
	if m != nil {
		return m.LogId
	}
	return 0
}

func (m *GetEntryAndProofRequest) GetLeafIndex() int64 {
	if m != nil {
		return m.LeafIndex
	}
	return 0
}

func (m *GetEntryAndProofRequest) GetTreeSize() int64 {
	if m != nil {
		return m.TreeSize
	}
	return 0
}

type GetEntryAndProofResponse struct {
	Proof *Proof   `protobuf:"bytes,2,opt,name=proof" json:"proof,omitempty"`
	Leaf  *LogLeaf `protobuf:"bytes,3,opt,name=leaf" json:"leaf,omitempty"`
}

func (m *GetEntryAndProofResponse) Reset()                    { *m = GetEntryAndProofResponse{} }
func (m *GetEntryAndProofResponse) String() string            { return proto.CompactTextString(m) }
func (*GetEntryAndProofResponse) ProtoMessage()               {}
func (*GetEntryAndProofResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{21} }

func (m *GetEntryAndProofResponse) GetProof() *Proof {
	if m != nil {
		return m.Proof
	}
	return nil
}

func (m *GetEntryAndProofResponse) GetLeaf() *LogLeaf {
	if m != nil {
		return m.Leaf
	}
	return nil
}

// MapLeaf represents the data behind Map leaves.
type MapLeaf struct {
	// index is the location of this leaf.
	// All indexes for a given Map must contain a constant number of bits.
	Index []byte `protobuf:"bytes,1,opt,name=index,proto3" json:"index,omitempty"`
	// leaf_hash is the tree hash of leaf_value.
	LeafHash []byte `protobuf:"bytes,2,opt,name=leaf_hash,json=leafHash,proto3" json:"leaf_hash,omitempty"`
	// leaf_value is the data the tree commits to.
	LeafValue []byte `protobuf:"bytes,3,opt,name=leaf_value,json=leafValue,proto3" json:"leaf_value,omitempty"`
	// extra_data holds related contextual data, but is not covered by any hash.
	ExtraData []byte `protobuf:"bytes,4,opt,name=extra_data,json=extraData,proto3" json:"extra_data,omitempty"`
}

func (m *MapLeaf) Reset()                    { *m = MapLeaf{} }
func (m *MapLeaf) String() string            { return proto.CompactTextString(m) }
func (*MapLeaf) ProtoMessage()               {}
func (*MapLeaf) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{22} }

func (m *MapLeaf) GetIndex() []byte {
	if m != nil {
		return m.Index
	}
	return nil
}

func (m *MapLeaf) GetLeafHash() []byte {
	if m != nil {
		return m.LeafHash
	}
	return nil
}

func (m *MapLeaf) GetLeafValue() []byte {
	if m != nil {
		return m.LeafValue
	}
	return nil
}

func (m *MapLeaf) GetExtraData() []byte {
	if m != nil {
		return m.ExtraData
	}
	return nil
}

type IndexValue struct {
	// TODO(gbelvin): RemoveIndex value in favor of using the index inside MapLeaf.
	Index []byte   `protobuf:"bytes,1,opt,name=index,proto3" json:"index,omitempty"`
	Value *MapLeaf `protobuf:"bytes,2,opt,name=value" json:"value,omitempty"`
}

func (m *IndexValue) Reset()                    { *m = IndexValue{} }
func (m *IndexValue) String() string            { return proto.CompactTextString(m) }
func (*IndexValue) ProtoMessage()               {}
func (*IndexValue) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{23} }

func (m *IndexValue) GetIndex() []byte {
	if m != nil {
		return m.Index
	}
	return nil
}

func (m *IndexValue) GetValue() *MapLeaf {
	if m != nil {
		return m.Value
	}
	return nil
}

type IndexValueInclusion struct {
	IndexValue *IndexValue `protobuf:"bytes,1,opt,name=index_value,json=indexValue" json:"index_value,omitempty"`
	Inclusion  [][]byte    `protobuf:"bytes,2,rep,name=inclusion,proto3" json:"inclusion,omitempty"`
}

func (m *IndexValueInclusion) Reset()                    { *m = IndexValueInclusion{} }
func (m *IndexValueInclusion) String() string            { return proto.CompactTextString(m) }
func (*IndexValueInclusion) ProtoMessage()               {}
func (*IndexValueInclusion) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{24} }

func (m *IndexValueInclusion) GetIndexValue() *IndexValue {
	if m != nil {
		return m.IndexValue
	}
	return nil
}

func (m *IndexValueInclusion) GetInclusion() [][]byte {
	if m != nil {
		return m.Inclusion
	}
	return nil
}

type GetMapLeavesRequest struct {
	MapId    int64    `protobuf:"varint,1,opt,name=map_id,json=mapId" json:"map_id,omitempty"`
	Index    [][]byte `protobuf:"bytes,2,rep,name=index,proto3" json:"index,omitempty"`
	Revision int64    `protobuf:"varint,3,opt,name=revision" json:"revision,omitempty"`
}

func (m *GetMapLeavesRequest) Reset()                    { *m = GetMapLeavesRequest{} }
func (m *GetMapLeavesRequest) String() string            { return proto.CompactTextString(m) }
func (*GetMapLeavesRequest) ProtoMessage()               {}
func (*GetMapLeavesRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{25} }

func (m *GetMapLeavesRequest) GetMapId() int64 {
	if m != nil {
		return m.MapId
	}
	return 0
}

func (m *GetMapLeavesRequest) GetIndex() [][]byte {
	if m != nil {
		return m.Index
	}
	return nil
}

func (m *GetMapLeavesRequest) GetRevision() int64 {
	if m != nil {
		return m.Revision
	}
	return 0
}

type GetMapLeavesResponse struct {
	// TODO(gbelvin): Return an error per index lookup.
	IndexValueInclusion []*IndexValueInclusion `protobuf:"bytes,2,rep,name=index_value_inclusion,json=indexValueInclusion" json:"index_value_inclusion,omitempty"`
	MapRoot             *SignedMapRoot         `protobuf:"bytes,3,opt,name=map_root,json=mapRoot" json:"map_root,omitempty"`
}

func (m *GetMapLeavesResponse) Reset()                    { *m = GetMapLeavesResponse{} }
func (m *GetMapLeavesResponse) String() string            { return proto.CompactTextString(m) }
func (*GetMapLeavesResponse) ProtoMessage()               {}
func (*GetMapLeavesResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{26} }

func (m *GetMapLeavesResponse) GetIndexValueInclusion() []*IndexValueInclusion {
	if m != nil {
		return m.IndexValueInclusion
	}
	return nil
}

func (m *GetMapLeavesResponse) GetMapRoot() *SignedMapRoot {
	if m != nil {
		return m.MapRoot
	}
	return nil
}

type SetMapLeavesRequest struct {
	MapId      int64           `protobuf:"varint,1,opt,name=map_id,json=mapId" json:"map_id,omitempty"`
	IndexValue []*IndexValue   `protobuf:"bytes,2,rep,name=index_value,json=indexValue" json:"index_value,omitempty"`
	MapperData *MapperMetadata `protobuf:"bytes,3,opt,name=mapper_data,json=mapperData" json:"mapper_data,omitempty"`
}

func (m *SetMapLeavesRequest) Reset()                    { *m = SetMapLeavesRequest{} }
func (m *SetMapLeavesRequest) String() string            { return proto.CompactTextString(m) }
func (*SetMapLeavesRequest) ProtoMessage()               {}
func (*SetMapLeavesRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{27} }

func (m *SetMapLeavesRequest) GetMapId() int64 {
	if m != nil {
		return m.MapId
	}
	return 0
}

func (m *SetMapLeavesRequest) GetIndexValue() []*IndexValue {
	if m != nil {
		return m.IndexValue
	}
	return nil
}

func (m *SetMapLeavesRequest) GetMapperData() *MapperMetadata {
	if m != nil {
		return m.MapperData
	}
	return nil
}

type SetMapLeavesResponse struct {
	MapRoot *SignedMapRoot `protobuf:"bytes,2,opt,name=map_root,json=mapRoot" json:"map_root,omitempty"`
}

func (m *SetMapLeavesResponse) Reset()                    { *m = SetMapLeavesResponse{} }
func (m *SetMapLeavesResponse) String() string            { return proto.CompactTextString(m) }
func (*SetMapLeavesResponse) ProtoMessage()               {}
func (*SetMapLeavesResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{28} }

func (m *SetMapLeavesResponse) GetMapRoot() *SignedMapRoot {
	if m != nil {
		return m.MapRoot
	}
	return nil
}

type GetSignedMapRootRequest struct {
	MapId int64 `protobuf:"varint,1,opt,name=map_id,json=mapId" json:"map_id,omitempty"`
}

func (m *GetSignedMapRootRequest) Reset()                    { *m = GetSignedMapRootRequest{} }
func (m *GetSignedMapRootRequest) String() string            { return proto.CompactTextString(m) }
func (*GetSignedMapRootRequest) ProtoMessage()               {}
func (*GetSignedMapRootRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{29} }

func (m *GetSignedMapRootRequest) GetMapId() int64 {
	if m != nil {
		return m.MapId
	}
	return 0
}

type GetSignedMapRootResponse struct {
	MapRoot *SignedMapRoot `protobuf:"bytes,2,opt,name=map_root,json=mapRoot" json:"map_root,omitempty"`
}

func (m *GetSignedMapRootResponse) Reset()                    { *m = GetSignedMapRootResponse{} }
func (m *GetSignedMapRootResponse) String() string            { return proto.CompactTextString(m) }
func (*GetSignedMapRootResponse) ProtoMessage()               {}
func (*GetSignedMapRootResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{30} }

func (m *GetSignedMapRootResponse) GetMapRoot() *SignedMapRoot {
	if m != nil {
		return m.MapRoot
	}
	return nil
}

// ListTrees request.
// No filters or pagination options are provided.
type ListTreesRequest struct {
}

func (m *ListTreesRequest) Reset()                    { *m = ListTreesRequest{} }
func (m *ListTreesRequest) String() string            { return proto.CompactTextString(m) }
func (*ListTreesRequest) ProtoMessage()               {}
func (*ListTreesRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{31} }

// ListTrees response.
// No pagination is provided, all trees the requester has access to are
// returned.
type ListTreesResponse struct {
	// Trees matching the list request filters.
	Tree []*Tree `protobuf:"bytes,1,rep,name=tree" json:"tree,omitempty"`
}

func (m *ListTreesResponse) Reset()                    { *m = ListTreesResponse{} }
func (m *ListTreesResponse) String() string            { return proto.CompactTextString(m) }
func (*ListTreesResponse) ProtoMessage()               {}
func (*ListTreesResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{32} }

func (m *ListTreesResponse) GetTree() []*Tree {
	if m != nil {
		return m.Tree
	}
	return nil
}

// GetTree request.
type GetTreeRequest struct {
	// ID of the tree to retrieve.
	TreeId int64 `protobuf:"varint,1,opt,name=tree_id,json=treeId" json:"tree_id,omitempty"`
}

func (m *GetTreeRequest) Reset()                    { *m = GetTreeRequest{} }
func (m *GetTreeRequest) String() string            { return proto.CompactTextString(m) }
func (*GetTreeRequest) ProtoMessage()               {}
func (*GetTreeRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{33} }

func (m *GetTreeRequest) GetTreeId() int64 {
	if m != nil {
		return m.TreeId
	}
	return 0
}

// CreateTree request.
type CreateTreeRequest struct {
	// Tree to be created. See Tree and CreateTree for more details.
	Tree *Tree `protobuf:"bytes,1,opt,name=tree" json:"tree,omitempty"`
}

func (m *CreateTreeRequest) Reset()                    { *m = CreateTreeRequest{} }
func (m *CreateTreeRequest) String() string            { return proto.CompactTextString(m) }
func (*CreateTreeRequest) ProtoMessage()               {}
func (*CreateTreeRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{34} }

func (m *CreateTreeRequest) GetTree() *Tree {
	if m != nil {
		return m.Tree
	}
	return nil
}

// UpdateTree request.
type UpdateTreeRequest struct {
	// Tree to be updated.
	Tree *Tree `protobuf:"bytes,1,opt,name=tree" json:"tree,omitempty"`
	// Fields modified by the update request.
	// For example: "tree_state", "display_name", "description".
	UpdateMask *google_protobuf1.FieldMask `protobuf:"bytes,2,opt,name=update_mask,json=updateMask" json:"update_mask,omitempty"`
}

func (m *UpdateTreeRequest) Reset()                    { *m = UpdateTreeRequest{} }
func (m *UpdateTreeRequest) String() string            { return proto.CompactTextString(m) }
func (*UpdateTreeRequest) ProtoMessage()               {}
func (*UpdateTreeRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{35} }

func (m *UpdateTreeRequest) GetTree() *Tree {
	if m != nil {
		return m.Tree
	}
	return nil
}

func (m *UpdateTreeRequest) GetUpdateMask() *google_protobuf1.FieldMask {
	if m != nil {
		return m.UpdateMask
	}
	return nil
}

// DeleteTree request.
type DeleteTreeRequest struct {
	// ID of the tree to delete.
	TreeId int64 `protobuf:"varint,1,opt,name=tree_id,json=treeId" json:"tree_id,omitempty"`
}

func (m *DeleteTreeRequest) Reset()                    { *m = DeleteTreeRequest{} }
func (m *DeleteTreeRequest) String() string            { return proto.CompactTextString(m) }
func (*DeleteTreeRequest) ProtoMessage()               {}
func (*DeleteTreeRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{36} }

func (m *DeleteTreeRequest) GetTreeId() int64 {
	if m != nil {
		return m.TreeId
	}
	return 0
}

func init() {
	proto.RegisterType((*LogLeaf)(nil), "trillian.LogLeaf")
	proto.RegisterType((*Node)(nil), "trillian.Node")
	proto.RegisterType((*Proof)(nil), "trillian.Proof")
	proto.RegisterType((*QueueLeavesRequest)(nil), "trillian.QueueLeavesRequest")
	proto.RegisterType((*QueueLeafRequest)(nil), "trillian.QueueLeafRequest")
	proto.RegisterType((*QueueLeavesResponse)(nil), "trillian.QueueLeavesResponse")
	proto.RegisterType((*GetInclusionProofRequest)(nil), "trillian.GetInclusionProofRequest")
	proto.RegisterType((*GetInclusionProofResponse)(nil), "trillian.GetInclusionProofResponse")
	proto.RegisterType((*GetInclusionProofByHashRequest)(nil), "trillian.GetInclusionProofByHashRequest")
	proto.RegisterType((*GetInclusionProofByHashResponse)(nil), "trillian.GetInclusionProofByHashResponse")
	proto.RegisterType((*GetConsistencyProofRequest)(nil), "trillian.GetConsistencyProofRequest")
	proto.RegisterType((*GetConsistencyProofResponse)(nil), "trillian.GetConsistencyProofResponse")
	proto.RegisterType((*GetLeavesByHashRequest)(nil), "trillian.GetLeavesByHashRequest")
	proto.RegisterType((*GetLeavesByHashResponse)(nil), "trillian.GetLeavesByHashResponse")
	proto.RegisterType((*GetLeavesByIndexRequest)(nil), "trillian.GetLeavesByIndexRequest")
	proto.RegisterType((*GetLeavesByIndexResponse)(nil), "trillian.GetLeavesByIndexResponse")
	proto.RegisterType((*GetSequencedLeafCountRequest)(nil), "trillian.GetSequencedLeafCountRequest")
	proto.RegisterType((*GetSequencedLeafCountResponse)(nil), "trillian.GetSequencedLeafCountResponse")
	proto.RegisterType((*GetLatestSignedLogRootRequest)(nil), "trillian.GetLatestSignedLogRootRequest")
	proto.RegisterType((*GetLatestSignedLogRootResponse)(nil), "trillian.GetLatestSignedLogRootResponse")
	proto.RegisterType((*GetEntryAndProofRequest)(nil), "trillian.GetEntryAndProofRequest")
	proto.RegisterType((*GetEntryAndProofResponse)(nil), "trillian.GetEntryAndProofResponse")
	proto.RegisterType((*MapLeaf)(nil), "trillian.MapLeaf")
	proto.RegisterType((*IndexValue)(nil), "trillian.IndexValue")
	proto.RegisterType((*IndexValueInclusion)(nil), "trillian.IndexValueInclusion")
	proto.RegisterType((*GetMapLeavesRequest)(nil), "trillian.GetMapLeavesRequest")
	proto.RegisterType((*GetMapLeavesResponse)(nil), "trillian.GetMapLeavesResponse")
	proto.RegisterType((*SetMapLeavesRequest)(nil), "trillian.SetMapLeavesRequest")
	proto.RegisterType((*SetMapLeavesResponse)(nil), "trillian.SetMapLeavesResponse")
	proto.RegisterType((*GetSignedMapRootRequest)(nil), "trillian.GetSignedMapRootRequest")
	proto.RegisterType((*GetSignedMapRootResponse)(nil), "trillian.GetSignedMapRootResponse")
	proto.RegisterType((*ListTreesRequest)(nil), "trillian.ListTreesRequest")
	proto.RegisterType((*ListTreesResponse)(nil), "trillian.ListTreesResponse")
	proto.RegisterType((*GetTreeRequest)(nil), "trillian.GetTreeRequest")
	proto.RegisterType((*CreateTreeRequest)(nil), "trillian.CreateTreeRequest")
	proto.RegisterType((*UpdateTreeRequest)(nil), "trillian.UpdateTreeRequest")
	proto.RegisterType((*DeleteTreeRequest)(nil), "trillian.DeleteTreeRequest")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for TrillianLog service

type TrillianLogClient interface {
	// QueueLeaf adds a single leaf to the queue.
	QueueLeaf(ctx context.Context, in *QueueLeafRequest, opts ...grpc.CallOption) (*google_protobuf.Empty, error)
	// Corresponds to the LeafQueuer API
	QueueLeaves(ctx context.Context, in *QueueLeavesRequest, opts ...grpc.CallOption) (*QueueLeavesResponse, error)
	// No direct equivalent at the storage level
	GetInclusionProof(ctx context.Context, in *GetInclusionProofRequest, opts ...grpc.CallOption) (*GetInclusionProofResponse, error)
	GetInclusionProofByHash(ctx context.Context, in *GetInclusionProofByHashRequest, opts ...grpc.CallOption) (*GetInclusionProofByHashResponse, error)
	GetConsistencyProof(ctx context.Context, in *GetConsistencyProofRequest, opts ...grpc.CallOption) (*GetConsistencyProofResponse, error)
	// Corresponds to the LogRootReader API
	GetLatestSignedLogRoot(ctx context.Context, in *GetLatestSignedLogRootRequest, opts ...grpc.CallOption) (*GetLatestSignedLogRootResponse, error)
	// Corresponds to the LeafReader API
	GetSequencedLeafCount(ctx context.Context, in *GetSequencedLeafCountRequest, opts ...grpc.CallOption) (*GetSequencedLeafCountResponse, error)
	GetLeavesByIndex(ctx context.Context, in *GetLeavesByIndexRequest, opts ...grpc.CallOption) (*GetLeavesByIndexResponse, error)
	GetLeavesByHash(ctx context.Context, in *GetLeavesByHashRequest, opts ...grpc.CallOption) (*GetLeavesByHashResponse, error)
	GetEntryAndProof(ctx context.Context, in *GetEntryAndProofRequest, opts ...grpc.CallOption) (*GetEntryAndProofResponse, error)
}

type trillianLogClient struct {
	cc *grpc.ClientConn
}

func NewTrillianLogClient(cc *grpc.ClientConn) TrillianLogClient {
	return &trillianLogClient{cc}
}

func (c *trillianLogClient) QueueLeaf(ctx context.Context, in *QueueLeafRequest, opts ...grpc.CallOption) (*google_protobuf.Empty, error) {
	out := new(google_protobuf.Empty)
	err := grpc.Invoke(ctx, "/trillian.TrillianLog/QueueLeaf", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *trillianLogClient) QueueLeaves(ctx context.Context, in *QueueLeavesRequest, opts ...grpc.CallOption) (*QueueLeavesResponse, error) {
	out := new(QueueLeavesResponse)
	err := grpc.Invoke(ctx, "/trillian.TrillianLog/QueueLeaves", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *trillianLogClient) GetInclusionProof(ctx context.Context, in *GetInclusionProofRequest, opts ...grpc.CallOption) (*GetInclusionProofResponse, error) {
	out := new(GetInclusionProofResponse)
	err := grpc.Invoke(ctx, "/trillian.TrillianLog/GetInclusionProof", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *trillianLogClient) GetInclusionProofByHash(ctx context.Context, in *GetInclusionProofByHashRequest, opts ...grpc.CallOption) (*GetInclusionProofByHashResponse, error) {
	out := new(GetInclusionProofByHashResponse)
	err := grpc.Invoke(ctx, "/trillian.TrillianLog/GetInclusionProofByHash", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *trillianLogClient) GetConsistencyProof(ctx context.Context, in *GetConsistencyProofRequest, opts ...grpc.CallOption) (*GetConsistencyProofResponse, error) {
	out := new(GetConsistencyProofResponse)
	err := grpc.Invoke(ctx, "/trillian.TrillianLog/GetConsistencyProof", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *trillianLogClient) GetLatestSignedLogRoot(ctx context.Context, in *GetLatestSignedLogRootRequest, opts ...grpc.CallOption) (*GetLatestSignedLogRootResponse, error) {
	out := new(GetLatestSignedLogRootResponse)
	err := grpc.Invoke(ctx, "/trillian.TrillianLog/GetLatestSignedLogRoot", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *trillianLogClient) GetSequencedLeafCount(ctx context.Context, in *GetSequencedLeafCountRequest, opts ...grpc.CallOption) (*GetSequencedLeafCountResponse, error) {
	out := new(GetSequencedLeafCountResponse)
	err := grpc.Invoke(ctx, "/trillian.TrillianLog/GetSequencedLeafCount", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *trillianLogClient) GetLeavesByIndex(ctx context.Context, in *GetLeavesByIndexRequest, opts ...grpc.CallOption) (*GetLeavesByIndexResponse, error) {
	out := new(GetLeavesByIndexResponse)
	err := grpc.Invoke(ctx, "/trillian.TrillianLog/GetLeavesByIndex", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *trillianLogClient) GetLeavesByHash(ctx context.Context, in *GetLeavesByHashRequest, opts ...grpc.CallOption) (*GetLeavesByHashResponse, error) {
	out := new(GetLeavesByHashResponse)
	err := grpc.Invoke(ctx, "/trillian.TrillianLog/GetLeavesByHash", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *trillianLogClient) GetEntryAndProof(ctx context.Context, in *GetEntryAndProofRequest, opts ...grpc.CallOption) (*GetEntryAndProofResponse, error) {
	out := new(GetEntryAndProofResponse)
	err := grpc.Invoke(ctx, "/trillian.TrillianLog/GetEntryAndProof", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for TrillianLog service

type TrillianLogServer interface {
	// QueueLeaf adds a single leaf to the queue.
	QueueLeaf(context.Context, *QueueLeafRequest) (*google_protobuf.Empty, error)
	// Corresponds to the LeafQueuer API
	QueueLeaves(context.Context, *QueueLeavesRequest) (*QueueLeavesResponse, error)
	// No direct equivalent at the storage level
	GetInclusionProof(context.Context, *GetInclusionProofRequest) (*GetInclusionProofResponse, error)
	GetInclusionProofByHash(context.Context, *GetInclusionProofByHashRequest) (*GetInclusionProofByHashResponse, error)
	GetConsistencyProof(context.Context, *GetConsistencyProofRequest) (*GetConsistencyProofResponse, error)
	// Corresponds to the LogRootReader API
	GetLatestSignedLogRoot(context.Context, *GetLatestSignedLogRootRequest) (*GetLatestSignedLogRootResponse, error)
	// Corresponds to the LeafReader API
	GetSequencedLeafCount(context.Context, *GetSequencedLeafCountRequest) (*GetSequencedLeafCountResponse, error)
	GetLeavesByIndex(context.Context, *GetLeavesByIndexRequest) (*GetLeavesByIndexResponse, error)
	GetLeavesByHash(context.Context, *GetLeavesByHashRequest) (*GetLeavesByHashResponse, error)
	GetEntryAndProof(context.Context, *GetEntryAndProofRequest) (*GetEntryAndProofResponse, error)
}

func RegisterTrillianLogServer(s *grpc.Server, srv TrillianLogServer) {
	s.RegisterService(&_TrillianLog_serviceDesc, srv)
}

func _TrillianLog_QueueLeaf_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueueLeafRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TrillianLogServer).QueueLeaf(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/trillian.TrillianLog/QueueLeaf",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TrillianLogServer).QueueLeaf(ctx, req.(*QueueLeafRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TrillianLog_QueueLeaves_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueueLeavesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TrillianLogServer).QueueLeaves(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/trillian.TrillianLog/QueueLeaves",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TrillianLogServer).QueueLeaves(ctx, req.(*QueueLeavesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TrillianLog_GetInclusionProof_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetInclusionProofRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TrillianLogServer).GetInclusionProof(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/trillian.TrillianLog/GetInclusionProof",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TrillianLogServer).GetInclusionProof(ctx, req.(*GetInclusionProofRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TrillianLog_GetInclusionProofByHash_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetInclusionProofByHashRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TrillianLogServer).GetInclusionProofByHash(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/trillian.TrillianLog/GetInclusionProofByHash",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TrillianLogServer).GetInclusionProofByHash(ctx, req.(*GetInclusionProofByHashRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TrillianLog_GetConsistencyProof_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetConsistencyProofRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TrillianLogServer).GetConsistencyProof(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/trillian.TrillianLog/GetConsistencyProof",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TrillianLogServer).GetConsistencyProof(ctx, req.(*GetConsistencyProofRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TrillianLog_GetLatestSignedLogRoot_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetLatestSignedLogRootRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TrillianLogServer).GetLatestSignedLogRoot(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/trillian.TrillianLog/GetLatestSignedLogRoot",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TrillianLogServer).GetLatestSignedLogRoot(ctx, req.(*GetLatestSignedLogRootRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TrillianLog_GetSequencedLeafCount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSequencedLeafCountRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TrillianLogServer).GetSequencedLeafCount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/trillian.TrillianLog/GetSequencedLeafCount",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TrillianLogServer).GetSequencedLeafCount(ctx, req.(*GetSequencedLeafCountRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TrillianLog_GetLeavesByIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetLeavesByIndexRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TrillianLogServer).GetLeavesByIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/trillian.TrillianLog/GetLeavesByIndex",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TrillianLogServer).GetLeavesByIndex(ctx, req.(*GetLeavesByIndexRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TrillianLog_GetLeavesByHash_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetLeavesByHashRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TrillianLogServer).GetLeavesByHash(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/trillian.TrillianLog/GetLeavesByHash",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TrillianLogServer).GetLeavesByHash(ctx, req.(*GetLeavesByHashRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TrillianLog_GetEntryAndProof_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetEntryAndProofRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TrillianLogServer).GetEntryAndProof(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/trillian.TrillianLog/GetEntryAndProof",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TrillianLogServer).GetEntryAndProof(ctx, req.(*GetEntryAndProofRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _TrillianLog_serviceDesc = grpc.ServiceDesc{
	ServiceName: "trillian.TrillianLog",
	HandlerType: (*TrillianLogServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "QueueLeaf",
			Handler:    _TrillianLog_QueueLeaf_Handler,
		},
		{
			MethodName: "QueueLeaves",
			Handler:    _TrillianLog_QueueLeaves_Handler,
		},
		{
			MethodName: "GetInclusionProof",
			Handler:    _TrillianLog_GetInclusionProof_Handler,
		},
		{
			MethodName: "GetInclusionProofByHash",
			Handler:    _TrillianLog_GetInclusionProofByHash_Handler,
		},
		{
			MethodName: "GetConsistencyProof",
			Handler:    _TrillianLog_GetConsistencyProof_Handler,
		},
		{
			MethodName: "GetLatestSignedLogRoot",
			Handler:    _TrillianLog_GetLatestSignedLogRoot_Handler,
		},
		{
			MethodName: "GetSequencedLeafCount",
			Handler:    _TrillianLog_GetSequencedLeafCount_Handler,
		},
		{
			MethodName: "GetLeavesByIndex",
			Handler:    _TrillianLog_GetLeavesByIndex_Handler,
		},
		{
			MethodName: "GetLeavesByHash",
			Handler:    _TrillianLog_GetLeavesByHash_Handler,
		},
		{
			MethodName: "GetEntryAndProof",
			Handler:    _TrillianLog_GetEntryAndProof_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "trillian_api.proto",
}

// Client API for TrillianMap service

type TrillianMapClient interface {
	GetLeaves(ctx context.Context, in *GetMapLeavesRequest, opts ...grpc.CallOption) (*GetMapLeavesResponse, error)
	SetLeaves(ctx context.Context, in *SetMapLeavesRequest, opts ...grpc.CallOption) (*SetMapLeavesResponse, error)
	GetSignedMapRoot(ctx context.Context, in *GetSignedMapRootRequest, opts ...grpc.CallOption) (*GetSignedMapRootResponse, error)
}

type trillianMapClient struct {
	cc *grpc.ClientConn
}

func NewTrillianMapClient(cc *grpc.ClientConn) TrillianMapClient {
	return &trillianMapClient{cc}
}

func (c *trillianMapClient) GetLeaves(ctx context.Context, in *GetMapLeavesRequest, opts ...grpc.CallOption) (*GetMapLeavesResponse, error) {
	out := new(GetMapLeavesResponse)
	err := grpc.Invoke(ctx, "/trillian.TrillianMap/GetLeaves", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *trillianMapClient) SetLeaves(ctx context.Context, in *SetMapLeavesRequest, opts ...grpc.CallOption) (*SetMapLeavesResponse, error) {
	out := new(SetMapLeavesResponse)
	err := grpc.Invoke(ctx, "/trillian.TrillianMap/SetLeaves", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *trillianMapClient) GetSignedMapRoot(ctx context.Context, in *GetSignedMapRootRequest, opts ...grpc.CallOption) (*GetSignedMapRootResponse, error) {
	out := new(GetSignedMapRootResponse)
	err := grpc.Invoke(ctx, "/trillian.TrillianMap/GetSignedMapRoot", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for TrillianMap service

type TrillianMapServer interface {
	GetLeaves(context.Context, *GetMapLeavesRequest) (*GetMapLeavesResponse, error)
	SetLeaves(context.Context, *SetMapLeavesRequest) (*SetMapLeavesResponse, error)
	GetSignedMapRoot(context.Context, *GetSignedMapRootRequest) (*GetSignedMapRootResponse, error)
}

func RegisterTrillianMapServer(s *grpc.Server, srv TrillianMapServer) {
	s.RegisterService(&_TrillianMap_serviceDesc, srv)
}

func _TrillianMap_GetLeaves_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMapLeavesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TrillianMapServer).GetLeaves(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/trillian.TrillianMap/GetLeaves",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TrillianMapServer).GetLeaves(ctx, req.(*GetMapLeavesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TrillianMap_SetLeaves_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetMapLeavesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TrillianMapServer).SetLeaves(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/trillian.TrillianMap/SetLeaves",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TrillianMapServer).SetLeaves(ctx, req.(*SetMapLeavesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TrillianMap_GetSignedMapRoot_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSignedMapRootRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TrillianMapServer).GetSignedMapRoot(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/trillian.TrillianMap/GetSignedMapRoot",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TrillianMapServer).GetSignedMapRoot(ctx, req.(*GetSignedMapRootRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _TrillianMap_serviceDesc = grpc.ServiceDesc{
	ServiceName: "trillian.TrillianMap",
	HandlerType: (*TrillianMapServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetLeaves",
			Handler:    _TrillianMap_GetLeaves_Handler,
		},
		{
			MethodName: "SetLeaves",
			Handler:    _TrillianMap_SetLeaves_Handler,
		},
		{
			MethodName: "GetSignedMapRoot",
			Handler:    _TrillianMap_GetSignedMapRoot_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "trillian_api.proto",
}

// Client API for TrillianAdmin service

type TrillianAdminClient interface {
	// Lists all trees the requester has access to.
	ListTrees(ctx context.Context, in *ListTreesRequest, opts ...grpc.CallOption) (*ListTreesResponse, error)
	// Retrieves a tree by ID.
	GetTree(ctx context.Context, in *GetTreeRequest, opts ...grpc.CallOption) (*Tree, error)
	// Creates a new tree.
	// System-generated fields are not required and will be ignored if present,
	// e.g.: tree_id, create_time and update_time.
	// Returns the created tree, with all system-generated fields assigned.
	CreateTree(ctx context.Context, in *CreateTreeRequest, opts ...grpc.CallOption) (*Tree, error)
	// Updates a tree.
	// See Tree for details. Readonly fields cannot be updated.
	UpdateTree(ctx context.Context, in *UpdateTreeRequest, opts ...grpc.CallOption) (*Tree, error)
	// Soft-deletes a tree.
	// A soft-deleted tree may be undeleted for a certain period, after which
	// it'll be permanently deleted.
	// TODO(codingllama): Provide an undelete RPC.
	DeleteTree(ctx context.Context, in *DeleteTreeRequest, opts ...grpc.CallOption) (*google_protobuf.Empty, error)
}

type trillianAdminClient struct {
	cc *grpc.ClientConn
}

func NewTrillianAdminClient(cc *grpc.ClientConn) TrillianAdminClient {
	return &trillianAdminClient{cc}
}

func (c *trillianAdminClient) ListTrees(ctx context.Context, in *ListTreesRequest, opts ...grpc.CallOption) (*ListTreesResponse, error) {
	out := new(ListTreesResponse)
	err := grpc.Invoke(ctx, "/trillian.TrillianAdmin/ListTrees", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *trillianAdminClient) GetTree(ctx context.Context, in *GetTreeRequest, opts ...grpc.CallOption) (*Tree, error) {
	out := new(Tree)
	err := grpc.Invoke(ctx, "/trillian.TrillianAdmin/GetTree", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *trillianAdminClient) CreateTree(ctx context.Context, in *CreateTreeRequest, opts ...grpc.CallOption) (*Tree, error) {
	out := new(Tree)
	err := grpc.Invoke(ctx, "/trillian.TrillianAdmin/CreateTree", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *trillianAdminClient) UpdateTree(ctx context.Context, in *UpdateTreeRequest, opts ...grpc.CallOption) (*Tree, error) {
	out := new(Tree)
	err := grpc.Invoke(ctx, "/trillian.TrillianAdmin/UpdateTree", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *trillianAdminClient) DeleteTree(ctx context.Context, in *DeleteTreeRequest, opts ...grpc.CallOption) (*google_protobuf.Empty, error) {
	out := new(google_protobuf.Empty)
	err := grpc.Invoke(ctx, "/trillian.TrillianAdmin/DeleteTree", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for TrillianAdmin service

type TrillianAdminServer interface {
	// Lists all trees the requester has access to.
	ListTrees(context.Context, *ListTreesRequest) (*ListTreesResponse, error)
	// Retrieves a tree by ID.
	GetTree(context.Context, *GetTreeRequest) (*Tree, error)
	// Creates a new tree.
	// System-generated fields are not required and will be ignored if present,
	// e.g.: tree_id, create_time and update_time.
	// Returns the created tree, with all system-generated fields assigned.
	CreateTree(context.Context, *CreateTreeRequest) (*Tree, error)
	// Updates a tree.
	// See Tree for details. Readonly fields cannot be updated.
	UpdateTree(context.Context, *UpdateTreeRequest) (*Tree, error)
	// Soft-deletes a tree.
	// A soft-deleted tree may be undeleted for a certain period, after which
	// it'll be permanently deleted.
	// TODO(codingllama): Provide an undelete RPC.
	DeleteTree(context.Context, *DeleteTreeRequest) (*google_protobuf.Empty, error)
}

func RegisterTrillianAdminServer(s *grpc.Server, srv TrillianAdminServer) {
	s.RegisterService(&_TrillianAdmin_serviceDesc, srv)
}

func _TrillianAdmin_ListTrees_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListTreesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TrillianAdminServer).ListTrees(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/trillian.TrillianAdmin/ListTrees",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TrillianAdminServer).ListTrees(ctx, req.(*ListTreesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TrillianAdmin_GetTree_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTreeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TrillianAdminServer).GetTree(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/trillian.TrillianAdmin/GetTree",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TrillianAdminServer).GetTree(ctx, req.(*GetTreeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TrillianAdmin_CreateTree_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateTreeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TrillianAdminServer).CreateTree(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/trillian.TrillianAdmin/CreateTree",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TrillianAdminServer).CreateTree(ctx, req.(*CreateTreeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TrillianAdmin_UpdateTree_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateTreeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TrillianAdminServer).UpdateTree(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/trillian.TrillianAdmin/UpdateTree",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TrillianAdminServer).UpdateTree(ctx, req.(*UpdateTreeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TrillianAdmin_DeleteTree_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteTreeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TrillianAdminServer).DeleteTree(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/trillian.TrillianAdmin/DeleteTree",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TrillianAdminServer).DeleteTree(ctx, req.(*DeleteTreeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _TrillianAdmin_serviceDesc = grpc.ServiceDesc{
	ServiceName: "trillian.TrillianAdmin",
	HandlerType: (*TrillianAdminServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListTrees",
			Handler:    _TrillianAdmin_ListTrees_Handler,
		},
		{
			MethodName: "GetTree",
			Handler:    _TrillianAdmin_GetTree_Handler,
		},
		{
			MethodName: "CreateTree",
			Handler:    _TrillianAdmin_CreateTree_Handler,
		},
		{
			MethodName: "UpdateTree",
			Handler:    _TrillianAdmin_UpdateTree_Handler,
		},
		{
			MethodName: "DeleteTree",
			Handler:    _TrillianAdmin_DeleteTree_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "trillian_api.proto",
}

func init() { proto.RegisterFile("trillian_api.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 1426 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xb4, 0x58, 0x5f, 0x6f, 0x13, 0x47,
	0x10, 0x8f, 0xe3, 0x24, 0x8e, 0xc7, 0x24, 0x71, 0x36, 0x09, 0x31, 0x17, 0x42, 0xc3, 0x52, 0xc0,
	0x54, 0x34, 0x54, 0xae, 0x68, 0x55, 0x21, 0xb5, 0x22, 0x09, 0x84, 0xb4, 0x0e, 0x0d, 0x67, 0x40,
	0x95, 0x2a, 0x71, 0x5a, 0x72, 0x6b, 0xe7, 0xe0, 0x7c, 0x77, 0xbd, 0x5b, 0x23, 0x92, 0xf7, 0xf6,
	0x5b, 0xb4, 0x1f, 0xa5, 0x6f, 0x7d, 0xec, 0x77, 0xaa, 0xf6, 0xcf, 0xfd, 0xf5, 0xda, 0x8e, 0x5b,
	0xf5, 0xcd, 0x3b, 0x7f, 0x7f, 0x33, 0xb3, 0xb3, 0x33, 0x67, 0x40, 0x2c, 0x74, 0x5c, 0xd7, 0x21,
	0x9e, 0x45, 0x02, 0x67, 0x37, 0x08, 0x7d, 0xe6, 0xa3, 0xc5, 0x98, 0x66, 0x2c, 0xc7, 0xbf, 0x24,
	0xc7, 0xd8, 0xea, 0xf9, 0x7e, 0xcf, 0xa5, 0x0f, 0xc4, 0xe9, 0xed, 0xa0, 0xfb, 0x80, 0xf6, 0x03,
	0x76, 0xae, 0x98, 0x3b, 0x45, 0x66, 0xd7, 0xa1, 0xae, 0x6d, 0xf5, 0x49, 0xf4, 0x5e, 0x4a, 0xe0,
	0x3f, 0x4b, 0x50, 0x69, 0xfb, 0xbd, 0x36, 0x25, 0x5d, 0xd4, 0x84, 0x7a, 0x9f, 0x86, 0xef, 0x5d,
	0x6a, 0xb9, 0x94, 0x74, 0xad, 0x33, 0x12, 0x9d, 0x35, 0x4a, 0x3b, 0xa5, 0xe6, 0x15, 0x73, 0x59,
	0xd2, 0xb9, 0xd4, 0x33, 0x12, 0x9d, 0xa1, 0x6d, 0x00, 0x21, 0xf2, 0x81, 0xb8, 0x03, 0xda, 0x98,
	0x15, 0x32, 0x55, 0x4e, 0x79, 0xcd, 0x09, 0x9c, 0x4d, 0x3f, 0xb2, 0x90, 0x58, 0x36, 0x61, 0xa4,
	0x51, 0x96, 0x6c, 0x41, 0x39, 0x20, 0x8c, 0x24, 0xda, 0x8e, 0x67, 0xd3, 0x8f, 0x8d, 0xb9, 0x9d,
	0x52, 0xb3, 0x2c, 0xb5, 0x8f, 0x38, 0x01, 0xdd, 0x07, 0x24, 0xd9, 0x36, 0xf5, 0x98, 0xc3, 0xce,
	0x25, 0x90, 0x79, 0x61, 0xa5, 0x2e, 0xc4, 0x14, 0x83, 0x43, 0xc1, 0x04, 0xe6, 0x9e, 0xfb, 0x36,
	0x45, 0x9b, 0x50, 0xf1, 0x7c, 0x9b, 0x5a, 0x8e, 0xad, 0x30, 0x2f, 0xf0, 0xe3, 0x91, 0x8d, 0xb6,
	0xa0, 0x2a, 0x18, 0xc2, 0x8a, 0x84, 0xba, 0xc8, 0x09, 0x22, 0x90, 0x5b, 0xb0, 0x24, 0x98, 0x21,
	0xfd, 0xe0, 0x44, 0x8e, 0xef, 0x09, 0xb0, 0x65, 0xf3, 0x0a, 0x27, 0x9a, 0x8a, 0x86, 0x5f, 0xc1,
	0xfc, 0x49, 0xe8, 0xfb, 0xdd, 0x02, 0xf0, 0x52, 0x11, 0xf8, 0xe7, 0x00, 0x01, 0x97, 0xb3, 0xb8,
	0x76, 0x63, 0x76, 0xa7, 0xdc, 0xac, 0xb5, 0x96, 0x77, 0x93, 0x7a, 0x71, 0x98, 0x66, 0x55, 0x48,
	0xf0, 0x9f, 0xf8, 0x35, 0xa0, 0x17, 0x03, 0x3a, 0xe0, 0x59, 0xfd, 0x40, 0x23, 0x93, 0xfe, 0x32,
	0xa0, 0x11, 0x43, 0x1b, 0xb0, 0xe0, 0xfa, 0xbd, 0x38, 0x8c, 0xb2, 0x39, 0xef, 0xfa, 0xbd, 0x23,
	0x1b, 0xdd, 0x83, 0x05, 0x57, 0xc8, 0x29, 0xbb, 0xab, 0xa9, 0x5d, 0x55, 0x3e, 0x53, 0x09, 0xe0,
	0x13, 0xa8, 0xc7, 0x76, 0xbb, 0x13, 0xac, 0xde, 0x86, 0x39, 0x0e, 0x5f, 0xa4, 0x45, 0x6b, 0x53,
	0xb0, 0xf1, 0x06, 0xac, 0xe5, 0x90, 0x46, 0x81, 0xef, 0x45, 0x14, 0xf7, 0xa1, 0x71, 0x48, 0xd9,
	0x91, 0x77, 0xea, 0x0e, 0x78, 0x9e, 0x44, 0x8e, 0x26, 0x38, 0xcc, 0x67, 0x70, 0xb6, 0x98, 0xc1,
	0x2d, 0xa8, 0xb2, 0x90, 0x52, 0x2b, 0x72, 0x2e, 0xa8, 0x2a, 0xc5, 0x22, 0x27, 0x74, 0x9c, 0x0b,
	0x8a, 0xf7, 0xe0, 0x9a, 0xc6, 0x9d, 0xc4, 0x82, 0x6e, 0xc3, 0xbc, 0xc8, 0xac, 0x0a, 0x65, 0x25,
	0x0d, 0x45, 0xca, 0x49, 0x2e, 0xfe, 0xbd, 0x04, 0x37, 0x86, 0x8c, 0xec, 0x89, 0x9b, 0x34, 0x01,
	0xf9, 0x16, 0x54, 0xd3, 0xae, 0x50, 0xd7, 0xc8, 0x8d, 0xfb, 0x61, 0x1c, 0x6e, 0xf4, 0x19, 0xac,
	0xfa, 0xa1, 0x4d, 0x43, 0xeb, 0xed, 0xb9, 0x15, 0x71, 0x27, 0xde, 0x29, 0x15, 0xb7, 0x7e, 0xd1,
	0x5c, 0x11, 0x8c, 0xbd, 0xf3, 0x8e, 0x22, 0xe3, 0x67, 0xf0, 0xc9, 0x48, 0x78, 0xc3, 0x91, 0x96,
	0xc7, 0x44, 0xfa, 0x6b, 0x09, 0x8c, 0x43, 0xca, 0xf6, 0x7d, 0x2f, 0x72, 0x22, 0x46, 0xbd, 0xd3,
	0xf3, 0xcb, 0xd4, 0xe7, 0x0e, 0xac, 0x74, 0x9d, 0x30, 0x62, 0x56, 0x1a, 0x8e, 0x2c, 0xd2, 0x92,
	0x20, 0xbf, 0x8c, 0x63, 0x6a, 0x42, 0x3d, 0xa2, 0xa7, 0xbe, 0x67, 0x5b, 0xc5, 0xb8, 0x97, 0x25,
	0x3d, 0x96, 0xc4, 0x07, 0xb0, 0xa5, 0x85, 0x31, 0x5d, 0xdd, 0x3e, 0xc2, 0xd5, 0x43, 0xca, 0xe4,
	0xfd, 0xfb, 0x37, 0xe5, 0x2a, 0xe7, 0xca, 0xa5, 0xad, 0x48, 0x59, 0x5f, 0x91, 0x03, 0xd8, 0x1c,
	0xf2, 0xac, 0xb0, 0x4f, 0xd1, 0x93, 0x3f, 0xe6, 0xac, 0x88, 0xcb, 0x3e, 0x65, 0xa7, 0x94, 0x73,
	0x9d, 0x82, 0x9f, 0x88, 0xde, 0x2b, 0x18, 0x9c, 0x1e, 0xd7, 0x43, 0xb8, 0x7e, 0x48, 0x59, 0x1c,
	0xac, 0xcd, 0x79, 0xfb, 0xfe, 0xc0, 0x63, 0xe3, 0xc1, 0xe1, 0x6f, 0x61, 0x7b, 0x84, 0x9a, 0x82,
	0x10, 0xa3, 0x3f, 0xe5, 0xd4, 0x6c, 0x9f, 0x0b, 0x31, 0xfc, 0x95, 0xd0, 0x6f, 0x13, 0x46, 0x23,
	0xd6, 0x71, 0x7a, 0x1e, 0xb5, 0xdb, 0x7e, 0xcf, 0xf4, 0xfd, 0x49, 0x7e, 0x89, 0xe8, 0x5e, 0xad,
	0x9e, 0x72, 0xfc, 0x1d, 0xac, 0x44, 0x82, 0x61, 0x71, 0xfd, 0xd0, 0xf7, 0x99, 0xba, 0x59, 0x9b,
	0x69, 0x12, 0xf2, 0x9a, 0x4b, 0x51, 0xf6, 0x88, 0x5d, 0x51, 0xa9, 0x27, 0x1e, 0x0b, 0xcf, 0x1f,
	0x7b, 0xf6, 0xff, 0xfd, 0xa6, 0x9d, 0x89, 0x32, 0x16, 0xbc, 0x4d, 0xd5, 0x1a, 0xc9, 0x1b, 0x5e,
	0x1e, 0xff, 0x86, 0x5f, 0x40, 0xe5, 0x98, 0x04, 0x62, 0xce, 0xaf, 0xc3, 0x7c, 0x3a, 0xc1, 0xae,
	0x98, 0xf2, 0x30, 0xfe, 0x81, 0xcb, 0x0f, 0xfc, 0xf2, 0xf8, 0x81, 0x3f, 0x57, 0x18, 0xf8, 0xf8,
	0x07, 0x00, 0x91, 0x0b, 0x29, 0xac, 0x77, 0x7f, 0x17, 0xe6, 0xd3, 0x6d, 0x22, 0x17, 0x87, 0x82,
	0x6d, 0x4a, 0x3e, 0x7e, 0x07, 0x6b, 0xa9, 0xb1, 0xe4, 0xa5, 0x44, 0x0f, 0xa1, 0x26, 0x0c, 0x29,
	0x88, 0x25, 0x61, 0x65, 0x3d, 0xb5, 0x92, 0xea, 0x98, 0xe0, 0xa4, 0x60, 0xae, 0x43, 0xd5, 0x89,
	0x6d, 0xa8, 0x77, 0x22, 0x25, 0xe0, 0x37, 0xb0, 0x76, 0x48, 0x99, 0x04, 0x90, 0x9f, 0xd1, 0x7d,
	0x12, 0x64, 0x2e, 0x42, 0x9f, 0x04, 0x47, 0x76, 0x1a, 0x98, 0xb4, 0xa3, 0x02, 0x33, 0x60, 0xb1,
	0xb0, 0x5d, 0x24, 0x67, 0x3e, 0x8e, 0xd6, 0xf3, 0x0e, 0x54, 0xed, 0x5f, 0xc0, 0x46, 0x26, 0x1a,
	0x2b, 0x0f, 0xb1, 0xd6, 0xda, 0xd6, 0xc5, 0x95, 0xe4, 0xc2, 0x5c, 0x73, 0x34, 0x09, 0x6a, 0xc1,
	0x22, 0x07, 0x2d, 0x5a, 0xa2, 0xac, 0x6f, 0x89, 0x63, 0x12, 0x88, 0x96, 0xa8, 0xf4, 0xe5, 0x0f,
	0xfc, 0x47, 0x09, 0xd6, 0x3a, 0x97, 0x4f, 0x40, 0xa1, 0x06, 0x12, 0xeb, 0xe4, 0x1a, 0x7c, 0x03,
	0xb5, 0x3e, 0x09, 0x02, 0x1a, 0xa6, 0xfb, 0x62, 0xad, 0xd5, 0xc8, 0x5d, 0x80, 0x80, 0x86, 0xc7,
	0x94, 0x11, 0xce, 0x37, 0x41, 0x0a, 0x8b, 0x9b, 0xf5, 0x3d, 0xac, 0x77, 0x74, 0xf9, 0xcb, 0x06,
	0x3b, 0x7b, 0xc9, 0x60, 0xbf, 0x10, 0x9d, 0x9f, 0x67, 0x8e, 0x8d, 0x17, 0x3f, 0x17, 0xdd, 0x5b,
	0xd0, 0xf8, 0x0f, 0x08, 0x10, 0xd4, 0xdb, 0x8e, 0x9c, 0xb2, 0x71, 0xaa, 0xf1, 0xd7, 0xb0, 0x9a,
	0xa1, 0x29, 0xe3, 0x18, 0xe6, 0xf8, 0x13, 0xd2, 0x28, 0x15, 0x77, 0x4c, 0x2e, 0x66, 0x0a, 0x1e,
	0xbe, 0x07, 0xcb, 0x87, 0x54, 0xe8, 0xc5, 0x51, 0x6c, 0x42, 0x45, 0xbc, 0x44, 0x49, 0x18, 0x0b,
	0xfc, 0x78, 0x64, 0x73, 0x1f, 0xfb, 0x21, 0x25, 0x8c, 0x66, 0xa5, 0x53, 0x1f, 0xa5, 0x91, 0x3e,
	0x18, 0xac, 0xbe, 0x0a, 0xec, 0xe9, 0x15, 0xd1, 0x23, 0xa8, 0x0d, 0x84, 0xa2, 0xf8, 0x16, 0x51,
	0x09, 0x32, 0x76, 0xe5, 0xe7, 0xca, 0x6e, 0xfc, 0xb9, 0xb2, 0xfb, 0x94, 0x7f, 0xae, 0x1c, 0x93,
	0xe8, 0xbd, 0x09, 0x52, 0x9c, 0xff, 0xc6, 0xf7, 0x61, 0xf5, 0x80, 0xba, 0x34, 0xef, 0x75, 0x54,
	0x70, 0xad, 0xbf, 0x2a, 0x50, 0x7b, 0xa9, 0x20, 0xb4, 0xfd, 0x1e, 0x7a, 0x0c, 0xd5, 0x64, 0x3d,
	0x46, 0x46, 0x8a, 0xae, 0xb8, 0x33, 0x1b, 0x57, 0x87, 0xe0, 0x3c, 0xe1, 0x9f, 0x56, 0x78, 0x06,
	0xb5, 0xa1, 0x96, 0xd9, 0x87, 0xd1, 0xf5, 0x61, 0x23, 0x69, 0xaf, 0x18, 0xdb, 0x23, 0xb8, 0x6a,
	0x89, 0x9e, 0x41, 0x6f, 0x60, 0x75, 0x68, 0xe7, 0x43, 0x38, 0xd5, 0x1a, 0xb5, 0x63, 0x1b, 0xb7,
	0xc6, 0xca, 0x24, 0xf6, 0x03, 0x71, 0xaf, 0x75, 0x3b, 0x25, 0x6a, 0x8e, 0xb1, 0x90, 0x5b, 0xb3,
	0x8c, 0x7b, 0x97, 0x90, 0x4c, 0x3c, 0xda, 0xe2, 0xd9, 0x2c, 0xee, 0x7c, 0xe8, 0xd3, 0x9c, 0x8d,
	0x11, 0x9b, 0xa9, 0x71, 0x7b, 0x82, 0x54, 0xe2, 0xa5, 0x2f, 0x77, 0xc2, 0xe1, 0x65, 0x00, 0xdd,
	0xcd, 0x99, 0x18, 0xbd, 0x66, 0x18, 0xcd, 0xc9, 0x82, 0x89, 0xbb, 0x77, 0xb0, 0xa1, 0xdd, 0x79,
	0xd0, 0x9d, 0x9c, 0x91, 0x91, 0xbb, 0x94, 0x71, 0x77, 0xa2, 0x5c, 0xe2, 0xeb, 0x67, 0xa8, 0x17,
	0xb7, 0x3b, 0x74, 0x33, 0x8f, 0x55, 0xb3, 0x4a, 0x1a, 0x78, 0x9c, 0x48, 0x62, 0xfc, 0x27, 0x58,
	0x29, 0x6c, 0xb4, 0x68, 0x47, 0xab, 0x98, 0xad, 0xff, 0xcd, 0x31, 0x12, 0x05, 0xd8, 0xb9, 0x6d,
	0xa6, 0x00, 0x5b, 0xb7, 0x57, 0x15, 0x60, 0x6b, 0x97, 0x21, 0x3c, 0xd3, 0xfa, 0x6d, 0x36, 0xed,
	0xe3, 0x63, 0x12, 0xa0, 0x36, 0x54, 0x13, 0x24, 0x68, 0x3b, 0x67, 0xa2, 0x38, 0xaf, 0x8c, 0x1b,
	0xa3, 0xd8, 0x09, 0xf4, 0x36, 0x54, 0x3b, 0x3a, 0x6b, 0x9d, 0xf1, 0xd6, 0x3a, 0x7a, 0x6b, 0x32,
	0x11, 0xb9, 0x57, 0xbe, 0x90, 0x08, 0xdd, 0x98, 0x29, 0x24, 0x42, 0x3b, 0x57, 0xf0, 0x4c, 0xeb,
	0xef, 0x59, 0x58, 0x8a, 0x13, 0xf1, 0xd8, 0xee, 0x3b, 0x1e, 0x7a, 0x0a, 0xd5, 0x64, 0x46, 0x64,
	0x9f, 0xb4, 0xe2, 0x30, 0x31, 0xb6, 0xb4, 0xbc, 0x04, 0xf6, 0x43, 0xa8, 0xa8, 0x91, 0x81, 0x1a,
	0x39, 0x28, 0x99, 0x87, 0xd6, 0x28, 0x3c, 0xe8, 0x78, 0x06, 0x3d, 0x02, 0x48, 0xc7, 0x07, 0xca,
	0xf8, 0x18, 0x1a, 0x2a, 0x7a, 0xe5, 0x74, 0x84, 0x64, 0x95, 0x87, 0x06, 0x8b, 0x46, 0x79, 0x1f,
	0x20, 0x9d, 0x04, 0x59, 0xe5, 0xa1, 0xf9, 0x30, 0xfa, 0x35, 0xdf, 0x7b, 0x00, 0xd7, 0x4e, 0xfd,
	0x7e, 0xcc, 0xce, 0xff, 0xbd, 0xb6, 0x57, 0x4f, 0x32, 0x1d, 0x38, 0x27, 0x9c, 0x72, 0x52, 0x7a,
	0xbb, 0x20, 0x58, 0x5f, 0xfe, 0x13, 0x00, 0x00, 0xff, 0xff, 0xf9, 0x98, 0x55, 0x0b, 0xa9, 0x13,
	0x00, 0x00,
}
