// Code generated by protoc-gen-go.
// source: signature.proto
// DO NOT EDIT!

/*
Package signature is a generated protocol buffer package.

It is generated from these files:
	signature.proto

It has these top-level messages:
	DigitallySigned
*/
package signature

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// HashAlgorithm defines the approved methods for object hashing.
//
// Supported hash algorithms. The numbering space is the same as for TLS,
// given in RFC 5246 s7.4.1.4.1 and at:
// http://www.iana.org/assignments/tls-parameters/tls-parameters.xhtml#tls-parameters-18
type DigitallySigned_HashAlgorithm int32

const (
	// No hash algorithm is used.
	DigitallySigned_NONE DigitallySigned_HashAlgorithm = 0
	// SHA256 is used.
	DigitallySigned_SHA256 DigitallySigned_HashAlgorithm = 4
)

var DigitallySigned_HashAlgorithm_name = map[int32]string{
	0: "NONE",
	4: "SHA256",
}
var DigitallySigned_HashAlgorithm_value = map[string]int32{
	"NONE":   0,
	"SHA256": 4,
}

func (x DigitallySigned_HashAlgorithm) String() string {
	return proto.EnumName(DigitallySigned_HashAlgorithm_name, int32(x))
}
func (DigitallySigned_HashAlgorithm) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{0, 0}
}

// SignatureAlgorithm defines the algorithm used to sign the object.
//
// Supported signature algorithms. The numbering space is the same as for TLS,
// given in RFC 5246 s7.4.1.4.1 and at:
// http://www.iana.org/assignments/tls-parameters/tls-parameters.xhtml#tls-parameters-16
type DigitallySigned_SignatureAlgorithm int32

const (
	// Anonymous signature scheme.
	DigitallySigned_ANONYMOUS DigitallySigned_SignatureAlgorithm = 0
	// RSA signature scheme.
	DigitallySigned_RSA DigitallySigned_SignatureAlgorithm = 1
	// ECDSA signature scheme.
	DigitallySigned_ECDSA DigitallySigned_SignatureAlgorithm = 3
)

var DigitallySigned_SignatureAlgorithm_name = map[int32]string{
	0: "ANONYMOUS",
	1: "RSA",
	3: "ECDSA",
}
var DigitallySigned_SignatureAlgorithm_value = map[string]int32{
	"ANONYMOUS": 0,
	"RSA":       1,
	"ECDSA":     3,
}

func (x DigitallySigned_SignatureAlgorithm) String() string {
	return proto.EnumName(DigitallySigned_SignatureAlgorithm_name, int32(x))
}
func (DigitallySigned_SignatureAlgorithm) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{0, 1}
}

// Protocol buffer encoding of the TLS DigitallySigned type, from RFC 5246 ยง4.7.
type DigitallySigned struct {
	// hash_algorithm contains the hash algorithm used.
	HashAlgorithm DigitallySigned_HashAlgorithm `protobuf:"varint,1,opt,name=hash_algorithm,json=hashAlgorithm,enum=signature.DigitallySigned_HashAlgorithm" json:"hash_algorithm,omitempty"`
	// sig_algorithm contains the signing algorithm used.
	SignatureAlgorithm DigitallySigned_SignatureAlgorithm `protobuf:"varint,2,opt,name=signature_algorithm,json=signatureAlgorithm,enum=signature.DigitallySigned_SignatureAlgorithm" json:"signature_algorithm,omitempty"`
	// signature contains the object signature.
	Signature []byte `protobuf:"bytes,3,opt,name=signature,proto3" json:"signature,omitempty"`
}

func (m *DigitallySigned) Reset()                    { *m = DigitallySigned{} }
func (m *DigitallySigned) String() string            { return proto.CompactTextString(m) }
func (*DigitallySigned) ProtoMessage()               {}
func (*DigitallySigned) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *DigitallySigned) GetHashAlgorithm() DigitallySigned_HashAlgorithm {
	if m != nil {
		return m.HashAlgorithm
	}
	return DigitallySigned_NONE
}

func (m *DigitallySigned) GetSignatureAlgorithm() DigitallySigned_SignatureAlgorithm {
	if m != nil {
		return m.SignatureAlgorithm
	}
	return DigitallySigned_ANONYMOUS
}

func (m *DigitallySigned) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

func init() {
	proto.RegisterType((*DigitallySigned)(nil), "signature.DigitallySigned")
	proto.RegisterEnum("signature.DigitallySigned_HashAlgorithm", DigitallySigned_HashAlgorithm_name, DigitallySigned_HashAlgorithm_value)
	proto.RegisterEnum("signature.DigitallySigned_SignatureAlgorithm", DigitallySigned_SignatureAlgorithm_name, DigitallySigned_SignatureAlgorithm_value)
}

func init() { proto.RegisterFile("signature.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 222 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xe2, 0xe2, 0x2f, 0xce, 0x4c, 0xcf,
	0x4b, 0x2c, 0x29, 0x2d, 0x4a, 0xd5, 0x2b, 0x28, 0xca, 0x2f, 0xc9, 0x17, 0xe2, 0x84, 0x0b, 0x28,
	0x1d, 0x60, 0xe2, 0xe2, 0x77, 0xc9, 0x4c, 0xcf, 0x2c, 0x49, 0xcc, 0xc9, 0xa9, 0x0c, 0xce, 0x4c,
	0xcf, 0x4b, 0x4d, 0x11, 0xf2, 0xe7, 0xe2, 0xcb, 0x48, 0x2c, 0xce, 0x88, 0x4f, 0xcc, 0x49, 0xcf,
	0x2f, 0xca, 0x2c, 0xc9, 0xc8, 0x95, 0x60, 0x54, 0x60, 0xd4, 0xe0, 0x33, 0xd2, 0xd0, 0x43, 0x18,
	0x84, 0xa6, 0x47, 0xcf, 0x23, 0xb1, 0x38, 0xc3, 0x11, 0xa6, 0x3e, 0x88, 0x37, 0x03, 0x99, 0x2b,
	0x14, 0xc7, 0x25, 0x0c, 0xd7, 0x89, 0x64, 0x2a, 0x13, 0xd8, 0x54, 0x5d, 0x3c, 0xa6, 0x06, 0xc3,
	0x64, 0x10, 0x46, 0x0b, 0x15, 0x63, 0x88, 0x09, 0xc9, 0x70, 0x21, 0x7c, 0x24, 0xc1, 0xac, 0xc0,
	0xa8, 0xc1, 0x13, 0x84, 0xe4, 0x45, 0x55, 0x2e, 0x5e, 0x14, 0xd7, 0x09, 0x71, 0x70, 0xb1, 0xf8,
	0xf9, 0xfb, 0xb9, 0x0a, 0x30, 0x08, 0x71, 0x71, 0xb1, 0x05, 0x7b, 0x38, 0x1a, 0x99, 0x9a, 0x09,
	0xb0, 0x28, 0x99, 0x73, 0x09, 0x61, 0x5a, 0x27, 0xc4, 0xcb, 0xc5, 0xe9, 0xe8, 0xe7, 0xef, 0x17,
	0xe9, 0xeb, 0x1f, 0x1a, 0x2c, 0xc0, 0x20, 0xc4, 0xce, 0xc5, 0x1c, 0x14, 0xec, 0x28, 0xc0, 0x28,
	0xc4, 0xc9, 0xc5, 0xea, 0xea, 0xec, 0x12, 0xec, 0x28, 0xc0, 0x9c, 0xc4, 0x06, 0x0e, 0x54, 0x63,
	0x40, 0x00, 0x00, 0x00, 0xff, 0xff, 0x69, 0x16, 0x48, 0x03, 0x67, 0x01, 0x00, 0x00,
}
