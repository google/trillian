package trillian

import (
	_ "crypto/sha256"

	"github.com/stretchr/testify/mock"
	"golang.org/x/net/context"
	"google.golang.org/grpc"
)

// MockTrillianLogClient is an autogenerated mock type for the TrillianLogClient type
type MockTrillianLogClient struct {
	mock.Mock
}

// GetConsistencyProof provides a mock function with given fields: ctx, in, opts
func (_m *MockTrillianLogClient) GetConsistencyProof(ctx context.Context, in *GetConsistencyProofRequest, opts ...grpc.CallOption) (*GetConsistencyProofResponse, error) {
	ret := _m.Called(ctx, in, opts)

	var r0 *GetConsistencyProofResponse
	if rf, ok := ret.Get(0).(func(context.Context, *GetConsistencyProofRequest, ...grpc.CallOption) *GetConsistencyProofResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*GetConsistencyProofResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *GetConsistencyProofRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetInclusionProof provides a mock function with given fields: ctx, in, opts
func (_m *MockTrillianLogClient) GetInclusionProof(ctx context.Context, in *GetInclusionProofRequest, opts ...grpc.CallOption) (*GetInclusionProofResponse, error) {
	ret := _m.Called(ctx, in, opts)

	var r0 *GetInclusionProofResponse
	if rf, ok := ret.Get(0).(func(context.Context, *GetInclusionProofRequest, ...grpc.CallOption) *GetInclusionProofResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*GetInclusionProofResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *GetInclusionProofRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetLatestSignedLogRoot provides a mock function with given fields: ctx, in, opts
func (_m *MockTrillianLogClient) GetLatestSignedLogRoot(ctx context.Context, in *GetLatestSignedLogRootRequest, opts ...grpc.CallOption) (*GetLatestSignedLogRootResponse, error) {
	ret := _m.Called(ctx, in, opts)

	var r0 *GetLatestSignedLogRootResponse
	if rf, ok := ret.Get(0).(func(context.Context, *GetLatestSignedLogRootRequest, ...grpc.CallOption) *GetLatestSignedLogRootResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*GetLatestSignedLogRootResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *GetLatestSignedLogRootRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetLeavesByHash provides a mock function with given fields: ctx, in, opts
func (_m *MockTrillianLogClient) GetLeavesByHash(ctx context.Context, in *GetLeavesByHashRequest, opts ...grpc.CallOption) (*GetLeavesByHashResponse, error) {
	ret := _m.Called(ctx, in, opts)

	var r0 *GetLeavesByHashResponse
	if rf, ok := ret.Get(0).(func(context.Context, *GetLeavesByHashRequest, ...grpc.CallOption) *GetLeavesByHashResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*GetLeavesByHashResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *GetLeavesByHashRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetLeavesByIndex provides a mock function with given fields: ctx, in, opts
func (_m *MockTrillianLogClient) GetLeavesByIndex(ctx context.Context, in *GetLeavesByIndexRequest, opts ...grpc.CallOption) (*GetLeavesByIndexResponse, error) {
	ret := _m.Called(ctx, in, opts)

	var r0 *GetLeavesByIndexResponse
	if rf, ok := ret.Get(0).(func(context.Context, *GetLeavesByIndexRequest, ...grpc.CallOption) *GetLeavesByIndexResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*GetLeavesByIndexResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *GetLeavesByIndexRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetSequencedLeafCount provides a mock function with given fields: ctx, in, opts
func (_m *MockTrillianLogClient) GetSequencedLeafCount(ctx context.Context, in *GetSequencedLeafCountRequest, opts ...grpc.CallOption) (*GetSequencedLeafCountResponse, error) {
	ret := _m.Called(ctx, in, opts)

	var r0 *GetSequencedLeafCountResponse
	if rf, ok := ret.Get(0).(func(context.Context, *GetSequencedLeafCountRequest, ...grpc.CallOption) *GetSequencedLeafCountResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*GetSequencedLeafCountResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *GetSequencedLeafCountRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// QueueLeaves provides a mock function with given fields: ctx, in, opts
func (_m *MockTrillianLogClient) QueueLeaves(ctx context.Context, in *QueueLeavesRequest, opts ...grpc.CallOption) (*QueueLeavesResponse, error) {
	ret := _m.Called(ctx, in, opts)

	var r0 *QueueLeavesResponse
	if rf, ok := ret.Get(0).(func(context.Context, *QueueLeavesRequest, ...grpc.CallOption) *QueueLeavesResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*QueueLeavesResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *QueueLeavesRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}
