// Code generated by protoc-gen-go. DO NOT EDIT.
// source: trillian_log_api.proto

package trillian

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	timestamp "github.com/golang/protobuf/ptypes/timestamp"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	status "google.golang.org/genproto/googleapis/rpc/status"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status1 "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// ChargeTo describes the user(s) associated with the request whose quota should
// be checked and charged.
type ChargeTo struct {
	// user is a list of personality-defined strings.
	// Trillian will treat them as /User/%{user}/... keys when checking and
	// charging quota.
	// If one or more of the specified users has insufficient quota, the
	// request will be denied.
	//
	// As an example, a Certificate Transparency frontend might set the following
	// user strings when sending a QueueLeaves request to the Trillian log:
	//   - The requesting IP address.
	//     This would limit the number of requests per IP.
	//   - The "intermediate-<hash>" for each of the intermediate certificates in
	//     the submitted chain.
	//     This would have the effect of limiting the rate of submissions under
	//     a given intermediate/root.
	User                 []string `protobuf:"bytes,1,rep,name=user,proto3" json:"user,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ChargeTo) Reset()         { *m = ChargeTo{} }
func (m *ChargeTo) String() string { return proto.CompactTextString(m) }
func (*ChargeTo) ProtoMessage()    {}
func (*ChargeTo) Descriptor() ([]byte, []int) {
	return fileDescriptor_5ad20a6a54aa5af3, []int{0}
}

func (m *ChargeTo) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ChargeTo.Unmarshal(m, b)
}
func (m *ChargeTo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ChargeTo.Marshal(b, m, deterministic)
}
func (m *ChargeTo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChargeTo.Merge(m, src)
}
func (m *ChargeTo) XXX_Size() int {
	return xxx_messageInfo_ChargeTo.Size(m)
}
func (m *ChargeTo) XXX_DiscardUnknown() {
	xxx_messageInfo_ChargeTo.DiscardUnknown(m)
}

var xxx_messageInfo_ChargeTo proto.InternalMessageInfo

func (m *ChargeTo) GetUser() []string {
	if m != nil {
		return m.User
	}
	return nil
}

type QueueLeafRequest struct {
	LogId                int64     `protobuf:"varint,1,opt,name=log_id,json=logId,proto3" json:"log_id,omitempty"`
	Leaf                 *LogLeaf  `protobuf:"bytes,2,opt,name=leaf,proto3" json:"leaf,omitempty"`
	ChargeTo             *ChargeTo `protobuf:"bytes,3,opt,name=charge_to,json=chargeTo,proto3" json:"charge_to,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *QueueLeafRequest) Reset()         { *m = QueueLeafRequest{} }
func (m *QueueLeafRequest) String() string { return proto.CompactTextString(m) }
func (*QueueLeafRequest) ProtoMessage()    {}
func (*QueueLeafRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_5ad20a6a54aa5af3, []int{1}
}

func (m *QueueLeafRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_QueueLeafRequest.Unmarshal(m, b)
}
func (m *QueueLeafRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_QueueLeafRequest.Marshal(b, m, deterministic)
}
func (m *QueueLeafRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueueLeafRequest.Merge(m, src)
}
func (m *QueueLeafRequest) XXX_Size() int {
	return xxx_messageInfo_QueueLeafRequest.Size(m)
}
func (m *QueueLeafRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueueLeafRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueueLeafRequest proto.InternalMessageInfo

func (m *QueueLeafRequest) GetLogId() int64 {
	if m != nil {
		return m.LogId
	}
	return 0
}

func (m *QueueLeafRequest) GetLeaf() *LogLeaf {
	if m != nil {
		return m.Leaf
	}
	return nil
}

func (m *QueueLeafRequest) GetChargeTo() *ChargeTo {
	if m != nil {
		return m.ChargeTo
	}
	return nil
}

type QueueLeafResponse struct {
	// queued_leaf describes the leaf which is or will be incorporated into the
	// Log.  If the submitted leaf was already present in the Log (as indicated by
	// its leaf identity hash), then the returned leaf will be the pre-existing
	// leaf entry rather than the submitted leaf.
	QueuedLeaf           *QueuedLogLeaf `protobuf:"bytes,2,opt,name=queued_leaf,json=queuedLeaf,proto3" json:"queued_leaf,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *QueueLeafResponse) Reset()         { *m = QueueLeafResponse{} }
func (m *QueueLeafResponse) String() string { return proto.CompactTextString(m) }
func (*QueueLeafResponse) ProtoMessage()    {}
func (*QueueLeafResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_5ad20a6a54aa5af3, []int{2}
}

func (m *QueueLeafResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_QueueLeafResponse.Unmarshal(m, b)
}
func (m *QueueLeafResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_QueueLeafResponse.Marshal(b, m, deterministic)
}
func (m *QueueLeafResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueueLeafResponse.Merge(m, src)
}
func (m *QueueLeafResponse) XXX_Size() int {
	return xxx_messageInfo_QueueLeafResponse.Size(m)
}
func (m *QueueLeafResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueueLeafResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueueLeafResponse proto.InternalMessageInfo

func (m *QueueLeafResponse) GetQueuedLeaf() *QueuedLogLeaf {
	if m != nil {
		return m.QueuedLeaf
	}
	return nil
}

type AddSequencedLeafRequest struct {
	LogId                int64     `protobuf:"varint,1,opt,name=log_id,json=logId,proto3" json:"log_id,omitempty"`
	Leaf                 *LogLeaf  `protobuf:"bytes,2,opt,name=leaf,proto3" json:"leaf,omitempty"`
	ChargeTo             *ChargeTo `protobuf:"bytes,3,opt,name=charge_to,json=chargeTo,proto3" json:"charge_to,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *AddSequencedLeafRequest) Reset()         { *m = AddSequencedLeafRequest{} }
func (m *AddSequencedLeafRequest) String() string { return proto.CompactTextString(m) }
func (*AddSequencedLeafRequest) ProtoMessage()    {}
func (*AddSequencedLeafRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_5ad20a6a54aa5af3, []int{3}
}

func (m *AddSequencedLeafRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_AddSequencedLeafRequest.Unmarshal(m, b)
}
func (m *AddSequencedLeafRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_AddSequencedLeafRequest.Marshal(b, m, deterministic)
}
func (m *AddSequencedLeafRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddSequencedLeafRequest.Merge(m, src)
}
func (m *AddSequencedLeafRequest) XXX_Size() int {
	return xxx_messageInfo_AddSequencedLeafRequest.Size(m)
}
func (m *AddSequencedLeafRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AddSequencedLeafRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AddSequencedLeafRequest proto.InternalMessageInfo

func (m *AddSequencedLeafRequest) GetLogId() int64 {
	if m != nil {
		return m.LogId
	}
	return 0
}

func (m *AddSequencedLeafRequest) GetLeaf() *LogLeaf {
	if m != nil {
		return m.Leaf
	}
	return nil
}

func (m *AddSequencedLeafRequest) GetChargeTo() *ChargeTo {
	if m != nil {
		return m.ChargeTo
	}
	return nil
}

type AddSequencedLeafResponse struct {
	Result               *QueuedLogLeaf `protobuf:"bytes,2,opt,name=result,proto3" json:"result,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *AddSequencedLeafResponse) Reset()         { *m = AddSequencedLeafResponse{} }
func (m *AddSequencedLeafResponse) String() string { return proto.CompactTextString(m) }
func (*AddSequencedLeafResponse) ProtoMessage()    {}
func (*AddSequencedLeafResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_5ad20a6a54aa5af3, []int{4}
}

func (m *AddSequencedLeafResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_AddSequencedLeafResponse.Unmarshal(m, b)
}
func (m *AddSequencedLeafResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_AddSequencedLeafResponse.Marshal(b, m, deterministic)
}
func (m *AddSequencedLeafResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddSequencedLeafResponse.Merge(m, src)
}
func (m *AddSequencedLeafResponse) XXX_Size() int {
	return xxx_messageInfo_AddSequencedLeafResponse.Size(m)
}
func (m *AddSequencedLeafResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_AddSequencedLeafResponse.DiscardUnknown(m)
}

var xxx_messageInfo_AddSequencedLeafResponse proto.InternalMessageInfo

func (m *AddSequencedLeafResponse) GetResult() *QueuedLogLeaf {
	if m != nil {
		return m.Result
	}
	return nil
}

type GetInclusionProofRequest struct {
	LogId                int64     `protobuf:"varint,1,opt,name=log_id,json=logId,proto3" json:"log_id,omitempty"`
	LeafIndex            int64     `protobuf:"varint,2,opt,name=leaf_index,json=leafIndex,proto3" json:"leaf_index,omitempty"`
	TreeSize             int64     `protobuf:"varint,3,opt,name=tree_size,json=treeSize,proto3" json:"tree_size,omitempty"`
	ChargeTo             *ChargeTo `protobuf:"bytes,4,opt,name=charge_to,json=chargeTo,proto3" json:"charge_to,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *GetInclusionProofRequest) Reset()         { *m = GetInclusionProofRequest{} }
func (m *GetInclusionProofRequest) String() string { return proto.CompactTextString(m) }
func (*GetInclusionProofRequest) ProtoMessage()    {}
func (*GetInclusionProofRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_5ad20a6a54aa5af3, []int{5}
}

func (m *GetInclusionProofRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GetInclusionProofRequest.Unmarshal(m, b)
}
func (m *GetInclusionProofRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GetInclusionProofRequest.Marshal(b, m, deterministic)
}
func (m *GetInclusionProofRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetInclusionProofRequest.Merge(m, src)
}
func (m *GetInclusionProofRequest) XXX_Size() int {
	return xxx_messageInfo_GetInclusionProofRequest.Size(m)
}
func (m *GetInclusionProofRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetInclusionProofRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetInclusionProofRequest proto.InternalMessageInfo

func (m *GetInclusionProofRequest) GetLogId() int64 {
	if m != nil {
		return m.LogId
	}
	return 0
}

func (m *GetInclusionProofRequest) GetLeafIndex() int64 {
	if m != nil {
		return m.LeafIndex
	}
	return 0
}

func (m *GetInclusionProofRequest) GetTreeSize() int64 {
	if m != nil {
		return m.TreeSize
	}
	return 0
}

func (m *GetInclusionProofRequest) GetChargeTo() *ChargeTo {
	if m != nil {
		return m.ChargeTo
	}
	return nil
}

type GetInclusionProofResponse struct {
	// The proof field may be empty if the requested tree_size was larger
	// than that available at the server (e.g. because there is skew between
	// server instances, and an earlier client request was processed by a
	// more up-to-date instance).  In this case, the signed_log_root
	// field will indicate the tree size that the server is aware of, and
	// the proof field will be empty.
	Proof                *Proof         `protobuf:"bytes,2,opt,name=proof,proto3" json:"proof,omitempty"`
	SignedLogRoot        *SignedLogRoot `protobuf:"bytes,3,opt,name=signed_log_root,json=signedLogRoot,proto3" json:"signed_log_root,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *GetInclusionProofResponse) Reset()         { *m = GetInclusionProofResponse{} }
func (m *GetInclusionProofResponse) String() string { return proto.CompactTextString(m) }
func (*GetInclusionProofResponse) ProtoMessage()    {}
func (*GetInclusionProofResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_5ad20a6a54aa5af3, []int{6}
}

func (m *GetInclusionProofResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GetInclusionProofResponse.Unmarshal(m, b)
}
func (m *GetInclusionProofResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GetInclusionProofResponse.Marshal(b, m, deterministic)
}
func (m *GetInclusionProofResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetInclusionProofResponse.Merge(m, src)
}
func (m *GetInclusionProofResponse) XXX_Size() int {
	return xxx_messageInfo_GetInclusionProofResponse.Size(m)
}
func (m *GetInclusionProofResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetInclusionProofResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetInclusionProofResponse proto.InternalMessageInfo

func (m *GetInclusionProofResponse) GetProof() *Proof {
	if m != nil {
		return m.Proof
	}
	return nil
}

func (m *GetInclusionProofResponse) GetSignedLogRoot() *SignedLogRoot {
	if m != nil {
		return m.SignedLogRoot
	}
	return nil
}

type GetInclusionProofByHashRequest struct {
	LogId int64 `protobuf:"varint,1,opt,name=log_id,json=logId,proto3" json:"log_id,omitempty"`
	// The leaf hash field provides the Merkle tree hash of the leaf entry
	// to be retrieved.
	LeafHash             []byte    `protobuf:"bytes,2,opt,name=leaf_hash,json=leafHash,proto3" json:"leaf_hash,omitempty"`
	TreeSize             int64     `protobuf:"varint,3,opt,name=tree_size,json=treeSize,proto3" json:"tree_size,omitempty"`
	OrderBySequence      bool      `protobuf:"varint,4,opt,name=order_by_sequence,json=orderBySequence,proto3" json:"order_by_sequence,omitempty"`
	ChargeTo             *ChargeTo `protobuf:"bytes,5,opt,name=charge_to,json=chargeTo,proto3" json:"charge_to,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *GetInclusionProofByHashRequest) Reset()         { *m = GetInclusionProofByHashRequest{} }
func (m *GetInclusionProofByHashRequest) String() string { return proto.CompactTextString(m) }
func (*GetInclusionProofByHashRequest) ProtoMessage()    {}
func (*GetInclusionProofByHashRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_5ad20a6a54aa5af3, []int{7}
}

func (m *GetInclusionProofByHashRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GetInclusionProofByHashRequest.Unmarshal(m, b)
}
func (m *GetInclusionProofByHashRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GetInclusionProofByHashRequest.Marshal(b, m, deterministic)
}
func (m *GetInclusionProofByHashRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetInclusionProofByHashRequest.Merge(m, src)
}
func (m *GetInclusionProofByHashRequest) XXX_Size() int {
	return xxx_messageInfo_GetInclusionProofByHashRequest.Size(m)
}
func (m *GetInclusionProofByHashRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetInclusionProofByHashRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetInclusionProofByHashRequest proto.InternalMessageInfo

func (m *GetInclusionProofByHashRequest) GetLogId() int64 {
	if m != nil {
		return m.LogId
	}
	return 0
}

func (m *GetInclusionProofByHashRequest) GetLeafHash() []byte {
	if m != nil {
		return m.LeafHash
	}
	return nil
}

func (m *GetInclusionProofByHashRequest) GetTreeSize() int64 {
	if m != nil {
		return m.TreeSize
	}
	return 0
}

func (m *GetInclusionProofByHashRequest) GetOrderBySequence() bool {
	if m != nil {
		return m.OrderBySequence
	}
	return false
}

func (m *GetInclusionProofByHashRequest) GetChargeTo() *ChargeTo {
	if m != nil {
		return m.ChargeTo
	}
	return nil
}

type GetInclusionProofByHashResponse struct {
	// Logs can potentially contain leaves with duplicate hashes so it's possible
	// for this to return multiple proofs.  If the leaf index for a particular
	// instance of the requested Merkle leaf hash is beyond the requested tree
	// size, the corresponding proof entry will be missing.
	Proof                []*Proof       `protobuf:"bytes,2,rep,name=proof,proto3" json:"proof,omitempty"`
	SignedLogRoot        *SignedLogRoot `protobuf:"bytes,3,opt,name=signed_log_root,json=signedLogRoot,proto3" json:"signed_log_root,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *GetInclusionProofByHashResponse) Reset()         { *m = GetInclusionProofByHashResponse{} }
func (m *GetInclusionProofByHashResponse) String() string { return proto.CompactTextString(m) }
func (*GetInclusionProofByHashResponse) ProtoMessage()    {}
func (*GetInclusionProofByHashResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_5ad20a6a54aa5af3, []int{8}
}

func (m *GetInclusionProofByHashResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GetInclusionProofByHashResponse.Unmarshal(m, b)
}
func (m *GetInclusionProofByHashResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GetInclusionProofByHashResponse.Marshal(b, m, deterministic)
}
func (m *GetInclusionProofByHashResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetInclusionProofByHashResponse.Merge(m, src)
}
func (m *GetInclusionProofByHashResponse) XXX_Size() int {
	return xxx_messageInfo_GetInclusionProofByHashResponse.Size(m)
}
func (m *GetInclusionProofByHashResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetInclusionProofByHashResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetInclusionProofByHashResponse proto.InternalMessageInfo

func (m *GetInclusionProofByHashResponse) GetProof() []*Proof {
	if m != nil {
		return m.Proof
	}
	return nil
}

func (m *GetInclusionProofByHashResponse) GetSignedLogRoot() *SignedLogRoot {
	if m != nil {
		return m.SignedLogRoot
	}
	return nil
}

type GetConsistencyProofRequest struct {
	LogId                int64     `protobuf:"varint,1,opt,name=log_id,json=logId,proto3" json:"log_id,omitempty"`
	FirstTreeSize        int64     `protobuf:"varint,2,opt,name=first_tree_size,json=firstTreeSize,proto3" json:"first_tree_size,omitempty"`
	SecondTreeSize       int64     `protobuf:"varint,3,opt,name=second_tree_size,json=secondTreeSize,proto3" json:"second_tree_size,omitempty"`
	ChargeTo             *ChargeTo `protobuf:"bytes,4,opt,name=charge_to,json=chargeTo,proto3" json:"charge_to,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *GetConsistencyProofRequest) Reset()         { *m = GetConsistencyProofRequest{} }
func (m *GetConsistencyProofRequest) String() string { return proto.CompactTextString(m) }
func (*GetConsistencyProofRequest) ProtoMessage()    {}
func (*GetConsistencyProofRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_5ad20a6a54aa5af3, []int{9}
}

func (m *GetConsistencyProofRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GetConsistencyProofRequest.Unmarshal(m, b)
}
func (m *GetConsistencyProofRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GetConsistencyProofRequest.Marshal(b, m, deterministic)
}
func (m *GetConsistencyProofRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetConsistencyProofRequest.Merge(m, src)
}
func (m *GetConsistencyProofRequest) XXX_Size() int {
	return xxx_messageInfo_GetConsistencyProofRequest.Size(m)
}
func (m *GetConsistencyProofRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetConsistencyProofRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetConsistencyProofRequest proto.InternalMessageInfo

func (m *GetConsistencyProofRequest) GetLogId() int64 {
	if m != nil {
		return m.LogId
	}
	return 0
}

func (m *GetConsistencyProofRequest) GetFirstTreeSize() int64 {
	if m != nil {
		return m.FirstTreeSize
	}
	return 0
}

func (m *GetConsistencyProofRequest) GetSecondTreeSize() int64 {
	if m != nil {
		return m.SecondTreeSize
	}
	return 0
}

func (m *GetConsistencyProofRequest) GetChargeTo() *ChargeTo {
	if m != nil {
		return m.ChargeTo
	}
	return nil
}

type GetConsistencyProofResponse struct {
	// The proof field may be empty if the requested tree_size was larger
	// than that available at the server (e.g. because there is skew between
	// server instances, and an earlier client request was processed by a
	// more up-to-date instance).  In this case, the signed_log_root
	// field will indicate the tree size that the server is aware of, and
	// the proof field will be empty.
	Proof                *Proof         `protobuf:"bytes,2,opt,name=proof,proto3" json:"proof,omitempty"`
	SignedLogRoot        *SignedLogRoot `protobuf:"bytes,3,opt,name=signed_log_root,json=signedLogRoot,proto3" json:"signed_log_root,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *GetConsistencyProofResponse) Reset()         { *m = GetConsistencyProofResponse{} }
func (m *GetConsistencyProofResponse) String() string { return proto.CompactTextString(m) }
func (*GetConsistencyProofResponse) ProtoMessage()    {}
func (*GetConsistencyProofResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_5ad20a6a54aa5af3, []int{10}
}

func (m *GetConsistencyProofResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GetConsistencyProofResponse.Unmarshal(m, b)
}
func (m *GetConsistencyProofResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GetConsistencyProofResponse.Marshal(b, m, deterministic)
}
func (m *GetConsistencyProofResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetConsistencyProofResponse.Merge(m, src)
}
func (m *GetConsistencyProofResponse) XXX_Size() int {
	return xxx_messageInfo_GetConsistencyProofResponse.Size(m)
}
func (m *GetConsistencyProofResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetConsistencyProofResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetConsistencyProofResponse proto.InternalMessageInfo

func (m *GetConsistencyProofResponse) GetProof() *Proof {
	if m != nil {
		return m.Proof
	}
	return nil
}

func (m *GetConsistencyProofResponse) GetSignedLogRoot() *SignedLogRoot {
	if m != nil {
		return m.SignedLogRoot
	}
	return nil
}

type GetLatestSignedLogRootRequest struct {
	LogId    int64     `protobuf:"varint,1,opt,name=log_id,json=logId,proto3" json:"log_id,omitempty"`
	ChargeTo *ChargeTo `protobuf:"bytes,2,opt,name=charge_to,json=chargeTo,proto3" json:"charge_to,omitempty"`
	// If first_tree_size is non-zero, the response will include a consistency
	// proof between first_tree_size and the new tree size (if not smaller).
	FirstTreeSize        int64    `protobuf:"varint,3,opt,name=first_tree_size,json=firstTreeSize,proto3" json:"first_tree_size,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetLatestSignedLogRootRequest) Reset()         { *m = GetLatestSignedLogRootRequest{} }
func (m *GetLatestSignedLogRootRequest) String() string { return proto.CompactTextString(m) }
func (*GetLatestSignedLogRootRequest) ProtoMessage()    {}
func (*GetLatestSignedLogRootRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_5ad20a6a54aa5af3, []int{11}
}

func (m *GetLatestSignedLogRootRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GetLatestSignedLogRootRequest.Unmarshal(m, b)
}
func (m *GetLatestSignedLogRootRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GetLatestSignedLogRootRequest.Marshal(b, m, deterministic)
}
func (m *GetLatestSignedLogRootRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetLatestSignedLogRootRequest.Merge(m, src)
}
func (m *GetLatestSignedLogRootRequest) XXX_Size() int {
	return xxx_messageInfo_GetLatestSignedLogRootRequest.Size(m)
}
func (m *GetLatestSignedLogRootRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetLatestSignedLogRootRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetLatestSignedLogRootRequest proto.InternalMessageInfo

func (m *GetLatestSignedLogRootRequest) GetLogId() int64 {
	if m != nil {
		return m.LogId
	}
	return 0
}

func (m *GetLatestSignedLogRootRequest) GetChargeTo() *ChargeTo {
	if m != nil {
		return m.ChargeTo
	}
	return nil
}

func (m *GetLatestSignedLogRootRequest) GetFirstTreeSize() int64 {
	if m != nil {
		return m.FirstTreeSize
	}
	return 0
}

type GetLatestSignedLogRootResponse struct {
	SignedLogRoot *SignedLogRoot `protobuf:"bytes,2,opt,name=signed_log_root,json=signedLogRoot,proto3" json:"signed_log_root,omitempty"`
	// proof is filled in with a consistency proof if first_tree_size in
	// GetLatestSignedLogRootRequest is non-zero (and within the tree size
	// available at the server).
	Proof                *Proof   `protobuf:"bytes,3,opt,name=proof,proto3" json:"proof,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetLatestSignedLogRootResponse) Reset()         { *m = GetLatestSignedLogRootResponse{} }
func (m *GetLatestSignedLogRootResponse) String() string { return proto.CompactTextString(m) }
func (*GetLatestSignedLogRootResponse) ProtoMessage()    {}
func (*GetLatestSignedLogRootResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_5ad20a6a54aa5af3, []int{12}
}

func (m *GetLatestSignedLogRootResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GetLatestSignedLogRootResponse.Unmarshal(m, b)
}
func (m *GetLatestSignedLogRootResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GetLatestSignedLogRootResponse.Marshal(b, m, deterministic)
}
func (m *GetLatestSignedLogRootResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetLatestSignedLogRootResponse.Merge(m, src)
}
func (m *GetLatestSignedLogRootResponse) XXX_Size() int {
	return xxx_messageInfo_GetLatestSignedLogRootResponse.Size(m)
}
func (m *GetLatestSignedLogRootResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetLatestSignedLogRootResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetLatestSignedLogRootResponse proto.InternalMessageInfo

func (m *GetLatestSignedLogRootResponse) GetSignedLogRoot() *SignedLogRoot {
	if m != nil {
		return m.SignedLogRoot
	}
	return nil
}

func (m *GetLatestSignedLogRootResponse) GetProof() *Proof {
	if m != nil {
		return m.Proof
	}
	return nil
}

// DO NOT USE - FOR DEBUGGING/TEST ONLY
//
// (Use GetLatestSignedLogRoot then de-serialize the Log Root and use
// use the tree size field within.)
type GetSequencedLeafCountRequest struct {
	LogId                int64     `protobuf:"varint,1,opt,name=log_id,json=logId,proto3" json:"log_id,omitempty"`
	ChargeTo             *ChargeTo `protobuf:"bytes,2,opt,name=charge_to,json=chargeTo,proto3" json:"charge_to,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *GetSequencedLeafCountRequest) Reset()         { *m = GetSequencedLeafCountRequest{} }
func (m *GetSequencedLeafCountRequest) String() string { return proto.CompactTextString(m) }
func (*GetSequencedLeafCountRequest) ProtoMessage()    {}
func (*GetSequencedLeafCountRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_5ad20a6a54aa5af3, []int{13}
}

func (m *GetSequencedLeafCountRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GetSequencedLeafCountRequest.Unmarshal(m, b)
}
func (m *GetSequencedLeafCountRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GetSequencedLeafCountRequest.Marshal(b, m, deterministic)
}
func (m *GetSequencedLeafCountRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetSequencedLeafCountRequest.Merge(m, src)
}
func (m *GetSequencedLeafCountRequest) XXX_Size() int {
	return xxx_messageInfo_GetSequencedLeafCountRequest.Size(m)
}
func (m *GetSequencedLeafCountRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetSequencedLeafCountRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetSequencedLeafCountRequest proto.InternalMessageInfo

func (m *GetSequencedLeafCountRequest) GetLogId() int64 {
	if m != nil {
		return m.LogId
	}
	return 0
}

func (m *GetSequencedLeafCountRequest) GetChargeTo() *ChargeTo {
	if m != nil {
		return m.ChargeTo
	}
	return nil
}

type GetSequencedLeafCountResponse struct {
	LeafCount            int64    `protobuf:"varint,2,opt,name=leaf_count,json=leafCount,proto3" json:"leaf_count,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetSequencedLeafCountResponse) Reset()         { *m = GetSequencedLeafCountResponse{} }
func (m *GetSequencedLeafCountResponse) String() string { return proto.CompactTextString(m) }
func (*GetSequencedLeafCountResponse) ProtoMessage()    {}
func (*GetSequencedLeafCountResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_5ad20a6a54aa5af3, []int{14}
}

func (m *GetSequencedLeafCountResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GetSequencedLeafCountResponse.Unmarshal(m, b)
}
func (m *GetSequencedLeafCountResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GetSequencedLeafCountResponse.Marshal(b, m, deterministic)
}
func (m *GetSequencedLeafCountResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetSequencedLeafCountResponse.Merge(m, src)
}
func (m *GetSequencedLeafCountResponse) XXX_Size() int {
	return xxx_messageInfo_GetSequencedLeafCountResponse.Size(m)
}
func (m *GetSequencedLeafCountResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetSequencedLeafCountResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetSequencedLeafCountResponse proto.InternalMessageInfo

func (m *GetSequencedLeafCountResponse) GetLeafCount() int64 {
	if m != nil {
		return m.LeafCount
	}
	return 0
}

type GetEntryAndProofRequest struct {
	LogId                int64     `protobuf:"varint,1,opt,name=log_id,json=logId,proto3" json:"log_id,omitempty"`
	LeafIndex            int64     `protobuf:"varint,2,opt,name=leaf_index,json=leafIndex,proto3" json:"leaf_index,omitempty"`
	TreeSize             int64     `protobuf:"varint,3,opt,name=tree_size,json=treeSize,proto3" json:"tree_size,omitempty"`
	ChargeTo             *ChargeTo `protobuf:"bytes,4,opt,name=charge_to,json=chargeTo,proto3" json:"charge_to,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *GetEntryAndProofRequest) Reset()         { *m = GetEntryAndProofRequest{} }
func (m *GetEntryAndProofRequest) String() string { return proto.CompactTextString(m) }
func (*GetEntryAndProofRequest) ProtoMessage()    {}
func (*GetEntryAndProofRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_5ad20a6a54aa5af3, []int{15}
}

func (m *GetEntryAndProofRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GetEntryAndProofRequest.Unmarshal(m, b)
}
func (m *GetEntryAndProofRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GetEntryAndProofRequest.Marshal(b, m, deterministic)
}
func (m *GetEntryAndProofRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetEntryAndProofRequest.Merge(m, src)
}
func (m *GetEntryAndProofRequest) XXX_Size() int {
	return xxx_messageInfo_GetEntryAndProofRequest.Size(m)
}
func (m *GetEntryAndProofRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetEntryAndProofRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetEntryAndProofRequest proto.InternalMessageInfo

func (m *GetEntryAndProofRequest) GetLogId() int64 {
	if m != nil {
		return m.LogId
	}
	return 0
}

func (m *GetEntryAndProofRequest) GetLeafIndex() int64 {
	if m != nil {
		return m.LeafIndex
	}
	return 0
}

func (m *GetEntryAndProofRequest) GetTreeSize() int64 {
	if m != nil {
		return m.TreeSize
	}
	return 0
}

func (m *GetEntryAndProofRequest) GetChargeTo() *ChargeTo {
	if m != nil {
		return m.ChargeTo
	}
	return nil
}

type GetEntryAndProofResponse struct {
	Proof                *Proof         `protobuf:"bytes,2,opt,name=proof,proto3" json:"proof,omitempty"`
	Leaf                 *LogLeaf       `protobuf:"bytes,3,opt,name=leaf,proto3" json:"leaf,omitempty"`
	SignedLogRoot        *SignedLogRoot `protobuf:"bytes,4,opt,name=signed_log_root,json=signedLogRoot,proto3" json:"signed_log_root,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *GetEntryAndProofResponse) Reset()         { *m = GetEntryAndProofResponse{} }
func (m *GetEntryAndProofResponse) String() string { return proto.CompactTextString(m) }
func (*GetEntryAndProofResponse) ProtoMessage()    {}
func (*GetEntryAndProofResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_5ad20a6a54aa5af3, []int{16}
}

func (m *GetEntryAndProofResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GetEntryAndProofResponse.Unmarshal(m, b)
}
func (m *GetEntryAndProofResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GetEntryAndProofResponse.Marshal(b, m, deterministic)
}
func (m *GetEntryAndProofResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetEntryAndProofResponse.Merge(m, src)
}
func (m *GetEntryAndProofResponse) XXX_Size() int {
	return xxx_messageInfo_GetEntryAndProofResponse.Size(m)
}
func (m *GetEntryAndProofResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetEntryAndProofResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetEntryAndProofResponse proto.InternalMessageInfo

func (m *GetEntryAndProofResponse) GetProof() *Proof {
	if m != nil {
		return m.Proof
	}
	return nil
}

func (m *GetEntryAndProofResponse) GetLeaf() *LogLeaf {
	if m != nil {
		return m.Leaf
	}
	return nil
}

func (m *GetEntryAndProofResponse) GetSignedLogRoot() *SignedLogRoot {
	if m != nil {
		return m.SignedLogRoot
	}
	return nil
}

type InitLogRequest struct {
	LogId                int64     `protobuf:"varint,1,opt,name=log_id,json=logId,proto3" json:"log_id,omitempty"`
	ChargeTo             *ChargeTo `protobuf:"bytes,2,opt,name=charge_to,json=chargeTo,proto3" json:"charge_to,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *InitLogRequest) Reset()         { *m = InitLogRequest{} }
func (m *InitLogRequest) String() string { return proto.CompactTextString(m) }
func (*InitLogRequest) ProtoMessage()    {}
func (*InitLogRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_5ad20a6a54aa5af3, []int{17}
}

func (m *InitLogRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_InitLogRequest.Unmarshal(m, b)
}
func (m *InitLogRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_InitLogRequest.Marshal(b, m, deterministic)
}
func (m *InitLogRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InitLogRequest.Merge(m, src)
}
func (m *InitLogRequest) XXX_Size() int {
	return xxx_messageInfo_InitLogRequest.Size(m)
}
func (m *InitLogRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_InitLogRequest.DiscardUnknown(m)
}

var xxx_messageInfo_InitLogRequest proto.InternalMessageInfo

func (m *InitLogRequest) GetLogId() int64 {
	if m != nil {
		return m.LogId
	}
	return 0
}

func (m *InitLogRequest) GetChargeTo() *ChargeTo {
	if m != nil {
		return m.ChargeTo
	}
	return nil
}

type InitLogResponse struct {
	Created              *SignedLogRoot `protobuf:"bytes,1,opt,name=created,proto3" json:"created,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *InitLogResponse) Reset()         { *m = InitLogResponse{} }
func (m *InitLogResponse) String() string { return proto.CompactTextString(m) }
func (*InitLogResponse) ProtoMessage()    {}
func (*InitLogResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_5ad20a6a54aa5af3, []int{18}
}

func (m *InitLogResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_InitLogResponse.Unmarshal(m, b)
}
func (m *InitLogResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_InitLogResponse.Marshal(b, m, deterministic)
}
func (m *InitLogResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InitLogResponse.Merge(m, src)
}
func (m *InitLogResponse) XXX_Size() int {
	return xxx_messageInfo_InitLogResponse.Size(m)
}
func (m *InitLogResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_InitLogResponse.DiscardUnknown(m)
}

var xxx_messageInfo_InitLogResponse proto.InternalMessageInfo

func (m *InitLogResponse) GetCreated() *SignedLogRoot {
	if m != nil {
		return m.Created
	}
	return nil
}

type QueueLeavesRequest struct {
	LogId                int64      `protobuf:"varint,1,opt,name=log_id,json=logId,proto3" json:"log_id,omitempty"`
	Leaves               []*LogLeaf `protobuf:"bytes,2,rep,name=leaves,proto3" json:"leaves,omitempty"`
	ChargeTo             *ChargeTo  `protobuf:"bytes,3,opt,name=charge_to,json=chargeTo,proto3" json:"charge_to,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *QueueLeavesRequest) Reset()         { *m = QueueLeavesRequest{} }
func (m *QueueLeavesRequest) String() string { return proto.CompactTextString(m) }
func (*QueueLeavesRequest) ProtoMessage()    {}
func (*QueueLeavesRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_5ad20a6a54aa5af3, []int{19}
}

func (m *QueueLeavesRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_QueueLeavesRequest.Unmarshal(m, b)
}
func (m *QueueLeavesRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_QueueLeavesRequest.Marshal(b, m, deterministic)
}
func (m *QueueLeavesRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueueLeavesRequest.Merge(m, src)
}
func (m *QueueLeavesRequest) XXX_Size() int {
	return xxx_messageInfo_QueueLeavesRequest.Size(m)
}
func (m *QueueLeavesRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueueLeavesRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueueLeavesRequest proto.InternalMessageInfo

func (m *QueueLeavesRequest) GetLogId() int64 {
	if m != nil {
		return m.LogId
	}
	return 0
}

func (m *QueueLeavesRequest) GetLeaves() []*LogLeaf {
	if m != nil {
		return m.Leaves
	}
	return nil
}

func (m *QueueLeavesRequest) GetChargeTo() *ChargeTo {
	if m != nil {
		return m.ChargeTo
	}
	return nil
}

type QueueLeavesResponse struct {
	// Same number and order as in the corresponding request.
	QueuedLeaves         []*QueuedLogLeaf `protobuf:"bytes,2,rep,name=queued_leaves,json=queuedLeaves,proto3" json:"queued_leaves,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *QueueLeavesResponse) Reset()         { *m = QueueLeavesResponse{} }
func (m *QueueLeavesResponse) String() string { return proto.CompactTextString(m) }
func (*QueueLeavesResponse) ProtoMessage()    {}
func (*QueueLeavesResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_5ad20a6a54aa5af3, []int{20}
}

func (m *QueueLeavesResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_QueueLeavesResponse.Unmarshal(m, b)
}
func (m *QueueLeavesResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_QueueLeavesResponse.Marshal(b, m, deterministic)
}
func (m *QueueLeavesResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueueLeavesResponse.Merge(m, src)
}
func (m *QueueLeavesResponse) XXX_Size() int {
	return xxx_messageInfo_QueueLeavesResponse.Size(m)
}
func (m *QueueLeavesResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueueLeavesResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueueLeavesResponse proto.InternalMessageInfo

func (m *QueueLeavesResponse) GetQueuedLeaves() []*QueuedLogLeaf {
	if m != nil {
		return m.QueuedLeaves
	}
	return nil
}

type AddSequencedLeavesRequest struct {
	LogId                int64      `protobuf:"varint,1,opt,name=log_id,json=logId,proto3" json:"log_id,omitempty"`
	Leaves               []*LogLeaf `protobuf:"bytes,2,rep,name=leaves,proto3" json:"leaves,omitempty"`
	ChargeTo             *ChargeTo  `protobuf:"bytes,4,opt,name=charge_to,json=chargeTo,proto3" json:"charge_to,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *AddSequencedLeavesRequest) Reset()         { *m = AddSequencedLeavesRequest{} }
func (m *AddSequencedLeavesRequest) String() string { return proto.CompactTextString(m) }
func (*AddSequencedLeavesRequest) ProtoMessage()    {}
func (*AddSequencedLeavesRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_5ad20a6a54aa5af3, []int{21}
}

func (m *AddSequencedLeavesRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_AddSequencedLeavesRequest.Unmarshal(m, b)
}
func (m *AddSequencedLeavesRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_AddSequencedLeavesRequest.Marshal(b, m, deterministic)
}
func (m *AddSequencedLeavesRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddSequencedLeavesRequest.Merge(m, src)
}
func (m *AddSequencedLeavesRequest) XXX_Size() int {
	return xxx_messageInfo_AddSequencedLeavesRequest.Size(m)
}
func (m *AddSequencedLeavesRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AddSequencedLeavesRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AddSequencedLeavesRequest proto.InternalMessageInfo

func (m *AddSequencedLeavesRequest) GetLogId() int64 {
	if m != nil {
		return m.LogId
	}
	return 0
}

func (m *AddSequencedLeavesRequest) GetLeaves() []*LogLeaf {
	if m != nil {
		return m.Leaves
	}
	return nil
}

func (m *AddSequencedLeavesRequest) GetChargeTo() *ChargeTo {
	if m != nil {
		return m.ChargeTo
	}
	return nil
}

type AddSequencedLeavesResponse struct {
	// Same number and order as in the corresponding request.
	Results              []*QueuedLogLeaf `protobuf:"bytes,2,rep,name=results,proto3" json:"results,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *AddSequencedLeavesResponse) Reset()         { *m = AddSequencedLeavesResponse{} }
func (m *AddSequencedLeavesResponse) String() string { return proto.CompactTextString(m) }
func (*AddSequencedLeavesResponse) ProtoMessage()    {}
func (*AddSequencedLeavesResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_5ad20a6a54aa5af3, []int{22}
}

func (m *AddSequencedLeavesResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_AddSequencedLeavesResponse.Unmarshal(m, b)
}
func (m *AddSequencedLeavesResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_AddSequencedLeavesResponse.Marshal(b, m, deterministic)
}
func (m *AddSequencedLeavesResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddSequencedLeavesResponse.Merge(m, src)
}
func (m *AddSequencedLeavesResponse) XXX_Size() int {
	return xxx_messageInfo_AddSequencedLeavesResponse.Size(m)
}
func (m *AddSequencedLeavesResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_AddSequencedLeavesResponse.DiscardUnknown(m)
}

var xxx_messageInfo_AddSequencedLeavesResponse proto.InternalMessageInfo

func (m *AddSequencedLeavesResponse) GetResults() []*QueuedLogLeaf {
	if m != nil {
		return m.Results
	}
	return nil
}

type GetLeavesByIndexRequest struct {
	LogId                int64     `protobuf:"varint,1,opt,name=log_id,json=logId,proto3" json:"log_id,omitempty"`
	LeafIndex            []int64   `protobuf:"varint,2,rep,packed,name=leaf_index,json=leafIndex,proto3" json:"leaf_index,omitempty"`
	ChargeTo             *ChargeTo `protobuf:"bytes,5,opt,name=charge_to,json=chargeTo,proto3" json:"charge_to,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *GetLeavesByIndexRequest) Reset()         { *m = GetLeavesByIndexRequest{} }
func (m *GetLeavesByIndexRequest) String() string { return proto.CompactTextString(m) }
func (*GetLeavesByIndexRequest) ProtoMessage()    {}
func (*GetLeavesByIndexRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_5ad20a6a54aa5af3, []int{23}
}

func (m *GetLeavesByIndexRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GetLeavesByIndexRequest.Unmarshal(m, b)
}
func (m *GetLeavesByIndexRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GetLeavesByIndexRequest.Marshal(b, m, deterministic)
}
func (m *GetLeavesByIndexRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetLeavesByIndexRequest.Merge(m, src)
}
func (m *GetLeavesByIndexRequest) XXX_Size() int {
	return xxx_messageInfo_GetLeavesByIndexRequest.Size(m)
}
func (m *GetLeavesByIndexRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetLeavesByIndexRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetLeavesByIndexRequest proto.InternalMessageInfo

func (m *GetLeavesByIndexRequest) GetLogId() int64 {
	if m != nil {
		return m.LogId
	}
	return 0
}

func (m *GetLeavesByIndexRequest) GetLeafIndex() []int64 {
	if m != nil {
		return m.LeafIndex
	}
	return nil
}

func (m *GetLeavesByIndexRequest) GetChargeTo() *ChargeTo {
	if m != nil {
		return m.ChargeTo
	}
	return nil
}

type GetLeavesByIndexResponse struct {
	// TODO(gbelvin): Response syntax does not allow for some requested leaves to be available, and some not (but using QueuedLogLeaf might)
	Leaves               []*LogLeaf     `protobuf:"bytes,2,rep,name=leaves,proto3" json:"leaves,omitempty"`
	SignedLogRoot        *SignedLogRoot `protobuf:"bytes,3,opt,name=signed_log_root,json=signedLogRoot,proto3" json:"signed_log_root,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *GetLeavesByIndexResponse) Reset()         { *m = GetLeavesByIndexResponse{} }
func (m *GetLeavesByIndexResponse) String() string { return proto.CompactTextString(m) }
func (*GetLeavesByIndexResponse) ProtoMessage()    {}
func (*GetLeavesByIndexResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_5ad20a6a54aa5af3, []int{24}
}

func (m *GetLeavesByIndexResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GetLeavesByIndexResponse.Unmarshal(m, b)
}
func (m *GetLeavesByIndexResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GetLeavesByIndexResponse.Marshal(b, m, deterministic)
}
func (m *GetLeavesByIndexResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetLeavesByIndexResponse.Merge(m, src)
}
func (m *GetLeavesByIndexResponse) XXX_Size() int {
	return xxx_messageInfo_GetLeavesByIndexResponse.Size(m)
}
func (m *GetLeavesByIndexResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetLeavesByIndexResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetLeavesByIndexResponse proto.InternalMessageInfo

func (m *GetLeavesByIndexResponse) GetLeaves() []*LogLeaf {
	if m != nil {
		return m.Leaves
	}
	return nil
}

func (m *GetLeavesByIndexResponse) GetSignedLogRoot() *SignedLogRoot {
	if m != nil {
		return m.SignedLogRoot
	}
	return nil
}

type GetLeavesByRangeRequest struct {
	LogId                int64     `protobuf:"varint,1,opt,name=log_id,json=logId,proto3" json:"log_id,omitempty"`
	StartIndex           int64     `protobuf:"varint,2,opt,name=start_index,json=startIndex,proto3" json:"start_index,omitempty"`
	Count                int64     `protobuf:"varint,3,opt,name=count,proto3" json:"count,omitempty"`
	ChargeTo             *ChargeTo `protobuf:"bytes,4,opt,name=charge_to,json=chargeTo,proto3" json:"charge_to,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *GetLeavesByRangeRequest) Reset()         { *m = GetLeavesByRangeRequest{} }
func (m *GetLeavesByRangeRequest) String() string { return proto.CompactTextString(m) }
func (*GetLeavesByRangeRequest) ProtoMessage()    {}
func (*GetLeavesByRangeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_5ad20a6a54aa5af3, []int{25}
}

func (m *GetLeavesByRangeRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GetLeavesByRangeRequest.Unmarshal(m, b)
}
func (m *GetLeavesByRangeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GetLeavesByRangeRequest.Marshal(b, m, deterministic)
}
func (m *GetLeavesByRangeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetLeavesByRangeRequest.Merge(m, src)
}
func (m *GetLeavesByRangeRequest) XXX_Size() int {
	return xxx_messageInfo_GetLeavesByRangeRequest.Size(m)
}
func (m *GetLeavesByRangeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetLeavesByRangeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetLeavesByRangeRequest proto.InternalMessageInfo

func (m *GetLeavesByRangeRequest) GetLogId() int64 {
	if m != nil {
		return m.LogId
	}
	return 0
}

func (m *GetLeavesByRangeRequest) GetStartIndex() int64 {
	if m != nil {
		return m.StartIndex
	}
	return 0
}

func (m *GetLeavesByRangeRequest) GetCount() int64 {
	if m != nil {
		return m.Count
	}
	return 0
}

func (m *GetLeavesByRangeRequest) GetChargeTo() *ChargeTo {
	if m != nil {
		return m.ChargeTo
	}
	return nil
}

type GetLeavesByRangeResponse struct {
	// Returned log leaves starting from the `start_index` of the request, in
	// order. There may be fewer than `request.count` leaves returned, if the
	// requested range extended beyond the size of the tree or if the server opted
	// to return fewer leaves than requested.
	Leaves               []*LogLeaf     `protobuf:"bytes,1,rep,name=leaves,proto3" json:"leaves,omitempty"`
	SignedLogRoot        *SignedLogRoot `protobuf:"bytes,2,opt,name=signed_log_root,json=signedLogRoot,proto3" json:"signed_log_root,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *GetLeavesByRangeResponse) Reset()         { *m = GetLeavesByRangeResponse{} }
func (m *GetLeavesByRangeResponse) String() string { return proto.CompactTextString(m) }
func (*GetLeavesByRangeResponse) ProtoMessage()    {}
func (*GetLeavesByRangeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_5ad20a6a54aa5af3, []int{26}
}

func (m *GetLeavesByRangeResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GetLeavesByRangeResponse.Unmarshal(m, b)
}
func (m *GetLeavesByRangeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GetLeavesByRangeResponse.Marshal(b, m, deterministic)
}
func (m *GetLeavesByRangeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetLeavesByRangeResponse.Merge(m, src)
}
func (m *GetLeavesByRangeResponse) XXX_Size() int {
	return xxx_messageInfo_GetLeavesByRangeResponse.Size(m)
}
func (m *GetLeavesByRangeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetLeavesByRangeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetLeavesByRangeResponse proto.InternalMessageInfo

func (m *GetLeavesByRangeResponse) GetLeaves() []*LogLeaf {
	if m != nil {
		return m.Leaves
	}
	return nil
}

func (m *GetLeavesByRangeResponse) GetSignedLogRoot() *SignedLogRoot {
	if m != nil {
		return m.SignedLogRoot
	}
	return nil
}

type GetLeavesByHashRequest struct {
	LogId int64 `protobuf:"varint,1,opt,name=log_id,json=logId,proto3" json:"log_id,omitempty"`
	// The Merkle leaf hash of the leaf to be retrieved.
	LeafHash [][]byte `protobuf:"bytes,2,rep,name=leaf_hash,json=leafHash,proto3" json:"leaf_hash,omitempty"`
	// If order_by_sequence is set then leaves will be returned in order of ascending
	// leaf index.
	OrderBySequence      bool      `protobuf:"varint,3,opt,name=order_by_sequence,json=orderBySequence,proto3" json:"order_by_sequence,omitempty"`
	ChargeTo             *ChargeTo `protobuf:"bytes,5,opt,name=charge_to,json=chargeTo,proto3" json:"charge_to,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *GetLeavesByHashRequest) Reset()         { *m = GetLeavesByHashRequest{} }
func (m *GetLeavesByHashRequest) String() string { return proto.CompactTextString(m) }
func (*GetLeavesByHashRequest) ProtoMessage()    {}
func (*GetLeavesByHashRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_5ad20a6a54aa5af3, []int{27}
}

func (m *GetLeavesByHashRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GetLeavesByHashRequest.Unmarshal(m, b)
}
func (m *GetLeavesByHashRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GetLeavesByHashRequest.Marshal(b, m, deterministic)
}
func (m *GetLeavesByHashRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetLeavesByHashRequest.Merge(m, src)
}
func (m *GetLeavesByHashRequest) XXX_Size() int {
	return xxx_messageInfo_GetLeavesByHashRequest.Size(m)
}
func (m *GetLeavesByHashRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetLeavesByHashRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetLeavesByHashRequest proto.InternalMessageInfo

func (m *GetLeavesByHashRequest) GetLogId() int64 {
	if m != nil {
		return m.LogId
	}
	return 0
}

func (m *GetLeavesByHashRequest) GetLeafHash() [][]byte {
	if m != nil {
		return m.LeafHash
	}
	return nil
}

func (m *GetLeavesByHashRequest) GetOrderBySequence() bool {
	if m != nil {
		return m.OrderBySequence
	}
	return false
}

func (m *GetLeavesByHashRequest) GetChargeTo() *ChargeTo {
	if m != nil {
		return m.ChargeTo
	}
	return nil
}

type GetLeavesByHashResponse struct {
	Leaves               []*LogLeaf     `protobuf:"bytes,2,rep,name=leaves,proto3" json:"leaves,omitempty"`
	SignedLogRoot        *SignedLogRoot `protobuf:"bytes,3,opt,name=signed_log_root,json=signedLogRoot,proto3" json:"signed_log_root,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *GetLeavesByHashResponse) Reset()         { *m = GetLeavesByHashResponse{} }
func (m *GetLeavesByHashResponse) String() string { return proto.CompactTextString(m) }
func (*GetLeavesByHashResponse) ProtoMessage()    {}
func (*GetLeavesByHashResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_5ad20a6a54aa5af3, []int{28}
}

func (m *GetLeavesByHashResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GetLeavesByHashResponse.Unmarshal(m, b)
}
func (m *GetLeavesByHashResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GetLeavesByHashResponse.Marshal(b, m, deterministic)
}
func (m *GetLeavesByHashResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetLeavesByHashResponse.Merge(m, src)
}
func (m *GetLeavesByHashResponse) XXX_Size() int {
	return xxx_messageInfo_GetLeavesByHashResponse.Size(m)
}
func (m *GetLeavesByHashResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetLeavesByHashResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetLeavesByHashResponse proto.InternalMessageInfo

func (m *GetLeavesByHashResponse) GetLeaves() []*LogLeaf {
	if m != nil {
		return m.Leaves
	}
	return nil
}

func (m *GetLeavesByHashResponse) GetSignedLogRoot() *SignedLogRoot {
	if m != nil {
		return m.SignedLogRoot
	}
	return nil
}

// QueuedLogLeaf provides the result of submitting an entry to the log.
// TODO(pavelkalinnikov): Consider renaming it to AddLogLeafResult or the like.
type QueuedLogLeaf struct {
	// The leaf as it was stored by Trillian. Empty unless `status.code` is:
	//  - `google.rpc.OK`: the `leaf` data is the same as in the request.
	//  - `google.rpc.ALREADY_EXISTS` or 'google.rpc.FAILED_PRECONDITION`: the
	//    `leaf` is the conflicting one already in the log.
	Leaf *LogLeaf `protobuf:"bytes,1,opt,name=leaf,proto3" json:"leaf,omitempty"`
	// The status of adding the leaf.
	//  - `google.rpc.OK`: successfully added.
	//  - `google.rpc.ALREADY_EXISTS`: the leaf is a duplicate of an already
	//    existing one. Either `leaf_identity_hash` is the same in the `LOG`
	//    mode, or `leaf_index` in the `PREORDERED_LOG`.
	//  - `google.rpc.FAILED_PRECONDITION`: A conflicting entry is already
	//    present in the log, e.g., same `leaf_index` but different `leaf_data`.
	Status               *status.Status `protobuf:"bytes,2,opt,name=status,proto3" json:"status,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *QueuedLogLeaf) Reset()         { *m = QueuedLogLeaf{} }
func (m *QueuedLogLeaf) String() string { return proto.CompactTextString(m) }
func (*QueuedLogLeaf) ProtoMessage()    {}
func (*QueuedLogLeaf) Descriptor() ([]byte, []int) {
	return fileDescriptor_5ad20a6a54aa5af3, []int{29}
}

func (m *QueuedLogLeaf) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_QueuedLogLeaf.Unmarshal(m, b)
}
func (m *QueuedLogLeaf) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_QueuedLogLeaf.Marshal(b, m, deterministic)
}
func (m *QueuedLogLeaf) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueuedLogLeaf.Merge(m, src)
}
func (m *QueuedLogLeaf) XXX_Size() int {
	return xxx_messageInfo_QueuedLogLeaf.Size(m)
}
func (m *QueuedLogLeaf) XXX_DiscardUnknown() {
	xxx_messageInfo_QueuedLogLeaf.DiscardUnknown(m)
}

var xxx_messageInfo_QueuedLogLeaf proto.InternalMessageInfo

func (m *QueuedLogLeaf) GetLeaf() *LogLeaf {
	if m != nil {
		return m.Leaf
	}
	return nil
}

func (m *QueuedLogLeaf) GetStatus() *status.Status {
	if m != nil {
		return m.Status
	}
	return nil
}

// LogLeaf describes a leaf in the Log's Merkle tree, corresponding to a single log entry.
// Each leaf has a unique leaf index in the scope of this tree.  Clients submitting new
// leaf entries should only set the following fields:
//   - leaf_value
//   - extra_data (optionally)
//   - leaf_identity_hash (optionally)
//   - leaf_index (iff the log is a PREORDERED_LOG)
type LogLeaf struct {
	// merkle_leaf_hash holds the Merkle leaf hash over leaf_value.  This is
	// calculated by the Trillian server when leaves are added to the tree, using
	// the defined hashing algorithm and strategy for the tree; as such, the client
	// does not need to set it on leaf submissions.
	MerkleLeafHash []byte `protobuf:"bytes,1,opt,name=merkle_leaf_hash,json=merkleLeafHash,proto3" json:"merkle_leaf_hash,omitempty"`
	// leaf_value holds the data that forms the value of the Merkle tree leaf.
	// The client should set this field on all leaf submissions, and is
	// responsible for ensuring its validity (the Trillian server treats it as an
	// opaque blob).
	LeafValue []byte `protobuf:"bytes,2,opt,name=leaf_value,json=leafValue,proto3" json:"leaf_value,omitempty"`
	// extra_data holds additional data associated with the Merkle tree leaf.
	// The client may set this data on leaf submissions, and the Trillian server
	// will return it on subsequent read operations. However, the contents of
	// this field are not covered by and do not affect the Merkle tree hash
	// calculations.
	ExtraData []byte `protobuf:"bytes,3,opt,name=extra_data,json=extraData,proto3" json:"extra_data,omitempty"`
	// leaf_index indicates the index of this leaf in the Merkle tree.
	// This field is returned on all read operations, but should only be
	// set for leaf submissions in PREORDERED_LOG mode (for a normal log
	// the leaf index is assigned by Trillian when the submitted leaf is
	// integrated into the Merkle tree).
	LeafIndex int64 `protobuf:"varint,4,opt,name=leaf_index,json=leafIndex,proto3" json:"leaf_index,omitempty"`
	// leaf_identity_hash provides a hash value that indicates the client's
	// concept of which leaf entries should be considered identical.
	//
	// This mechanism allows the client personality to indicate that two leaves
	// should be considered "duplicates" even though their `leaf_value`s differ.
	//
	// If this is not set on leaf submissions, the Trillian server will take its
	// value to be the same as merkle_leaf_hash (and thus only leaves with
	// identical leaf_value contents will be considered identical).
	//
	// For example, in Certificate Transparency each certificate submission is
	// associated with a submission timestamp, but subsequent submissions of the
	// same certificate should be considered identical.  This is achieved
	// by setting the leaf identity hash to a hash over (just) the certificate,
	// whereas the Merkle leaf hash encompasses both the certificate and its
	// submission time -- allowing duplicate certificates to be detected.
	//
	//
	// Continuing the CT example, for a CT mirror personality (which must allow
	// dupes since the source log could contain them), the part of the
	// personality which fetches and submits the entries might set
	// `leaf_identity_hash` to `H(leaf_index||cert)`.
	//
	// TODO(pavelkalinnikov): Consider instead using `H(cert)` and allowing
	// identity hash dupes in `PREORDERED_LOG` mode, for it can later be
	// upgraded to `LOG` which will need to correctly detect duplicates with
	// older entries when new ones get queued.
	LeafIdentityHash []byte `protobuf:"bytes,5,opt,name=leaf_identity_hash,json=leafIdentityHash,proto3" json:"leaf_identity_hash,omitempty"`
	// queue_timestamp holds the time at which this leaf was queued for
	// inclusion in the Log, or zero if the entry was submitted without
	// queuing. Clients should not set this field on submissions.
	QueueTimestamp *timestamp.Timestamp `protobuf:"bytes,6,opt,name=queue_timestamp,json=queueTimestamp,proto3" json:"queue_timestamp,omitempty"`
	// integrate_timestamp holds the time at which this leaf was integrated into
	// the tree.  Clients should not set this field on submissions.
	IntegrateTimestamp   *timestamp.Timestamp `protobuf:"bytes,7,opt,name=integrate_timestamp,json=integrateTimestamp,proto3" json:"integrate_timestamp,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *LogLeaf) Reset()         { *m = LogLeaf{} }
func (m *LogLeaf) String() string { return proto.CompactTextString(m) }
func (*LogLeaf) ProtoMessage()    {}
func (*LogLeaf) Descriptor() ([]byte, []int) {
	return fileDescriptor_5ad20a6a54aa5af3, []int{30}
}

func (m *LogLeaf) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_LogLeaf.Unmarshal(m, b)
}
func (m *LogLeaf) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_LogLeaf.Marshal(b, m, deterministic)
}
func (m *LogLeaf) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LogLeaf.Merge(m, src)
}
func (m *LogLeaf) XXX_Size() int {
	return xxx_messageInfo_LogLeaf.Size(m)
}
func (m *LogLeaf) XXX_DiscardUnknown() {
	xxx_messageInfo_LogLeaf.DiscardUnknown(m)
}

var xxx_messageInfo_LogLeaf proto.InternalMessageInfo

func (m *LogLeaf) GetMerkleLeafHash() []byte {
	if m != nil {
		return m.MerkleLeafHash
	}
	return nil
}

func (m *LogLeaf) GetLeafValue() []byte {
	if m != nil {
		return m.LeafValue
	}
	return nil
}

func (m *LogLeaf) GetExtraData() []byte {
	if m != nil {
		return m.ExtraData
	}
	return nil
}

func (m *LogLeaf) GetLeafIndex() int64 {
	if m != nil {
		return m.LeafIndex
	}
	return 0
}

func (m *LogLeaf) GetLeafIdentityHash() []byte {
	if m != nil {
		return m.LeafIdentityHash
	}
	return nil
}

func (m *LogLeaf) GetQueueTimestamp() *timestamp.Timestamp {
	if m != nil {
		return m.QueueTimestamp
	}
	return nil
}

func (m *LogLeaf) GetIntegrateTimestamp() *timestamp.Timestamp {
	if m != nil {
		return m.IntegrateTimestamp
	}
	return nil
}

func init() {
	proto.RegisterType((*ChargeTo)(nil), "trillian.ChargeTo")
	proto.RegisterType((*QueueLeafRequest)(nil), "trillian.QueueLeafRequest")
	proto.RegisterType((*QueueLeafResponse)(nil), "trillian.QueueLeafResponse")
	proto.RegisterType((*AddSequencedLeafRequest)(nil), "trillian.AddSequencedLeafRequest")
	proto.RegisterType((*AddSequencedLeafResponse)(nil), "trillian.AddSequencedLeafResponse")
	proto.RegisterType((*GetInclusionProofRequest)(nil), "trillian.GetInclusionProofRequest")
	proto.RegisterType((*GetInclusionProofResponse)(nil), "trillian.GetInclusionProofResponse")
	proto.RegisterType((*GetInclusionProofByHashRequest)(nil), "trillian.GetInclusionProofByHashRequest")
	proto.RegisterType((*GetInclusionProofByHashResponse)(nil), "trillian.GetInclusionProofByHashResponse")
	proto.RegisterType((*GetConsistencyProofRequest)(nil), "trillian.GetConsistencyProofRequest")
	proto.RegisterType((*GetConsistencyProofResponse)(nil), "trillian.GetConsistencyProofResponse")
	proto.RegisterType((*GetLatestSignedLogRootRequest)(nil), "trillian.GetLatestSignedLogRootRequest")
	proto.RegisterType((*GetLatestSignedLogRootResponse)(nil), "trillian.GetLatestSignedLogRootResponse")
	proto.RegisterType((*GetSequencedLeafCountRequest)(nil), "trillian.GetSequencedLeafCountRequest")
	proto.RegisterType((*GetSequencedLeafCountResponse)(nil), "trillian.GetSequencedLeafCountResponse")
	proto.RegisterType((*GetEntryAndProofRequest)(nil), "trillian.GetEntryAndProofRequest")
	proto.RegisterType((*GetEntryAndProofResponse)(nil), "trillian.GetEntryAndProofResponse")
	proto.RegisterType((*InitLogRequest)(nil), "trillian.InitLogRequest")
	proto.RegisterType((*InitLogResponse)(nil), "trillian.InitLogResponse")
	proto.RegisterType((*QueueLeavesRequest)(nil), "trillian.QueueLeavesRequest")
	proto.RegisterType((*QueueLeavesResponse)(nil), "trillian.QueueLeavesResponse")
	proto.RegisterType((*AddSequencedLeavesRequest)(nil), "trillian.AddSequencedLeavesRequest")
	proto.RegisterType((*AddSequencedLeavesResponse)(nil), "trillian.AddSequencedLeavesResponse")
	proto.RegisterType((*GetLeavesByIndexRequest)(nil), "trillian.GetLeavesByIndexRequest")
	proto.RegisterType((*GetLeavesByIndexResponse)(nil), "trillian.GetLeavesByIndexResponse")
	proto.RegisterType((*GetLeavesByRangeRequest)(nil), "trillian.GetLeavesByRangeRequest")
	proto.RegisterType((*GetLeavesByRangeResponse)(nil), "trillian.GetLeavesByRangeResponse")
	proto.RegisterType((*GetLeavesByHashRequest)(nil), "trillian.GetLeavesByHashRequest")
	proto.RegisterType((*GetLeavesByHashResponse)(nil), "trillian.GetLeavesByHashResponse")
	proto.RegisterType((*QueuedLogLeaf)(nil), "trillian.QueuedLogLeaf")
	proto.RegisterType((*LogLeaf)(nil), "trillian.LogLeaf")
}

func init() {
	proto.RegisterFile("trillian_log_api.proto", fileDescriptor_5ad20a6a54aa5af3)
}

var fileDescriptor_5ad20a6a54aa5af3 = []byte{
	// 1512 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x58, 0x5b, 0x6f, 0xdc, 0xc4,
	0x17, 0xaf, 0xb3, 0xb9, 0x9e, 0x34, 0xd9, 0x64, 0xf2, 0x6f, 0xb3, 0x71, 0x9a, 0x36, 0x75, 0x9a,
	0x76, 0x9b, 0x7f, 0x89, 0x49, 0x11, 0x02, 0x45, 0x15, 0xa8, 0x49, 0x51, 0x88, 0xba, 0x40, 0x71,
	0x22, 0x54, 0xc1, 0x83, 0xe5, 0xf5, 0x4e, 0x1c, 0x0b, 0xc7, 0xb3, 0xb5, 0x67, 0xa3, 0x6e, 0xab,
	0x4a, 0x5c, 0x54, 0x2e, 0x0f, 0xc0, 0x03, 0x3c, 0xf4, 0x85, 0xcb, 0x1b, 0xe2, 0x0b, 0xf0, 0x31,
	0x10, 0x12, 0x5f, 0x81, 0x07, 0x3e, 0x06, 0xf2, 0xcc, 0x78, 0x7d, 0x59, 0xdb, 0xbb, 0x5b, 0xd2,
	0xc2, 0xdb, 0xfa, 0xcc, 0x99, 0x73, 0x7e, 0xe7, 0x37, 0x73, 0xce, 0x9c, 0xb3, 0x70, 0x96, 0x7a,
	0xb6, 0xe3, 0xd8, 0x86, 0xab, 0x3b, 0xc4, 0xd2, 0x8d, 0xa6, 0xbd, 0xde, 0xf4, 0x08, 0x25, 0x68,
	0x3c, 0x94, 0xcb, 0xe7, 0x2c, 0x42, 0x2c, 0x07, 0xab, 0x46, 0xd3, 0x56, 0x0d, 0xd7, 0x25, 0xd4,
	0xa0, 0x36, 0x71, 0x7d, 0xae, 0x27, 0x5f, 0x10, 0xab, 0xec, 0xab, 0xde, 0x3a, 0x50, 0xa9, 0x7d,
	0x84, 0x7d, 0x6a, 0x1c, 0x35, 0x85, 0xc2, 0xbc, 0x50, 0xf0, 0x9a, 0xa6, 0xea, 0x53, 0x83, 0xb6,
	0xc2, 0x9d, 0xd3, 0xa1, 0x07, 0xfe, 0xad, 0x9c, 0x87, 0xf1, 0xed, 0x43, 0xc3, 0xb3, 0xf0, 0x3e,
	0x41, 0x08, 0x86, 0x5b, 0x3e, 0xf6, 0x2a, 0xd2, 0x72, 0xa9, 0x3a, 0xa1, 0xb1, 0xdf, 0xca, 0xc7,
	0x12, 0xcc, 0xbc, 0xdb, 0xc2, 0x2d, 0x5c, 0xc3, 0xc6, 0x81, 0x86, 0xef, 0xb5, 0xb0, 0x4f, 0xd1,
	0x19, 0x18, 0x0d, 0x70, 0xdb, 0x8d, 0x8a, 0xb4, 0x2c, 0x55, 0x4b, 0xda, 0x88, 0x43, 0xac, 0xdd,
	0x06, 0x5a, 0x85, 0x61, 0x07, 0x1b, 0x07, 0x95, 0xa1, 0x65, 0xa9, 0x3a, 0x79, 0x7d, 0x76, 0xbd,
	0xe3, 0xaa, 0x46, 0x2c, 0xb6, 0x9d, 0x2d, 0x23, 0x15, 0x26, 0x4c, 0xe6, 0x52, 0xa7, 0xa4, 0x52,
	0x62, 0xba, 0x28, 0xd2, 0x0d, 0xd1, 0x68, 0xe3, 0xa6, 0xf8, 0xa5, 0xbc, 0x05, 0xb3, 0x31, 0x08,
	0x7e, 0x93, 0xb8, 0x3e, 0x46, 0xaf, 0xc2, 0xe4, 0xbd, 0x40, 0xd8, 0xd0, 0x63, 0x3e, 0xe7, 0x23,
	0x3b, 0x6c, 0x47, 0x23, 0xf4, 0x0c, 0x5c, 0x37, 0xf8, 0xad, 0x7c, 0x21, 0xc1, 0xfc, 0xcd, 0x46,
	0x63, 0x2f, 0x08, 0xc6, 0x35, 0xb9, 0xf0, 0x5f, 0x8a, 0xec, 0x36, 0x54, 0xba, 0x91, 0x88, 0x00,
	0x55, 0x18, 0xf5, 0xb0, 0xdf, 0x72, 0x68, 0xaf, 0xd8, 0x84, 0x9a, 0xf2, 0x83, 0x04, 0x95, 0x1d,
	0x4c, 0x77, 0x5d, 0xd3, 0x69, 0xf9, 0x36, 0x71, 0xef, 0x78, 0x84, 0xf4, 0x0a, 0x6c, 0x09, 0x20,
	0x40, 0xae, 0xdb, 0x6e, 0x03, 0xdf, 0x67, 0x8e, 0x4a, 0xda, 0x44, 0x20, 0xd9, 0x0d, 0x04, 0x68,
	0x11, 0x26, 0xa8, 0x87, 0xb1, 0xee, 0xdb, 0x0f, 0x30, 0x0b, 0xa8, 0xa4, 0x8d, 0x07, 0x82, 0x3d,
	0xfb, 0x01, 0x4e, 0x46, 0x3b, 0xdc, 0x47, 0xb4, 0x9f, 0x4a, 0xb0, 0x90, 0x01, 0x50, 0xc4, 0xbb,
	0x0a, 0x23, 0xcd, 0x40, 0x20, 0xc2, 0x2d, 0x47, 0xa6, 0xb8, 0x1e, 0x5f, 0x45, 0xaf, 0x43, 0xd9,
	0xb7, 0x2d, 0x37, 0x38, 0x77, 0x62, 0xe9, 0x1e, 0x21, 0x54, 0x30, 0x1d, 0xe3, 0x67, 0x8f, 0x29,
	0xd4, 0x88, 0xa5, 0x11, 0x42, 0xb5, 0x29, 0x3f, 0xfe, 0xa9, 0xfc, 0x26, 0xc1, 0xf9, 0x2e, 0x14,
	0x5b, 0xed, 0x37, 0x0d, 0xff, 0xb0, 0x07, 0x59, 0x8b, 0xc0, 0xa8, 0xd1, 0x0f, 0x0d, 0xff, 0x90,
	0xa1, 0x3c, 0xad, 0x8d, 0x07, 0x82, 0x60, 0x6b, 0x31, 0x55, 0x6b, 0x30, 0x4b, 0xbc, 0x06, 0xf6,
	0xf4, 0x7a, 0x5b, 0xf7, 0xc5, 0x69, 0x33, 0xca, 0xc6, 0xb5, 0x32, 0x5b, 0xd8, 0x6a, 0x87, 0x97,
	0x20, 0x49, 0xeb, 0x48, 0x1f, 0xb4, 0x7e, 0x29, 0xc1, 0x85, 0xdc, 0x80, 0xba, 0xc9, 0x2d, 0x3d,
	0x4b, 0x72, 0x7f, 0x95, 0x40, 0xde, 0xc1, 0x74, 0x9b, 0xb8, 0xbe, 0xed, 0x53, 0xec, 0x9a, 0xed,
	0x7e, 0x6e, 0xe1, 0x65, 0x28, 0x1f, 0xd8, 0x9e, 0x4f, 0xf5, 0x88, 0x41, 0x7e, 0x15, 0xa7, 0x98,
	0x78, 0x3f, 0xa4, 0xb1, 0x0a, 0x33, 0x3e, 0x36, 0x89, 0xdb, 0xd0, 0xd3, 0x54, 0x4f, 0x73, 0xf9,
	0xfe, 0x53, 0xdf, 0xcd, 0xc7, 0x12, 0x2c, 0x66, 0x02, 0x7f, 0xce, 0xb7, 0xf3, 0x1b, 0x09, 0x96,
	0x76, 0x30, 0xad, 0x19, 0x14, 0xfb, 0x34, 0xa9, 0x59, 0xcc, 0x61, 0x22, 0xe2, 0xa1, 0xde, 0x11,
	0x67, 0x91, 0x5e, 0xca, 0x20, 0x3d, 0x28, 0x97, 0xe7, 0xf3, 0x10, 0x09, 0x72, 0x32, 0xa2, 0x1e,
	0x1a, 0x24, 0xea, 0x88, 0xdd, 0x52, 0x11, 0xbb, 0xca, 0x01, 0x9c, 0xdb, 0xc1, 0x34, 0x51, 0x2e,
	0xb7, 0x49, 0xcb, 0x3d, 0x69, 0x6a, 0x94, 0xd7, 0xd8, 0x19, 0x64, 0xf9, 0x11, 0x01, 0x87, 0x65,
	0xd3, 0x0c, 0xa4, 0xf1, 0xb2, 0xc9, 0xd4, 0x94, 0xef, 0x25, 0x98, 0xdf, 0xc1, 0xf4, 0x0d, 0x97,
	0x7a, 0xed, 0x9b, 0x6e, 0xe3, 0x3f, 0x57, 0x88, 0x7f, 0xe1, 0x2f, 0x45, 0x0a, 0xdf, 0x60, 0x37,
	0x3d, 0x7c, 0x12, 0x4b, 0xc5, 0x4f, 0x62, 0xc6, 0xd5, 0x18, 0x1e, 0x28, 0x21, 0xee, 0xc2, 0xf4,
	0xae, 0x6b, 0xd3, 0xe0, 0xf3, 0x84, 0x4f, 0xf9, 0x16, 0x94, 0x3b, 0x96, 0x45, 0xec, 0x1b, 0x30,
	0x66, 0x7a, 0xd8, 0xa0, 0x98, 0xdb, 0x2e, 0x40, 0x19, 0xea, 0x29, 0x9f, 0x4b, 0x80, 0xc2, 0xee,
	0xe4, 0x18, 0xfb, 0x3d, 0x40, 0x5e, 0x85, 0x51, 0x87, 0xe9, 0x89, 0x42, 0x9c, 0xc1, 0x9b, 0x50,
	0x18, 0xbc, 0x99, 0xd8, 0x83, 0xb9, 0x04, 0x10, 0x11, 0xd3, 0x0d, 0x98, 0x8a, 0x1a, 0xa5, 0xc8,
	0x73, 0x6e, 0x3b, 0x71, 0xba, 0xd3, 0x2a, 0x1d, 0x63, 0x5f, 0xf9, 0x5a, 0x82, 0x85, 0x54, 0x8b,
	0xf2, 0xec, 0xa2, 0xec, 0xe7, 0xee, 0xbe, 0x03, 0x72, 0x16, 0x9e, 0xe8, 0x00, 0x79, 0x37, 0xd4,
	0x33, 0xcc, 0x50, 0x4f, 0xf9, 0x88, 0x27, 0x2b, 0x37, 0xb4, 0xd5, 0x66, 0xf9, 0x36, 0x60, 0xb2,
	0x96, 0x92, 0xc9, 0x3a, 0xf0, 0x0b, 0xfe, 0x19, 0xcf, 0xc7, 0x14, 0x04, 0x11, 0xd2, 0x00, 0x64,
	0xfe, 0xe3, 0xd7, 0xe7, 0x49, 0x92, 0x0b, 0xcd, 0x70, 0x2d, 0xdc, 0x83, 0x8b, 0x0b, 0x30, 0xe9,
	0x53, 0xc3, 0xa3, 0x89, 0xca, 0x05, 0x4c, 0xc4, 0xd9, 0xf8, 0x1f, 0x8c, 0xf0, 0x32, 0xc9, 0xcb,
	0x16, 0xff, 0x18, 0xfc, 0xdc, 0x53, 0x1c, 0x09, 0x68, 0x5d, 0x1c, 0x49, 0x4f, 0xc1, 0xd1, 0x40,
	0x6f, 0x55, 0x50, 0x3c, 0xcf, 0xc6, 0x80, 0x0c, 0xde, 0x37, 0x96, 0x12, 0x7d, 0x63, 0x66, 0x6b,
	0x58, 0x3a, 0xa1, 0xd6, 0xf0, 0x71, 0xf2, 0x3c, 0x13, 0x2d, 0xe1, 0xf3, 0xbc, 0x57, 0x75, 0x98,
	0x4a, 0x64, 0x5f, 0xe7, 0xf5, 0x90, 0x8a, 0x5f, 0x8f, 0x35, 0x18, 0xe5, 0xd3, 0x6b, 0xa7, 0xa0,
	0xf3, 0xb9, 0x76, 0xdd, 0x6b, 0x9a, 0xeb, 0x7b, 0x6c, 0x45, 0x13, 0x1a, 0xca, 0xef, 0x43, 0x30,
	0x16, 0x9a, 0xaf, 0xc2, 0xcc, 0x11, 0xf6, 0x3e, 0x74, 0xb0, 0x1e, 0x11, 0x2f, 0xb1, 0x86, 0x7d,
	0x9a, 0xcb, 0x6b, 0x21, 0xfd, 0x61, 0x2a, 0x1f, 0x1b, 0x4e, 0x0b, 0x8b, 0xa6, 0x9e, 0x9d, 0xd6,
	0x7b, 0x81, 0x20, 0x58, 0xc6, 0xf7, 0xa9, 0x67, 0xe8, 0x0d, 0x83, 0x1a, 0x2c, 0xe8, 0xd3, 0xda,
	0x04, 0x93, 0xdc, 0x32, 0xa8, 0x91, 0x2a, 0x04, 0xc3, 0xe9, 0x57, 0xfb, 0x1a, 0x20, 0xbe, 0xdc,
	0xc0, 0x2e, 0xb5, 0x69, 0x9b, 0x03, 0x19, 0x61, 0x56, 0x66, 0x98, 0x9a, 0x58, 0x60, 0x50, 0xb6,
	0xa1, 0xcc, 0x4a, 0xaf, 0xde, 0x19, 0xe6, 0x2b, 0xa3, 0x2c, 0x6a, 0x39, 0x8c, 0x3a, 0x1c, 0xf7,
	0xd7, 0xf7, 0x43, 0x0d, 0x6d, 0x9a, 0x6d, 0xe9, 0x7c, 0xa3, 0xdb, 0x30, 0x67, 0xbb, 0x14, 0x5b,
	0x9e, 0x41, 0xe3, 0x86, 0xc6, 0x7a, 0x1a, 0x42, 0x9d, 0x6d, 0x1d, 0xd9, 0xf5, 0xbf, 0xa6, 0x60,
	0x72, 0x5f, 0x9c, 0x4c, 0x8d, 0x58, 0xc8, 0x85, 0x89, 0xce, 0x20, 0x8e, 0xe4, 0x54, 0x65, 0x8d,
	0x8d, 0xd1, 0xf2, 0x62, 0xe6, 0x1a, 0xbf, 0x78, 0x4a, 0xf5, 0x93, 0x3f, 0xfe, 0xfc, 0x76, 0x48,
	0x51, 0x96, 0xd4, 0xe3, 0x8d, 0x3a, 0xa6, 0xc6, 0x86, 0xea, 0x10, 0xcb, 0x57, 0x1f, 0xf2, 0xd4,
	0x79, 0xa4, 0xf2, 0x4b, 0xb7, 0x29, 0xad, 0xa1, 0xaf, 0x24, 0x98, 0x49, 0xcf, 0xc7, 0xe8, 0x62,
	0x64, 0x3b, 0x67, 0x8a, 0x97, 0x95, 0x22, 0x15, 0x81, 0xe2, 0x3a, 0x43, 0x71, 0x4d, 0xb9, 0x52,
	0x8c, 0x22, 0x4c, 0xc9, 0x46, 0x80, 0xe7, 0x27, 0x09, 0x66, 0xbb, 0x26, 0x2d, 0x14, 0xf3, 0x96,
	0x37, 0x7e, 0xcb, 0x2b, 0x85, 0x3a, 0x02, 0xd2, 0x16, 0x83, 0x74, 0x03, 0x6d, 0x16, 0x42, 0x52,
	0x1f, 0x46, 0x57, 0xee, 0xd1, 0xa6, 0x1d, 0x9a, 0xd2, 0x79, 0x5b, 0xf6, 0x33, 0xcf, 0xf8, 0xac,
	0x61, 0x10, 0x55, 0x0b, 0x40, 0x24, 0x0a, 0x99, 0x7c, 0xb5, 0x0f, 0x4d, 0x01, 0xfa, 0x15, 0x06,
	0x7a, 0x03, 0xa9, 0xc5, 0x3c, 0x46, 0x38, 0xeb, 0x3c, 0x0d, 0xd0, 0x77, 0x12, 0xcc, 0x65, 0x4c,
	0x5c, 0xe8, 0x52, 0xc2, 0x77, 0xce, 0x24, 0x29, 0xaf, 0xf6, 0xd0, 0x12, 0xe8, 0x5e, 0x64, 0xe8,
	0xd6, 0x50, 0x35, 0x1b, 0xdd, 0xa6, 0x19, 0x6d, 0x14, 0x04, 0x3e, 0x11, 0xe5, 0xbd, 0x7b, 0xdc,
	0x41, 0x57, 0x12, 0x3e, 0xf3, 0x47, 0x34, 0xb9, 0xda, 0x5b, 0x51, 0xe0, 0xfb, 0x3f, 0xc3, 0xb7,
	0x8a, 0x56, 0x72, 0xd8, 0x0b, 0x6a, 0xad, 0xbf, 0xe9, 0x30, 0x0b, 0xe8, 0x47, 0x09, 0xce, 0x64,
	0xce, 0x25, 0xe8, 0x72, 0xc2, 0x61, 0xee, 0x80, 0x24, 0x5f, 0xe9, 0xa9, 0x27, 0x70, 0xbd, 0xcc,
	0x70, 0xa9, 0xe8, 0x85, 0x3e, 0xb3, 0x83, 0x4f, 0x42, 0x2c, 0x61, 0xd3, 0x83, 0x45, 0x3c, 0x61,
	0x73, 0x86, 0x22, 0x59, 0x29, 0x52, 0x49, 0x26, 0x2c, 0x5a, 0xeb, 0x3f, 0x3b, 0x90, 0x09, 0x63,
	0xa2, 0xc5, 0x47, 0x95, 0xc8, 0x45, 0x72, 0x9e, 0x90, 0x17, 0x32, 0x56, 0x84, 0xcf, 0x15, 0xe6,
	0x73, 0x49, 0x59, 0xcc, 0xb9, 0x3e, 0xb6, 0x6b, 0x53, 0x54, 0x83, 0xc9, 0x58, 0xdf, 0x8d, 0xce,
	0x75, 0xd7, 0xbe, 0xa8, 0x63, 0x96, 0x97, 0x72, 0x56, 0x85, 0xc3, 0x53, 0xc8, 0x00, 0xd4, 0xdd,
	0xdf, 0xa2, 0x95, 0xdc, 0x8a, 0x16, 0xb3, 0x7d, 0xa9, 0x58, 0xa9, 0xe3, 0xe2, 0x03, 0x76, 0x48,
	0x89, 0x6e, 0x33, 0x75, 0x48, 0x59, 0xcd, 0x70, 0xea, 0x90, 0x32, 0x9b, 0xd5, 0x2e, 0xe3, 0xac,
	0x4d, 0xcb, 0x31, 0x1e, 0xef, 0x2e, 0x73, 0x8c, 0x27, 0xba, 0x3c, 0xe5, 0x14, 0xba, 0x0b, 0xe5,
	0x54, 0x3b, 0x83, 0x96, 0x33, 0x37, 0xc6, 0x8b, 0xd9, 0xc5, 0x02, 0x8d, 0xd0, 0xf2, 0xd6, 0xdb,
	0xb0, 0x60, 0x92, 0xa3, 0xf0, 0x7d, 0x4c, 0xfe, 0x49, 0xbe, 0x35, 0x17, 0x7b, 0x04, 0x6f, 0x36,
	0xed, 0x3b, 0x81, 0xf0, 0x8e, 0xf4, 0xbe, 0x6c, 0xd9, 0xf4, 0xb0, 0x55, 0x5f, 0x37, 0xc9, 0x91,
	0x2a, 0xfe, 0x6f, 0x0f, 0x37, 0xd6, 0x47, 0xd9, 0xce, 0x97, 0xfe, 0x0e, 0x00, 0x00, 0xff, 0xff,
	0x2a, 0x12, 0x9d, 0x60, 0xea, 0x17, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConnInterface

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion6

// TrillianLogClient is the client API for TrillianLog service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type TrillianLogClient interface {
	// QueueLeaf adds a single leaf to the queue of pending leaves for a normal
	// log.
	QueueLeaf(ctx context.Context, in *QueueLeafRequest, opts ...grpc.CallOption) (*QueueLeafResponse, error)
	// AddSequencedLeaf adds a single leaf with an assigned sequence number to a
	// pre-ordered log.
	AddSequencedLeaf(ctx context.Context, in *AddSequencedLeafRequest, opts ...grpc.CallOption) (*AddSequencedLeafResponse, error)
	// GetInclusionProof returns an inclusion proof for a leaf with a given index
	// in a particular tree.
	//
	// If the requested tree_size is larger than the server is aware of, the
	// response will include the latest known log root and an empty proof.
	GetInclusionProof(ctx context.Context, in *GetInclusionProofRequest, opts ...grpc.CallOption) (*GetInclusionProofResponse, error)
	// GetInclusionProofByHash returns an inclusion proof for any leaves that have
	// the given Merkle hash in a particular tree.
	//
	// If any of the leaves that match the given Merkle has have a leaf index that
	// is beyond the requested tree size, the corresponding proof entry will be empty.
	GetInclusionProofByHash(ctx context.Context, in *GetInclusionProofByHashRequest, opts ...grpc.CallOption) (*GetInclusionProofByHashResponse, error)
	// GetConsistencyProof returns a consistency proof between different sizes of
	// a particular tree.
	//
	// If the requested tree size is larger than the server is aware of,
	// the response will include the latest known log root and an empty proof.
	GetConsistencyProof(ctx context.Context, in *GetConsistencyProofRequest, opts ...grpc.CallOption) (*GetConsistencyProofResponse, error)
	// GetLatestSignedLogRoot returns the latest signed log root for a given tree,
	// and optionally also includes a consistency proof from an earlier tree size
	// to the new size of the tree.
	//
	// If the earlier tree size is larger than the server is aware of,
	// an InvalidArgument error is returned.
	GetLatestSignedLogRoot(ctx context.Context, in *GetLatestSignedLogRootRequest, opts ...grpc.CallOption) (*GetLatestSignedLogRootResponse, error)
	// GetSequencedLeafCount returns the total number of leaves that have been
	// integrated into the given tree.
	//
	// DO NOT USE - FOR DEBUGGING/TEST ONLY
	//
	// (Use GetLatestSignedLogRoot then de-serialize the Log Root and use
	// use the tree size field within.)
	GetSequencedLeafCount(ctx context.Context, in *GetSequencedLeafCountRequest, opts ...grpc.CallOption) (*GetSequencedLeafCountResponse, error)
	// GetEntryAndProof returns a log leaf and the corresponding inclusion proof
	// to a specified tree size, for a given leaf index in a particular tree.
	//
	// If the requested tree size is unavailable but the leaf is
	// in scope for the current tree, the returned proof will be for the
	// current tree size rather than the requested tree size.
	GetEntryAndProof(ctx context.Context, in *GetEntryAndProofRequest, opts ...grpc.CallOption) (*GetEntryAndProofResponse, error)
	// InitLog initializes a particular tree, creating the initial signed log
	// root (which will be of size 0).
	InitLog(ctx context.Context, in *InitLogRequest, opts ...grpc.CallOption) (*InitLogResponse, error)
	// QueueLeaf adds a batch of leaves to the queue of pending leaves for a
	// normal log.
	QueueLeaves(ctx context.Context, in *QueueLeavesRequest, opts ...grpc.CallOption) (*QueueLeavesResponse, error)
	// AddSequencedLeaves adds a batch of leaves with assigned sequence numbers
	// to a pre-ordered log.  The indices of the provided leaves must be contiguous.
	AddSequencedLeaves(ctx context.Context, in *AddSequencedLeavesRequest, opts ...grpc.CallOption) (*AddSequencedLeavesResponse, error)
	// GetLeavesByIndex returns a batch of leaves whose leaf indices are provided
	// in the request.
	GetLeavesByIndex(ctx context.Context, in *GetLeavesByIndexRequest, opts ...grpc.CallOption) (*GetLeavesByIndexResponse, error)
	// GetLeavesByRange returns a batch of leaves whose leaf indices are in a
	// sequential range.
	GetLeavesByRange(ctx context.Context, in *GetLeavesByRangeRequest, opts ...grpc.CallOption) (*GetLeavesByRangeResponse, error)
	// GetLeavesByHash returns a batch of leaves which are identified by their
	// Merkle leaf hash values.
	GetLeavesByHash(ctx context.Context, in *GetLeavesByHashRequest, opts ...grpc.CallOption) (*GetLeavesByHashResponse, error)
}

type trillianLogClient struct {
	cc grpc.ClientConnInterface
}

func NewTrillianLogClient(cc grpc.ClientConnInterface) TrillianLogClient {
	return &trillianLogClient{cc}
}

func (c *trillianLogClient) QueueLeaf(ctx context.Context, in *QueueLeafRequest, opts ...grpc.CallOption) (*QueueLeafResponse, error) {
	out := new(QueueLeafResponse)
	err := c.cc.Invoke(ctx, "/trillian.TrillianLog/QueueLeaf", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *trillianLogClient) AddSequencedLeaf(ctx context.Context, in *AddSequencedLeafRequest, opts ...grpc.CallOption) (*AddSequencedLeafResponse, error) {
	out := new(AddSequencedLeafResponse)
	err := c.cc.Invoke(ctx, "/trillian.TrillianLog/AddSequencedLeaf", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *trillianLogClient) GetInclusionProof(ctx context.Context, in *GetInclusionProofRequest, opts ...grpc.CallOption) (*GetInclusionProofResponse, error) {
	out := new(GetInclusionProofResponse)
	err := c.cc.Invoke(ctx, "/trillian.TrillianLog/GetInclusionProof", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *trillianLogClient) GetInclusionProofByHash(ctx context.Context, in *GetInclusionProofByHashRequest, opts ...grpc.CallOption) (*GetInclusionProofByHashResponse, error) {
	out := new(GetInclusionProofByHashResponse)
	err := c.cc.Invoke(ctx, "/trillian.TrillianLog/GetInclusionProofByHash", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *trillianLogClient) GetConsistencyProof(ctx context.Context, in *GetConsistencyProofRequest, opts ...grpc.CallOption) (*GetConsistencyProofResponse, error) {
	out := new(GetConsistencyProofResponse)
	err := c.cc.Invoke(ctx, "/trillian.TrillianLog/GetConsistencyProof", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *trillianLogClient) GetLatestSignedLogRoot(ctx context.Context, in *GetLatestSignedLogRootRequest, opts ...grpc.CallOption) (*GetLatestSignedLogRootResponse, error) {
	out := new(GetLatestSignedLogRootResponse)
	err := c.cc.Invoke(ctx, "/trillian.TrillianLog/GetLatestSignedLogRoot", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *trillianLogClient) GetSequencedLeafCount(ctx context.Context, in *GetSequencedLeafCountRequest, opts ...grpc.CallOption) (*GetSequencedLeafCountResponse, error) {
	out := new(GetSequencedLeafCountResponse)
	err := c.cc.Invoke(ctx, "/trillian.TrillianLog/GetSequencedLeafCount", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *trillianLogClient) GetEntryAndProof(ctx context.Context, in *GetEntryAndProofRequest, opts ...grpc.CallOption) (*GetEntryAndProofResponse, error) {
	out := new(GetEntryAndProofResponse)
	err := c.cc.Invoke(ctx, "/trillian.TrillianLog/GetEntryAndProof", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *trillianLogClient) InitLog(ctx context.Context, in *InitLogRequest, opts ...grpc.CallOption) (*InitLogResponse, error) {
	out := new(InitLogResponse)
	err := c.cc.Invoke(ctx, "/trillian.TrillianLog/InitLog", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *trillianLogClient) QueueLeaves(ctx context.Context, in *QueueLeavesRequest, opts ...grpc.CallOption) (*QueueLeavesResponse, error) {
	out := new(QueueLeavesResponse)
	err := c.cc.Invoke(ctx, "/trillian.TrillianLog/QueueLeaves", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *trillianLogClient) AddSequencedLeaves(ctx context.Context, in *AddSequencedLeavesRequest, opts ...grpc.CallOption) (*AddSequencedLeavesResponse, error) {
	out := new(AddSequencedLeavesResponse)
	err := c.cc.Invoke(ctx, "/trillian.TrillianLog/AddSequencedLeaves", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *trillianLogClient) GetLeavesByIndex(ctx context.Context, in *GetLeavesByIndexRequest, opts ...grpc.CallOption) (*GetLeavesByIndexResponse, error) {
	out := new(GetLeavesByIndexResponse)
	err := c.cc.Invoke(ctx, "/trillian.TrillianLog/GetLeavesByIndex", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *trillianLogClient) GetLeavesByRange(ctx context.Context, in *GetLeavesByRangeRequest, opts ...grpc.CallOption) (*GetLeavesByRangeResponse, error) {
	out := new(GetLeavesByRangeResponse)
	err := c.cc.Invoke(ctx, "/trillian.TrillianLog/GetLeavesByRange", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *trillianLogClient) GetLeavesByHash(ctx context.Context, in *GetLeavesByHashRequest, opts ...grpc.CallOption) (*GetLeavesByHashResponse, error) {
	out := new(GetLeavesByHashResponse)
	err := c.cc.Invoke(ctx, "/trillian.TrillianLog/GetLeavesByHash", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TrillianLogServer is the server API for TrillianLog service.
type TrillianLogServer interface {
	// QueueLeaf adds a single leaf to the queue of pending leaves for a normal
	// log.
	QueueLeaf(context.Context, *QueueLeafRequest) (*QueueLeafResponse, error)
	// AddSequencedLeaf adds a single leaf with an assigned sequence number to a
	// pre-ordered log.
	AddSequencedLeaf(context.Context, *AddSequencedLeafRequest) (*AddSequencedLeafResponse, error)
	// GetInclusionProof returns an inclusion proof for a leaf with a given index
	// in a particular tree.
	//
	// If the requested tree_size is larger than the server is aware of, the
	// response will include the latest known log root and an empty proof.
	GetInclusionProof(context.Context, *GetInclusionProofRequest) (*GetInclusionProofResponse, error)
	// GetInclusionProofByHash returns an inclusion proof for any leaves that have
	// the given Merkle hash in a particular tree.
	//
	// If any of the leaves that match the given Merkle has have a leaf index that
	// is beyond the requested tree size, the corresponding proof entry will be empty.
	GetInclusionProofByHash(context.Context, *GetInclusionProofByHashRequest) (*GetInclusionProofByHashResponse, error)
	// GetConsistencyProof returns a consistency proof between different sizes of
	// a particular tree.
	//
	// If the requested tree size is larger than the server is aware of,
	// the response will include the latest known log root and an empty proof.
	GetConsistencyProof(context.Context, *GetConsistencyProofRequest) (*GetConsistencyProofResponse, error)
	// GetLatestSignedLogRoot returns the latest signed log root for a given tree,
	// and optionally also includes a consistency proof from an earlier tree size
	// to the new size of the tree.
	//
	// If the earlier tree size is larger than the server is aware of,
	// an InvalidArgument error is returned.
	GetLatestSignedLogRoot(context.Context, *GetLatestSignedLogRootRequest) (*GetLatestSignedLogRootResponse, error)
	// GetSequencedLeafCount returns the total number of leaves that have been
	// integrated into the given tree.
	//
	// DO NOT USE - FOR DEBUGGING/TEST ONLY
	//
	// (Use GetLatestSignedLogRoot then de-serialize the Log Root and use
	// use the tree size field within.)
	GetSequencedLeafCount(context.Context, *GetSequencedLeafCountRequest) (*GetSequencedLeafCountResponse, error)
	// GetEntryAndProof returns a log leaf and the corresponding inclusion proof
	// to a specified tree size, for a given leaf index in a particular tree.
	//
	// If the requested tree size is unavailable but the leaf is
	// in scope for the current tree, the returned proof will be for the
	// current tree size rather than the requested tree size.
	GetEntryAndProof(context.Context, *GetEntryAndProofRequest) (*GetEntryAndProofResponse, error)
	// InitLog initializes a particular tree, creating the initial signed log
	// root (which will be of size 0).
	InitLog(context.Context, *InitLogRequest) (*InitLogResponse, error)
	// QueueLeaf adds a batch of leaves to the queue of pending leaves for a
	// normal log.
	QueueLeaves(context.Context, *QueueLeavesRequest) (*QueueLeavesResponse, error)
	// AddSequencedLeaves adds a batch of leaves with assigned sequence numbers
	// to a pre-ordered log.  The indices of the provided leaves must be contiguous.
	AddSequencedLeaves(context.Context, *AddSequencedLeavesRequest) (*AddSequencedLeavesResponse, error)
	// GetLeavesByIndex returns a batch of leaves whose leaf indices are provided
	// in the request.
	GetLeavesByIndex(context.Context, *GetLeavesByIndexRequest) (*GetLeavesByIndexResponse, error)
	// GetLeavesByRange returns a batch of leaves whose leaf indices are in a
	// sequential range.
	GetLeavesByRange(context.Context, *GetLeavesByRangeRequest) (*GetLeavesByRangeResponse, error)
	// GetLeavesByHash returns a batch of leaves which are identified by their
	// Merkle leaf hash values.
	GetLeavesByHash(context.Context, *GetLeavesByHashRequest) (*GetLeavesByHashResponse, error)
}

// UnimplementedTrillianLogServer can be embedded to have forward compatible implementations.
type UnimplementedTrillianLogServer struct {
}

func (*UnimplementedTrillianLogServer) QueueLeaf(ctx context.Context, req *QueueLeafRequest) (*QueueLeafResponse, error) {
	return nil, status1.Errorf(codes.Unimplemented, "method QueueLeaf not implemented")
}
func (*UnimplementedTrillianLogServer) AddSequencedLeaf(ctx context.Context, req *AddSequencedLeafRequest) (*AddSequencedLeafResponse, error) {
	return nil, status1.Errorf(codes.Unimplemented, "method AddSequencedLeaf not implemented")
}
func (*UnimplementedTrillianLogServer) GetInclusionProof(ctx context.Context, req *GetInclusionProofRequest) (*GetInclusionProofResponse, error) {
	return nil, status1.Errorf(codes.Unimplemented, "method GetInclusionProof not implemented")
}
func (*UnimplementedTrillianLogServer) GetInclusionProofByHash(ctx context.Context, req *GetInclusionProofByHashRequest) (*GetInclusionProofByHashResponse, error) {
	return nil, status1.Errorf(codes.Unimplemented, "method GetInclusionProofByHash not implemented")
}
func (*UnimplementedTrillianLogServer) GetConsistencyProof(ctx context.Context, req *GetConsistencyProofRequest) (*GetConsistencyProofResponse, error) {
	return nil, status1.Errorf(codes.Unimplemented, "method GetConsistencyProof not implemented")
}
func (*UnimplementedTrillianLogServer) GetLatestSignedLogRoot(ctx context.Context, req *GetLatestSignedLogRootRequest) (*GetLatestSignedLogRootResponse, error) {
	return nil, status1.Errorf(codes.Unimplemented, "method GetLatestSignedLogRoot not implemented")
}
func (*UnimplementedTrillianLogServer) GetSequencedLeafCount(ctx context.Context, req *GetSequencedLeafCountRequest) (*GetSequencedLeafCountResponse, error) {
	return nil, status1.Errorf(codes.Unimplemented, "method GetSequencedLeafCount not implemented")
}
func (*UnimplementedTrillianLogServer) GetEntryAndProof(ctx context.Context, req *GetEntryAndProofRequest) (*GetEntryAndProofResponse, error) {
	return nil, status1.Errorf(codes.Unimplemented, "method GetEntryAndProof not implemented")
}
func (*UnimplementedTrillianLogServer) InitLog(ctx context.Context, req *InitLogRequest) (*InitLogResponse, error) {
	return nil, status1.Errorf(codes.Unimplemented, "method InitLog not implemented")
}
func (*UnimplementedTrillianLogServer) QueueLeaves(ctx context.Context, req *QueueLeavesRequest) (*QueueLeavesResponse, error) {
	return nil, status1.Errorf(codes.Unimplemented, "method QueueLeaves not implemented")
}
func (*UnimplementedTrillianLogServer) AddSequencedLeaves(ctx context.Context, req *AddSequencedLeavesRequest) (*AddSequencedLeavesResponse, error) {
	return nil, status1.Errorf(codes.Unimplemented, "method AddSequencedLeaves not implemented")
}
func (*UnimplementedTrillianLogServer) GetLeavesByIndex(ctx context.Context, req *GetLeavesByIndexRequest) (*GetLeavesByIndexResponse, error) {
	return nil, status1.Errorf(codes.Unimplemented, "method GetLeavesByIndex not implemented")
}
func (*UnimplementedTrillianLogServer) GetLeavesByRange(ctx context.Context, req *GetLeavesByRangeRequest) (*GetLeavesByRangeResponse, error) {
	return nil, status1.Errorf(codes.Unimplemented, "method GetLeavesByRange not implemented")
}
func (*UnimplementedTrillianLogServer) GetLeavesByHash(ctx context.Context, req *GetLeavesByHashRequest) (*GetLeavesByHashResponse, error) {
	return nil, status1.Errorf(codes.Unimplemented, "method GetLeavesByHash not implemented")
}

func RegisterTrillianLogServer(s *grpc.Server, srv TrillianLogServer) {
	s.RegisterService(&_TrillianLog_serviceDesc, srv)
}

func _TrillianLog_QueueLeaf_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueueLeafRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TrillianLogServer).QueueLeaf(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/trillian.TrillianLog/QueueLeaf",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TrillianLogServer).QueueLeaf(ctx, req.(*QueueLeafRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TrillianLog_AddSequencedLeaf_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddSequencedLeafRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TrillianLogServer).AddSequencedLeaf(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/trillian.TrillianLog/AddSequencedLeaf",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TrillianLogServer).AddSequencedLeaf(ctx, req.(*AddSequencedLeafRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TrillianLog_GetInclusionProof_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetInclusionProofRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TrillianLogServer).GetInclusionProof(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/trillian.TrillianLog/GetInclusionProof",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TrillianLogServer).GetInclusionProof(ctx, req.(*GetInclusionProofRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TrillianLog_GetInclusionProofByHash_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetInclusionProofByHashRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TrillianLogServer).GetInclusionProofByHash(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/trillian.TrillianLog/GetInclusionProofByHash",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TrillianLogServer).GetInclusionProofByHash(ctx, req.(*GetInclusionProofByHashRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TrillianLog_GetConsistencyProof_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetConsistencyProofRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TrillianLogServer).GetConsistencyProof(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/trillian.TrillianLog/GetConsistencyProof",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TrillianLogServer).GetConsistencyProof(ctx, req.(*GetConsistencyProofRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TrillianLog_GetLatestSignedLogRoot_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetLatestSignedLogRootRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TrillianLogServer).GetLatestSignedLogRoot(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/trillian.TrillianLog/GetLatestSignedLogRoot",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TrillianLogServer).GetLatestSignedLogRoot(ctx, req.(*GetLatestSignedLogRootRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TrillianLog_GetSequencedLeafCount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSequencedLeafCountRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TrillianLogServer).GetSequencedLeafCount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/trillian.TrillianLog/GetSequencedLeafCount",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TrillianLogServer).GetSequencedLeafCount(ctx, req.(*GetSequencedLeafCountRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TrillianLog_GetEntryAndProof_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetEntryAndProofRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TrillianLogServer).GetEntryAndProof(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/trillian.TrillianLog/GetEntryAndProof",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TrillianLogServer).GetEntryAndProof(ctx, req.(*GetEntryAndProofRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TrillianLog_InitLog_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InitLogRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TrillianLogServer).InitLog(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/trillian.TrillianLog/InitLog",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TrillianLogServer).InitLog(ctx, req.(*InitLogRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TrillianLog_QueueLeaves_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueueLeavesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TrillianLogServer).QueueLeaves(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/trillian.TrillianLog/QueueLeaves",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TrillianLogServer).QueueLeaves(ctx, req.(*QueueLeavesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TrillianLog_AddSequencedLeaves_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddSequencedLeavesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TrillianLogServer).AddSequencedLeaves(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/trillian.TrillianLog/AddSequencedLeaves",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TrillianLogServer).AddSequencedLeaves(ctx, req.(*AddSequencedLeavesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TrillianLog_GetLeavesByIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetLeavesByIndexRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TrillianLogServer).GetLeavesByIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/trillian.TrillianLog/GetLeavesByIndex",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TrillianLogServer).GetLeavesByIndex(ctx, req.(*GetLeavesByIndexRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TrillianLog_GetLeavesByRange_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetLeavesByRangeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TrillianLogServer).GetLeavesByRange(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/trillian.TrillianLog/GetLeavesByRange",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TrillianLogServer).GetLeavesByRange(ctx, req.(*GetLeavesByRangeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TrillianLog_GetLeavesByHash_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetLeavesByHashRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TrillianLogServer).GetLeavesByHash(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/trillian.TrillianLog/GetLeavesByHash",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TrillianLogServer).GetLeavesByHash(ctx, req.(*GetLeavesByHashRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _TrillianLog_serviceDesc = grpc.ServiceDesc{
	ServiceName: "trillian.TrillianLog",
	HandlerType: (*TrillianLogServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "QueueLeaf",
			Handler:    _TrillianLog_QueueLeaf_Handler,
		},
		{
			MethodName: "AddSequencedLeaf",
			Handler:    _TrillianLog_AddSequencedLeaf_Handler,
		},
		{
			MethodName: "GetInclusionProof",
			Handler:    _TrillianLog_GetInclusionProof_Handler,
		},
		{
			MethodName: "GetInclusionProofByHash",
			Handler:    _TrillianLog_GetInclusionProofByHash_Handler,
		},
		{
			MethodName: "GetConsistencyProof",
			Handler:    _TrillianLog_GetConsistencyProof_Handler,
		},
		{
			MethodName: "GetLatestSignedLogRoot",
			Handler:    _TrillianLog_GetLatestSignedLogRoot_Handler,
		},
		{
			MethodName: "GetSequencedLeafCount",
			Handler:    _TrillianLog_GetSequencedLeafCount_Handler,
		},
		{
			MethodName: "GetEntryAndProof",
			Handler:    _TrillianLog_GetEntryAndProof_Handler,
		},
		{
			MethodName: "InitLog",
			Handler:    _TrillianLog_InitLog_Handler,
		},
		{
			MethodName: "QueueLeaves",
			Handler:    _TrillianLog_QueueLeaves_Handler,
		},
		{
			MethodName: "AddSequencedLeaves",
			Handler:    _TrillianLog_AddSequencedLeaves_Handler,
		},
		{
			MethodName: "GetLeavesByIndex",
			Handler:    _TrillianLog_GetLeavesByIndex_Handler,
		},
		{
			MethodName: "GetLeavesByRange",
			Handler:    _TrillianLog_GetLeavesByRange_Handler,
		},
		{
			MethodName: "GetLeavesByHash",
			Handler:    _TrillianLog_GetLeavesByHash_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "trillian_log_api.proto",
}
