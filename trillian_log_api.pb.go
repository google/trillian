// Code generated by protoc-gen-go. DO NOT EDIT.
// source: trillian_log_api.proto

/*
Package trillian is a generated protocol buffer package.

It is generated from these files:
	trillian_log_api.proto
	trillian_map_api.proto
	trillian_admin_api.proto
	trillian.proto

It has these top-level messages:
	LogLeaf
	Proof
	QueuedLogLeaf
	QueueLeavesRequest
	QueueLeafRequest
	QueueLeafResponse
	QueueLeavesResponse
	GetInclusionProofRequest
	GetInclusionProofResponse
	GetInclusionProofByHashRequest
	GetInclusionProofByHashResponse
	GetConsistencyProofRequest
	GetConsistencyProofResponse
	GetLeavesByHashRequest
	GetLeavesByHashResponse
	GetLeavesByIndexRequest
	GetLeavesByIndexResponse
	GetSequencedLeafCountRequest
	GetSequencedLeafCountResponse
	GetLatestSignedLogRootRequest
	GetLatestSignedLogRootResponse
	GetEntryAndProofRequest
	GetEntryAndProofResponse
	MapLeaf
	MapLeafInclusion
	GetMapLeavesRequest
	GetMapLeavesByRevisionRequest
	GetMapLeavesResponse
	SetMapLeavesRequest
	SetMapLeavesResponse
	GetSignedMapRootRequest
	GetSignedMapRootByRevisionRequest
	GetSignedMapRootResponse
	ListTreesRequest
	ListTreesResponse
	GetTreeRequest
	CreateTreeRequest
	UpdateTreeRequest
	DeleteTreeRequest
	UndeleteTreeRequest
	Tree
	SignedEntryTimestamp
	SignedLogRoot
	SignedMapRoot
*/
package trillian

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import google_rpc "google.golang.org/genproto/googleapis/rpc/status"
import _ "google.golang.org/genproto/googleapis/api/annotations"
import google_protobuf2 "github.com/golang/protobuf/ptypes/timestamp"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type LogLeaf struct {
	// merkle_leaf_hash is over leaf data and optional extra_data.
	MerkleLeafHash []byte `protobuf:"bytes,1,opt,name=merkle_leaf_hash,json=merkleLeafHash,proto3" json:"merkle_leaf_hash,omitempty"`
	// leaf_value contains arbitrary data.
	LeafValue []byte `protobuf:"bytes,2,opt,name=leaf_value,json=leafValue,proto3" json:"leaf_value,omitempty"`
	// extra_data is optional metadata. e.g. a timestamp.
	ExtraData []byte `protobuf:"bytes,3,opt,name=extra_data,json=extraData,proto3" json:"extra_data,omitempty"`
	// leaf_index is optional. Trillian will assign the next available index when unset.
	// TODO: remove this into separate AddSequencedLeaves API.
	LeafIndex int64 `protobuf:"varint,4,opt,name=leaf_index,json=leafIndex" json:"leaf_index,omitempty"`
	// leaf_identity_hash is a hash over the identity of this leaf.
	// It's intended to provide a mechanism for the personality to provide a
	// hint to Trillian that two leaves should be considered "duplicates" even
	// though their leaf_values differ.
	//
	// E.g. in a CT personality multiple add-chain calls for an identical
	// certificate would produce differing leaf_data bytes (due to the presence
	// of SCT elements), with just this information Trillian would be unable to
	// determine that, within the context of the personality, these entries are
	// dupes, so the CT personality sets leaf_identity_hash to H(cert),
	// which allows Trillian to detect the duplicates.
	//
	// Continuing the CT example, for a CT mirror personality (which must allow
	// dupes since the source log could contain them), the part of the
	// personality which fetches and submits the entries might set
	// leaf_identity_hash to H(seq||certdata).
	//
	// If leaf_identity_hash is empty, it's assumed to be the same as the
	// merkle_leaf_hash.
	LeafIdentityHash []byte `protobuf:"bytes,5,opt,name=leaf_identity_hash,json=leafIdentityHash,proto3" json:"leaf_identity_hash,omitempty"`
	// queue_timestamp records the time at which this leaf was first passed to QueueLeaves.
	// This value will be determined and set by the LogServer.
	QueueTimestamp *google_protobuf2.Timestamp `protobuf:"bytes,6,opt,name=queue_timestamp,json=queueTimestamp" json:"queue_timestamp,omitempty"`
	// integrate_timestamp records the time at which this leaf was integrated into the tree.
	// This value will be determined and set by the LogSigner.
	IntegrateTimestamp *google_protobuf2.Timestamp `protobuf:"bytes,7,opt,name=integrate_timestamp,json=integrateTimestamp" json:"integrate_timestamp,omitempty"`
}

func (m *LogLeaf) Reset()                    { *m = LogLeaf{} }
func (m *LogLeaf) String() string            { return proto.CompactTextString(m) }
func (*LogLeaf) ProtoMessage()               {}
func (*LogLeaf) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *LogLeaf) GetMerkleLeafHash() []byte {
	if m != nil {
		return m.MerkleLeafHash
	}
	return nil
}

func (m *LogLeaf) GetLeafValue() []byte {
	if m != nil {
		return m.LeafValue
	}
	return nil
}

func (m *LogLeaf) GetExtraData() []byte {
	if m != nil {
		return m.ExtraData
	}
	return nil
}

func (m *LogLeaf) GetLeafIndex() int64 {
	if m != nil {
		return m.LeafIndex
	}
	return 0
}

func (m *LogLeaf) GetLeafIdentityHash() []byte {
	if m != nil {
		return m.LeafIdentityHash
	}
	return nil
}

func (m *LogLeaf) GetQueueTimestamp() *google_protobuf2.Timestamp {
	if m != nil {
		return m.QueueTimestamp
	}
	return nil
}

func (m *LogLeaf) GetIntegrateTimestamp() *google_protobuf2.Timestamp {
	if m != nil {
		return m.IntegrateTimestamp
	}
	return nil
}

type Proof struct {
	LeafIndex int64    `protobuf:"varint,1,opt,name=leaf_index,json=leafIndex" json:"leaf_index,omitempty"`
	Hashes    [][]byte `protobuf:"bytes,3,rep,name=hashes,proto3" json:"hashes,omitempty"`
}

func (m *Proof) Reset()                    { *m = Proof{} }
func (m *Proof) String() string            { return proto.CompactTextString(m) }
func (*Proof) ProtoMessage()               {}
func (*Proof) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *Proof) GetLeafIndex() int64 {
	if m != nil {
		return m.LeafIndex
	}
	return 0
}

func (m *Proof) GetHashes() [][]byte {
	if m != nil {
		return m.Hashes
	}
	return nil
}

// QueuedLogLeaf represents a log leaf that has been queued for inclusion; it may
// be pending or already exist in the log (if the log does not allow duplicates).
type QueuedLogLeaf struct {
	// The leaf is present if status.code is:
	//  - google.rpc.OK : the leaf is the same as in the QueueLea{f,ves}Request
	//  - google.rpc.ALREADY_EXISTS : the leaf is the one already present in the log.
	Leaf   *LogLeaf           `protobuf:"bytes,1,opt,name=leaf" json:"leaf,omitempty"`
	Status *google_rpc.Status `protobuf:"bytes,2,opt,name=status" json:"status,omitempty"`
}

func (m *QueuedLogLeaf) Reset()                    { *m = QueuedLogLeaf{} }
func (m *QueuedLogLeaf) String() string            { return proto.CompactTextString(m) }
func (*QueuedLogLeaf) ProtoMessage()               {}
func (*QueuedLogLeaf) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *QueuedLogLeaf) GetLeaf() *LogLeaf {
	if m != nil {
		return m.Leaf
	}
	return nil
}

func (m *QueuedLogLeaf) GetStatus() *google_rpc.Status {
	if m != nil {
		return m.Status
	}
	return nil
}

type QueueLeavesRequest struct {
	LogId  int64      `protobuf:"varint,1,opt,name=log_id,json=logId" json:"log_id,omitempty"`
	Leaves []*LogLeaf `protobuf:"bytes,2,rep,name=leaves" json:"leaves,omitempty"`
}

func (m *QueueLeavesRequest) Reset()                    { *m = QueueLeavesRequest{} }
func (m *QueueLeavesRequest) String() string            { return proto.CompactTextString(m) }
func (*QueueLeavesRequest) ProtoMessage()               {}
func (*QueueLeavesRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *QueueLeavesRequest) GetLogId() int64 {
	if m != nil {
		return m.LogId
	}
	return 0
}

func (m *QueueLeavesRequest) GetLeaves() []*LogLeaf {
	if m != nil {
		return m.Leaves
	}
	return nil
}

type QueueLeafRequest struct {
	LogId int64    `protobuf:"varint,1,opt,name=log_id,json=logId" json:"log_id,omitempty"`
	Leaf  *LogLeaf `protobuf:"bytes,2,opt,name=leaf" json:"leaf,omitempty"`
}

func (m *QueueLeafRequest) Reset()                    { *m = QueueLeafRequest{} }
func (m *QueueLeafRequest) String() string            { return proto.CompactTextString(m) }
func (*QueueLeafRequest) ProtoMessage()               {}
func (*QueueLeafRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *QueueLeafRequest) GetLogId() int64 {
	if m != nil {
		return m.LogId
	}
	return 0
}

func (m *QueueLeafRequest) GetLeaf() *LogLeaf {
	if m != nil {
		return m.Leaf
	}
	return nil
}

type QueueLeafResponse struct {
	QueuedLeaf *QueuedLogLeaf `protobuf:"bytes,2,opt,name=queued_leaf,json=queuedLeaf" json:"queued_leaf,omitempty"`
}

func (m *QueueLeafResponse) Reset()                    { *m = QueueLeafResponse{} }
func (m *QueueLeafResponse) String() string            { return proto.CompactTextString(m) }
func (*QueueLeafResponse) ProtoMessage()               {}
func (*QueueLeafResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *QueueLeafResponse) GetQueuedLeaf() *QueuedLogLeaf {
	if m != nil {
		return m.QueuedLeaf
	}
	return nil
}

type QueueLeavesResponse struct {
	// Same number and order as in the corresponding request.
	QueuedLeaves []*QueuedLogLeaf `protobuf:"bytes,2,rep,name=queued_leaves,json=queuedLeaves" json:"queued_leaves,omitempty"`
}

func (m *QueueLeavesResponse) Reset()                    { *m = QueueLeavesResponse{} }
func (m *QueueLeavesResponse) String() string            { return proto.CompactTextString(m) }
func (*QueueLeavesResponse) ProtoMessage()               {}
func (*QueueLeavesResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *QueueLeavesResponse) GetQueuedLeaves() []*QueuedLogLeaf {
	if m != nil {
		return m.QueuedLeaves
	}
	return nil
}

type GetInclusionProofRequest struct {
	LogId     int64 `protobuf:"varint,1,opt,name=log_id,json=logId" json:"log_id,omitempty"`
	LeafIndex int64 `protobuf:"varint,2,opt,name=leaf_index,json=leafIndex" json:"leaf_index,omitempty"`
	TreeSize  int64 `protobuf:"varint,3,opt,name=tree_size,json=treeSize" json:"tree_size,omitempty"`
}

func (m *GetInclusionProofRequest) Reset()                    { *m = GetInclusionProofRequest{} }
func (m *GetInclusionProofRequest) String() string            { return proto.CompactTextString(m) }
func (*GetInclusionProofRequest) ProtoMessage()               {}
func (*GetInclusionProofRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *GetInclusionProofRequest) GetLogId() int64 {
	if m != nil {
		return m.LogId
	}
	return 0
}

func (m *GetInclusionProofRequest) GetLeafIndex() int64 {
	if m != nil {
		return m.LeafIndex
	}
	return 0
}

func (m *GetInclusionProofRequest) GetTreeSize() int64 {
	if m != nil {
		return m.TreeSize
	}
	return 0
}

type GetInclusionProofResponse struct {
	Proof *Proof `protobuf:"bytes,2,opt,name=proof" json:"proof,omitempty"`
}

func (m *GetInclusionProofResponse) Reset()                    { *m = GetInclusionProofResponse{} }
func (m *GetInclusionProofResponse) String() string            { return proto.CompactTextString(m) }
func (*GetInclusionProofResponse) ProtoMessage()               {}
func (*GetInclusionProofResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *GetInclusionProofResponse) GetProof() *Proof {
	if m != nil {
		return m.Proof
	}
	return nil
}

type GetInclusionProofByHashRequest struct {
	LogId           int64  `protobuf:"varint,1,opt,name=log_id,json=logId" json:"log_id,omitempty"`
	LeafHash        []byte `protobuf:"bytes,2,opt,name=leaf_hash,json=leafHash,proto3" json:"leaf_hash,omitempty"`
	TreeSize        int64  `protobuf:"varint,3,opt,name=tree_size,json=treeSize" json:"tree_size,omitempty"`
	OrderBySequence bool   `protobuf:"varint,4,opt,name=order_by_sequence,json=orderBySequence" json:"order_by_sequence,omitempty"`
}

func (m *GetInclusionProofByHashRequest) Reset()                    { *m = GetInclusionProofByHashRequest{} }
func (m *GetInclusionProofByHashRequest) String() string            { return proto.CompactTextString(m) }
func (*GetInclusionProofByHashRequest) ProtoMessage()               {}
func (*GetInclusionProofByHashRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *GetInclusionProofByHashRequest) GetLogId() int64 {
	if m != nil {
		return m.LogId
	}
	return 0
}

func (m *GetInclusionProofByHashRequest) GetLeafHash() []byte {
	if m != nil {
		return m.LeafHash
	}
	return nil
}

func (m *GetInclusionProofByHashRequest) GetTreeSize() int64 {
	if m != nil {
		return m.TreeSize
	}
	return 0
}

func (m *GetInclusionProofByHashRequest) GetOrderBySequence() bool {
	if m != nil {
		return m.OrderBySequence
	}
	return false
}

type GetInclusionProofByHashResponse struct {
	// Logs can potentially contain leaves with duplicate hashes so it's possible
	// for this to return multiple proofs.
	// TODO(gbelvin) only return one proof.
	Proof []*Proof `protobuf:"bytes,2,rep,name=proof" json:"proof,omitempty"`
}

func (m *GetInclusionProofByHashResponse) Reset()         { *m = GetInclusionProofByHashResponse{} }
func (m *GetInclusionProofByHashResponse) String() string { return proto.CompactTextString(m) }
func (*GetInclusionProofByHashResponse) ProtoMessage()    {}
func (*GetInclusionProofByHashResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{10}
}

func (m *GetInclusionProofByHashResponse) GetProof() []*Proof {
	if m != nil {
		return m.Proof
	}
	return nil
}

type GetConsistencyProofRequest struct {
	LogId          int64 `protobuf:"varint,1,opt,name=log_id,json=logId" json:"log_id,omitempty"`
	FirstTreeSize  int64 `protobuf:"varint,2,opt,name=first_tree_size,json=firstTreeSize" json:"first_tree_size,omitempty"`
	SecondTreeSize int64 `protobuf:"varint,3,opt,name=second_tree_size,json=secondTreeSize" json:"second_tree_size,omitempty"`
}

func (m *GetConsistencyProofRequest) Reset()                    { *m = GetConsistencyProofRequest{} }
func (m *GetConsistencyProofRequest) String() string            { return proto.CompactTextString(m) }
func (*GetConsistencyProofRequest) ProtoMessage()               {}
func (*GetConsistencyProofRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *GetConsistencyProofRequest) GetLogId() int64 {
	if m != nil {
		return m.LogId
	}
	return 0
}

func (m *GetConsistencyProofRequest) GetFirstTreeSize() int64 {
	if m != nil {
		return m.FirstTreeSize
	}
	return 0
}

func (m *GetConsistencyProofRequest) GetSecondTreeSize() int64 {
	if m != nil {
		return m.SecondTreeSize
	}
	return 0
}

type GetConsistencyProofResponse struct {
	Proof *Proof `protobuf:"bytes,2,opt,name=proof" json:"proof,omitempty"`
}

func (m *GetConsistencyProofResponse) Reset()                    { *m = GetConsistencyProofResponse{} }
func (m *GetConsistencyProofResponse) String() string            { return proto.CompactTextString(m) }
func (*GetConsistencyProofResponse) ProtoMessage()               {}
func (*GetConsistencyProofResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *GetConsistencyProofResponse) GetProof() *Proof {
	if m != nil {
		return m.Proof
	}
	return nil
}

type GetLeavesByHashRequest struct {
	LogId           int64    `protobuf:"varint,1,opt,name=log_id,json=logId" json:"log_id,omitempty"`
	LeafHash        [][]byte `protobuf:"bytes,2,rep,name=leaf_hash,json=leafHash,proto3" json:"leaf_hash,omitempty"`
	OrderBySequence bool     `protobuf:"varint,3,opt,name=order_by_sequence,json=orderBySequence" json:"order_by_sequence,omitempty"`
}

func (m *GetLeavesByHashRequest) Reset()                    { *m = GetLeavesByHashRequest{} }
func (m *GetLeavesByHashRequest) String() string            { return proto.CompactTextString(m) }
func (*GetLeavesByHashRequest) ProtoMessage()               {}
func (*GetLeavesByHashRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *GetLeavesByHashRequest) GetLogId() int64 {
	if m != nil {
		return m.LogId
	}
	return 0
}

func (m *GetLeavesByHashRequest) GetLeafHash() [][]byte {
	if m != nil {
		return m.LeafHash
	}
	return nil
}

func (m *GetLeavesByHashRequest) GetOrderBySequence() bool {
	if m != nil {
		return m.OrderBySequence
	}
	return false
}

type GetLeavesByHashResponse struct {
	// TODO(gbelvin) reply with error codes.
	Leaves []*LogLeaf `protobuf:"bytes,2,rep,name=leaves" json:"leaves,omitempty"`
}

func (m *GetLeavesByHashResponse) Reset()                    { *m = GetLeavesByHashResponse{} }
func (m *GetLeavesByHashResponse) String() string            { return proto.CompactTextString(m) }
func (*GetLeavesByHashResponse) ProtoMessage()               {}
func (*GetLeavesByHashResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

func (m *GetLeavesByHashResponse) GetLeaves() []*LogLeaf {
	if m != nil {
		return m.Leaves
	}
	return nil
}

type GetLeavesByIndexRequest struct {
	LogId     int64   `protobuf:"varint,1,opt,name=log_id,json=logId" json:"log_id,omitempty"`
	LeafIndex []int64 `protobuf:"varint,2,rep,packed,name=leaf_index,json=leafIndex" json:"leaf_index,omitempty"`
}

func (m *GetLeavesByIndexRequest) Reset()                    { *m = GetLeavesByIndexRequest{} }
func (m *GetLeavesByIndexRequest) String() string            { return proto.CompactTextString(m) }
func (*GetLeavesByIndexRequest) ProtoMessage()               {}
func (*GetLeavesByIndexRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

func (m *GetLeavesByIndexRequest) GetLogId() int64 {
	if m != nil {
		return m.LogId
	}
	return 0
}

func (m *GetLeavesByIndexRequest) GetLeafIndex() []int64 {
	if m != nil {
		return m.LeafIndex
	}
	return nil
}

type GetLeavesByIndexResponse struct {
	// TODO(gbelvin) reply with error codes.
	Leaves []*LogLeaf `protobuf:"bytes,2,rep,name=leaves" json:"leaves,omitempty"`
}

func (m *GetLeavesByIndexResponse) Reset()                    { *m = GetLeavesByIndexResponse{} }
func (m *GetLeavesByIndexResponse) String() string            { return proto.CompactTextString(m) }
func (*GetLeavesByIndexResponse) ProtoMessage()               {}
func (*GetLeavesByIndexResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{16} }

func (m *GetLeavesByIndexResponse) GetLeaves() []*LogLeaf {
	if m != nil {
		return m.Leaves
	}
	return nil
}

type GetSequencedLeafCountRequest struct {
	LogId int64 `protobuf:"varint,1,opt,name=log_id,json=logId" json:"log_id,omitempty"`
}

func (m *GetSequencedLeafCountRequest) Reset()                    { *m = GetSequencedLeafCountRequest{} }
func (m *GetSequencedLeafCountRequest) String() string            { return proto.CompactTextString(m) }
func (*GetSequencedLeafCountRequest) ProtoMessage()               {}
func (*GetSequencedLeafCountRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{17} }

func (m *GetSequencedLeafCountRequest) GetLogId() int64 {
	if m != nil {
		return m.LogId
	}
	return 0
}

type GetSequencedLeafCountResponse struct {
	LeafCount int64 `protobuf:"varint,2,opt,name=leaf_count,json=leafCount" json:"leaf_count,omitempty"`
}

func (m *GetSequencedLeafCountResponse) Reset()                    { *m = GetSequencedLeafCountResponse{} }
func (m *GetSequencedLeafCountResponse) String() string            { return proto.CompactTextString(m) }
func (*GetSequencedLeafCountResponse) ProtoMessage()               {}
func (*GetSequencedLeafCountResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{18} }

func (m *GetSequencedLeafCountResponse) GetLeafCount() int64 {
	if m != nil {
		return m.LeafCount
	}
	return 0
}

type GetLatestSignedLogRootRequest struct {
	LogId int64 `protobuf:"varint,1,opt,name=log_id,json=logId" json:"log_id,omitempty"`
}

func (m *GetLatestSignedLogRootRequest) Reset()                    { *m = GetLatestSignedLogRootRequest{} }
func (m *GetLatestSignedLogRootRequest) String() string            { return proto.CompactTextString(m) }
func (*GetLatestSignedLogRootRequest) ProtoMessage()               {}
func (*GetLatestSignedLogRootRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{19} }

func (m *GetLatestSignedLogRootRequest) GetLogId() int64 {
	if m != nil {
		return m.LogId
	}
	return 0
}

type GetLatestSignedLogRootResponse struct {
	SignedLogRoot *SignedLogRoot `protobuf:"bytes,2,opt,name=signed_log_root,json=signedLogRoot" json:"signed_log_root,omitempty"`
}

func (m *GetLatestSignedLogRootResponse) Reset()                    { *m = GetLatestSignedLogRootResponse{} }
func (m *GetLatestSignedLogRootResponse) String() string            { return proto.CompactTextString(m) }
func (*GetLatestSignedLogRootResponse) ProtoMessage()               {}
func (*GetLatestSignedLogRootResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{20} }

func (m *GetLatestSignedLogRootResponse) GetSignedLogRoot() *SignedLogRoot {
	if m != nil {
		return m.SignedLogRoot
	}
	return nil
}

type GetEntryAndProofRequest struct {
	LogId     int64 `protobuf:"varint,1,opt,name=log_id,json=logId" json:"log_id,omitempty"`
	LeafIndex int64 `protobuf:"varint,2,opt,name=leaf_index,json=leafIndex" json:"leaf_index,omitempty"`
	TreeSize  int64 `protobuf:"varint,3,opt,name=tree_size,json=treeSize" json:"tree_size,omitempty"`
}

func (m *GetEntryAndProofRequest) Reset()                    { *m = GetEntryAndProofRequest{} }
func (m *GetEntryAndProofRequest) String() string            { return proto.CompactTextString(m) }
func (*GetEntryAndProofRequest) ProtoMessage()               {}
func (*GetEntryAndProofRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{21} }

func (m *GetEntryAndProofRequest) GetLogId() int64 {
	if m != nil {
		return m.LogId
	}
	return 0
}

func (m *GetEntryAndProofRequest) GetLeafIndex() int64 {
	if m != nil {
		return m.LeafIndex
	}
	return 0
}

func (m *GetEntryAndProofRequest) GetTreeSize() int64 {
	if m != nil {
		return m.TreeSize
	}
	return 0
}

type GetEntryAndProofResponse struct {
	Proof *Proof   `protobuf:"bytes,2,opt,name=proof" json:"proof,omitempty"`
	Leaf  *LogLeaf `protobuf:"bytes,3,opt,name=leaf" json:"leaf,omitempty"`
}

func (m *GetEntryAndProofResponse) Reset()                    { *m = GetEntryAndProofResponse{} }
func (m *GetEntryAndProofResponse) String() string            { return proto.CompactTextString(m) }
func (*GetEntryAndProofResponse) ProtoMessage()               {}
func (*GetEntryAndProofResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{22} }

func (m *GetEntryAndProofResponse) GetProof() *Proof {
	if m != nil {
		return m.Proof
	}
	return nil
}

func (m *GetEntryAndProofResponse) GetLeaf() *LogLeaf {
	if m != nil {
		return m.Leaf
	}
	return nil
}

func init() {
	proto.RegisterType((*LogLeaf)(nil), "trillian.LogLeaf")
	proto.RegisterType((*Proof)(nil), "trillian.Proof")
	proto.RegisterType((*QueuedLogLeaf)(nil), "trillian.QueuedLogLeaf")
	proto.RegisterType((*QueueLeavesRequest)(nil), "trillian.QueueLeavesRequest")
	proto.RegisterType((*QueueLeafRequest)(nil), "trillian.QueueLeafRequest")
	proto.RegisterType((*QueueLeafResponse)(nil), "trillian.QueueLeafResponse")
	proto.RegisterType((*QueueLeavesResponse)(nil), "trillian.QueueLeavesResponse")
	proto.RegisterType((*GetInclusionProofRequest)(nil), "trillian.GetInclusionProofRequest")
	proto.RegisterType((*GetInclusionProofResponse)(nil), "trillian.GetInclusionProofResponse")
	proto.RegisterType((*GetInclusionProofByHashRequest)(nil), "trillian.GetInclusionProofByHashRequest")
	proto.RegisterType((*GetInclusionProofByHashResponse)(nil), "trillian.GetInclusionProofByHashResponse")
	proto.RegisterType((*GetConsistencyProofRequest)(nil), "trillian.GetConsistencyProofRequest")
	proto.RegisterType((*GetConsistencyProofResponse)(nil), "trillian.GetConsistencyProofResponse")
	proto.RegisterType((*GetLeavesByHashRequest)(nil), "trillian.GetLeavesByHashRequest")
	proto.RegisterType((*GetLeavesByHashResponse)(nil), "trillian.GetLeavesByHashResponse")
	proto.RegisterType((*GetLeavesByIndexRequest)(nil), "trillian.GetLeavesByIndexRequest")
	proto.RegisterType((*GetLeavesByIndexResponse)(nil), "trillian.GetLeavesByIndexResponse")
	proto.RegisterType((*GetSequencedLeafCountRequest)(nil), "trillian.GetSequencedLeafCountRequest")
	proto.RegisterType((*GetSequencedLeafCountResponse)(nil), "trillian.GetSequencedLeafCountResponse")
	proto.RegisterType((*GetLatestSignedLogRootRequest)(nil), "trillian.GetLatestSignedLogRootRequest")
	proto.RegisterType((*GetLatestSignedLogRootResponse)(nil), "trillian.GetLatestSignedLogRootResponse")
	proto.RegisterType((*GetEntryAndProofRequest)(nil), "trillian.GetEntryAndProofRequest")
	proto.RegisterType((*GetEntryAndProofResponse)(nil), "trillian.GetEntryAndProofResponse")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for TrillianLog service

type TrillianLogClient interface {
	// QueueLeaf adds a single leaf to the queue.
	QueueLeaf(ctx context.Context, in *QueueLeafRequest, opts ...grpc.CallOption) (*QueueLeafResponse, error)
	// No direct equivalent at the storage level
	GetInclusionProof(ctx context.Context, in *GetInclusionProofRequest, opts ...grpc.CallOption) (*GetInclusionProofResponse, error)
	GetInclusionProofByHash(ctx context.Context, in *GetInclusionProofByHashRequest, opts ...grpc.CallOption) (*GetInclusionProofByHashResponse, error)
	GetConsistencyProof(ctx context.Context, in *GetConsistencyProofRequest, opts ...grpc.CallOption) (*GetConsistencyProofResponse, error)
	// Corresponds to the LogRootReader API
	GetLatestSignedLogRoot(ctx context.Context, in *GetLatestSignedLogRootRequest, opts ...grpc.CallOption) (*GetLatestSignedLogRootResponse, error)
	// Corresponds to the LeafReader API
	GetSequencedLeafCount(ctx context.Context, in *GetSequencedLeafCountRequest, opts ...grpc.CallOption) (*GetSequencedLeafCountResponse, error)
	GetEntryAndProof(ctx context.Context, in *GetEntryAndProofRequest, opts ...grpc.CallOption) (*GetEntryAndProofResponse, error)
	// Corresponds to the LeafQueuer API
	QueueLeaves(ctx context.Context, in *QueueLeavesRequest, opts ...grpc.CallOption) (*QueueLeavesResponse, error)
	GetLeavesByIndex(ctx context.Context, in *GetLeavesByIndexRequest, opts ...grpc.CallOption) (*GetLeavesByIndexResponse, error)
	GetLeavesByHash(ctx context.Context, in *GetLeavesByHashRequest, opts ...grpc.CallOption) (*GetLeavesByHashResponse, error)
}

type trillianLogClient struct {
	cc *grpc.ClientConn
}

func NewTrillianLogClient(cc *grpc.ClientConn) TrillianLogClient {
	return &trillianLogClient{cc}
}

func (c *trillianLogClient) QueueLeaf(ctx context.Context, in *QueueLeafRequest, opts ...grpc.CallOption) (*QueueLeafResponse, error) {
	out := new(QueueLeafResponse)
	err := grpc.Invoke(ctx, "/trillian.TrillianLog/QueueLeaf", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *trillianLogClient) GetInclusionProof(ctx context.Context, in *GetInclusionProofRequest, opts ...grpc.CallOption) (*GetInclusionProofResponse, error) {
	out := new(GetInclusionProofResponse)
	err := grpc.Invoke(ctx, "/trillian.TrillianLog/GetInclusionProof", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *trillianLogClient) GetInclusionProofByHash(ctx context.Context, in *GetInclusionProofByHashRequest, opts ...grpc.CallOption) (*GetInclusionProofByHashResponse, error) {
	out := new(GetInclusionProofByHashResponse)
	err := grpc.Invoke(ctx, "/trillian.TrillianLog/GetInclusionProofByHash", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *trillianLogClient) GetConsistencyProof(ctx context.Context, in *GetConsistencyProofRequest, opts ...grpc.CallOption) (*GetConsistencyProofResponse, error) {
	out := new(GetConsistencyProofResponse)
	err := grpc.Invoke(ctx, "/trillian.TrillianLog/GetConsistencyProof", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *trillianLogClient) GetLatestSignedLogRoot(ctx context.Context, in *GetLatestSignedLogRootRequest, opts ...grpc.CallOption) (*GetLatestSignedLogRootResponse, error) {
	out := new(GetLatestSignedLogRootResponse)
	err := grpc.Invoke(ctx, "/trillian.TrillianLog/GetLatestSignedLogRoot", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *trillianLogClient) GetSequencedLeafCount(ctx context.Context, in *GetSequencedLeafCountRequest, opts ...grpc.CallOption) (*GetSequencedLeafCountResponse, error) {
	out := new(GetSequencedLeafCountResponse)
	err := grpc.Invoke(ctx, "/trillian.TrillianLog/GetSequencedLeafCount", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *trillianLogClient) GetEntryAndProof(ctx context.Context, in *GetEntryAndProofRequest, opts ...grpc.CallOption) (*GetEntryAndProofResponse, error) {
	out := new(GetEntryAndProofResponse)
	err := grpc.Invoke(ctx, "/trillian.TrillianLog/GetEntryAndProof", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *trillianLogClient) QueueLeaves(ctx context.Context, in *QueueLeavesRequest, opts ...grpc.CallOption) (*QueueLeavesResponse, error) {
	out := new(QueueLeavesResponse)
	err := grpc.Invoke(ctx, "/trillian.TrillianLog/QueueLeaves", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *trillianLogClient) GetLeavesByIndex(ctx context.Context, in *GetLeavesByIndexRequest, opts ...grpc.CallOption) (*GetLeavesByIndexResponse, error) {
	out := new(GetLeavesByIndexResponse)
	err := grpc.Invoke(ctx, "/trillian.TrillianLog/GetLeavesByIndex", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *trillianLogClient) GetLeavesByHash(ctx context.Context, in *GetLeavesByHashRequest, opts ...grpc.CallOption) (*GetLeavesByHashResponse, error) {
	out := new(GetLeavesByHashResponse)
	err := grpc.Invoke(ctx, "/trillian.TrillianLog/GetLeavesByHash", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for TrillianLog service

type TrillianLogServer interface {
	// QueueLeaf adds a single leaf to the queue.
	QueueLeaf(context.Context, *QueueLeafRequest) (*QueueLeafResponse, error)
	// No direct equivalent at the storage level
	GetInclusionProof(context.Context, *GetInclusionProofRequest) (*GetInclusionProofResponse, error)
	GetInclusionProofByHash(context.Context, *GetInclusionProofByHashRequest) (*GetInclusionProofByHashResponse, error)
	GetConsistencyProof(context.Context, *GetConsistencyProofRequest) (*GetConsistencyProofResponse, error)
	// Corresponds to the LogRootReader API
	GetLatestSignedLogRoot(context.Context, *GetLatestSignedLogRootRequest) (*GetLatestSignedLogRootResponse, error)
	// Corresponds to the LeafReader API
	GetSequencedLeafCount(context.Context, *GetSequencedLeafCountRequest) (*GetSequencedLeafCountResponse, error)
	GetEntryAndProof(context.Context, *GetEntryAndProofRequest) (*GetEntryAndProofResponse, error)
	// Corresponds to the LeafQueuer API
	QueueLeaves(context.Context, *QueueLeavesRequest) (*QueueLeavesResponse, error)
	GetLeavesByIndex(context.Context, *GetLeavesByIndexRequest) (*GetLeavesByIndexResponse, error)
	GetLeavesByHash(context.Context, *GetLeavesByHashRequest) (*GetLeavesByHashResponse, error)
}

func RegisterTrillianLogServer(s *grpc.Server, srv TrillianLogServer) {
	s.RegisterService(&_TrillianLog_serviceDesc, srv)
}

func _TrillianLog_QueueLeaf_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueueLeafRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TrillianLogServer).QueueLeaf(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/trillian.TrillianLog/QueueLeaf",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TrillianLogServer).QueueLeaf(ctx, req.(*QueueLeafRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TrillianLog_GetInclusionProof_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetInclusionProofRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TrillianLogServer).GetInclusionProof(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/trillian.TrillianLog/GetInclusionProof",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TrillianLogServer).GetInclusionProof(ctx, req.(*GetInclusionProofRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TrillianLog_GetInclusionProofByHash_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetInclusionProofByHashRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TrillianLogServer).GetInclusionProofByHash(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/trillian.TrillianLog/GetInclusionProofByHash",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TrillianLogServer).GetInclusionProofByHash(ctx, req.(*GetInclusionProofByHashRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TrillianLog_GetConsistencyProof_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetConsistencyProofRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TrillianLogServer).GetConsistencyProof(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/trillian.TrillianLog/GetConsistencyProof",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TrillianLogServer).GetConsistencyProof(ctx, req.(*GetConsistencyProofRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TrillianLog_GetLatestSignedLogRoot_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetLatestSignedLogRootRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TrillianLogServer).GetLatestSignedLogRoot(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/trillian.TrillianLog/GetLatestSignedLogRoot",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TrillianLogServer).GetLatestSignedLogRoot(ctx, req.(*GetLatestSignedLogRootRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TrillianLog_GetSequencedLeafCount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSequencedLeafCountRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TrillianLogServer).GetSequencedLeafCount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/trillian.TrillianLog/GetSequencedLeafCount",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TrillianLogServer).GetSequencedLeafCount(ctx, req.(*GetSequencedLeafCountRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TrillianLog_GetEntryAndProof_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetEntryAndProofRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TrillianLogServer).GetEntryAndProof(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/trillian.TrillianLog/GetEntryAndProof",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TrillianLogServer).GetEntryAndProof(ctx, req.(*GetEntryAndProofRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TrillianLog_QueueLeaves_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueueLeavesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TrillianLogServer).QueueLeaves(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/trillian.TrillianLog/QueueLeaves",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TrillianLogServer).QueueLeaves(ctx, req.(*QueueLeavesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TrillianLog_GetLeavesByIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetLeavesByIndexRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TrillianLogServer).GetLeavesByIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/trillian.TrillianLog/GetLeavesByIndex",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TrillianLogServer).GetLeavesByIndex(ctx, req.(*GetLeavesByIndexRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TrillianLog_GetLeavesByHash_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetLeavesByHashRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TrillianLogServer).GetLeavesByHash(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/trillian.TrillianLog/GetLeavesByHash",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TrillianLogServer).GetLeavesByHash(ctx, req.(*GetLeavesByHashRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _TrillianLog_serviceDesc = grpc.ServiceDesc{
	ServiceName: "trillian.TrillianLog",
	HandlerType: (*TrillianLogServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "QueueLeaf",
			Handler:    _TrillianLog_QueueLeaf_Handler,
		},
		{
			MethodName: "GetInclusionProof",
			Handler:    _TrillianLog_GetInclusionProof_Handler,
		},
		{
			MethodName: "GetInclusionProofByHash",
			Handler:    _TrillianLog_GetInclusionProofByHash_Handler,
		},
		{
			MethodName: "GetConsistencyProof",
			Handler:    _TrillianLog_GetConsistencyProof_Handler,
		},
		{
			MethodName: "GetLatestSignedLogRoot",
			Handler:    _TrillianLog_GetLatestSignedLogRoot_Handler,
		},
		{
			MethodName: "GetSequencedLeafCount",
			Handler:    _TrillianLog_GetSequencedLeafCount_Handler,
		},
		{
			MethodName: "GetEntryAndProof",
			Handler:    _TrillianLog_GetEntryAndProof_Handler,
		},
		{
			MethodName: "QueueLeaves",
			Handler:    _TrillianLog_QueueLeaves_Handler,
		},
		{
			MethodName: "GetLeavesByIndex",
			Handler:    _TrillianLog_GetLeavesByIndex_Handler,
		},
		{
			MethodName: "GetLeavesByHash",
			Handler:    _TrillianLog_GetLeavesByHash_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "trillian_log_api.proto",
}

func init() { proto.RegisterFile("trillian_log_api.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 1197 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x57, 0xdf, 0x6e, 0xdb, 0x54,
	0x18, 0x9f, 0xe3, 0x36, 0x6b, 0xbf, 0xb4, 0x4d, 0x7a, 0xaa, 0xb5, 0x99, 0xdb, 0xb2, 0xcc, 0xa3,
	0x5b, 0x56, 0x46, 0x4c, 0x8b, 0x06, 0xa8, 0x9a, 0x40, 0x4b, 0x3b, 0x75, 0x85, 0x00, 0x25, 0xad,
	0x26, 0x04, 0x17, 0xd6, 0x49, 0x72, 0x92, 0x5a, 0x38, 0x3e, 0x99, 0xcf, 0x49, 0xd5, 0x6e, 0xda,
	0x0d, 0x12, 0x97, 0x5c, 0xc1, 0x05, 0x37, 0x08, 0xee, 0x78, 0x00, 0x5e, 0x04, 0x89, 0x57, 0xe0,
	0x41, 0x90, 0xcf, 0x39, 0x4e, 0x62, 0xc7, 0x71, 0x5a, 0x24, 0xee, 0xe2, 0xef, 0xef, 0xef, 0xe7,
	0xef, 0x7c, 0xbf, 0xe3, 0xc0, 0x2a, 0xf7, 0x1d, 0xd7, 0x75, 0xb0, 0x67, 0xbb, 0xb4, 0x63, 0xe3,
	0x9e, 0x53, 0xe9, 0xf9, 0x94, 0x53, 0x34, 0x17, 0xda, 0x8d, 0xa5, 0xf0, 0x97, 0xf4, 0x18, 0x6b,
	0x1d, 0x4a, 0x3b, 0x2e, 0xb1, 0xfc, 0x5e, 0xd3, 0x62, 0x1c, 0xf3, 0x3e, 0x53, 0x8e, 0x0d, 0xe5,
	0xc0, 0x3d, 0xc7, 0xc2, 0x9e, 0x47, 0x39, 0xe6, 0x0e, 0xf5, 0x42, 0xef, 0x1d, 0xe5, 0x15, 0x4f,
	0x8d, 0x7e, 0xdb, 0xe2, 0x4e, 0x97, 0x30, 0x8e, 0xbb, 0x3d, 0x19, 0x60, 0xfe, 0x95, 0x81, 0x9b,
	0x35, 0xda, 0xa9, 0x11, 0xdc, 0x46, 0x65, 0x28, 0x74, 0x89, 0xff, 0x9d, 0x4b, 0x6c, 0x97, 0xe0,
	0xb6, 0x7d, 0x86, 0xd9, 0x59, 0x51, 0x2b, 0x69, 0xe5, 0x85, 0xfa, 0x92, 0xb4, 0x07, 0x51, 0xcf,
	0x31, 0x3b, 0x43, 0x9b, 0x00, 0x22, 0xe4, 0x1c, 0xbb, 0x7d, 0x52, 0xcc, 0x88, 0x98, 0xf9, 0xc0,
	0xf2, 0x22, 0x30, 0x04, 0x6e, 0x72, 0xc1, 0x7d, 0x6c, 0xb7, 0x30, 0xc7, 0x45, 0x5d, 0xba, 0x85,
	0xe5, 0x00, 0x73, 0x3c, 0xc8, 0x76, 0xbc, 0x16, 0xb9, 0x28, 0xce, 0x94, 0xb4, 0xb2, 0x2e, 0xb3,
	0x8f, 0x02, 0x03, 0x7a, 0x04, 0x48, 0xba, 0x5b, 0xc4, 0xe3, 0x0e, 0xbf, 0x94, 0x40, 0x66, 0x45,
	0x95, 0x82, 0x08, 0x53, 0x0e, 0x01, 0x65, 0x1f, 0xf2, 0x2f, 0xfb, 0xa4, 0x4f, 0xec, 0x01, 0xb3,
	0x62, 0xb6, 0xa4, 0x95, 0x73, 0xbb, 0x46, 0x45, 0x72, 0xaf, 0x84, 0xdc, 0x2b, 0xa7, 0x61, 0x44,
	0x7d, 0x49, 0xa4, 0x0c, 0x9e, 0xd1, 0x67, 0xb0, 0xe2, 0x78, 0x9c, 0x74, 0x7c, 0xcc, 0x47, 0x0b,
	0xdd, 0x9c, 0x5a, 0x08, 0x0d, 0xd2, 0x06, 0x36, 0xf3, 0x00, 0x66, 0x8f, 0x7d, 0x4a, 0xdb, 0x31,
	0x9e, 0x5a, 0x9c, 0xe7, 0x2a, 0x64, 0x03, 0x66, 0x84, 0x15, 0xf5, 0x92, 0x5e, 0x5e, 0xa8, 0xab,
	0xa7, 0x4f, 0x67, 0xe6, 0x32, 0x05, 0xdd, 0x6c, 0xc0, 0xe2, 0x57, 0x01, 0xc8, 0x56, 0x38, 0x9d,
	0x2d, 0x98, 0x09, 0x72, 0x45, 0x9d, 0xdc, 0xee, 0x72, 0x65, 0x70, 0x40, 0x54, 0x40, 0x5d, 0xb8,
	0xd1, 0x36, 0x64, 0xe5, 0xf9, 0x10, 0x63, 0xc9, 0xed, 0xa2, 0x10, 0xbd, 0xdf, 0x6b, 0x56, 0x4e,
	0x84, 0xa7, 0xae, 0x22, 0xcc, 0x17, 0x80, 0x44, 0x8f, 0x1a, 0xc1, 0xe7, 0x84, 0xd5, 0xc9, 0xcb,
	0x3e, 0x61, 0x1c, 0xdd, 0x82, 0x6c, 0x70, 0x2a, 0x9d, 0x96, 0x82, 0x3c, 0xeb, 0xd2, 0xce, 0x51,
	0x0b, 0x3d, 0x84, 0xac, 0x2b, 0xe2, 0x8a, 0x99, 0x92, 0x9e, 0x8c, 0x40, 0x05, 0x98, 0xc7, 0x50,
	0x08, 0xeb, 0xb6, 0xa7, 0x54, 0x0d, 0x59, 0x65, 0x52, 0x59, 0x99, 0x9f, 0xc3, 0xf2, 0x48, 0x45,
	0xd6, 0xa3, 0x1e, 0x23, 0xe8, 0x23, 0xc8, 0x89, 0x39, 0xb6, 0xec, 0x91, 0x12, 0x6b, 0xc3, 0x12,
	0x91, 0xf7, 0x57, 0x07, 0x19, 0x1b, 0xfc, 0x36, 0x4f, 0x60, 0x25, 0x42, 0x5c, 0x15, 0x7c, 0x02,
	0x8b, 0xc3, 0x82, 0x43, 0xa6, 0x13, 0x4b, 0x2e, 0x0c, 0x4a, 0x06, 0xac, 0xbb, 0x50, 0x3c, 0x24,
	0xfc, 0xc8, 0x6b, 0xba, 0x7d, 0xe6, 0x50, 0x4f, 0x9c, 0x81, 0x29, 0xec, 0xa3, 0x27, 0x24, 0x13,
	0x3f, 0x21, 0xeb, 0x30, 0xcf, 0x7d, 0x42, 0x6c, 0xe6, 0xbc, 0x22, 0x62, 0x8d, 0xf4, 0xfa, 0x5c,
	0x60, 0x38, 0x71, 0x5e, 0x11, 0xb3, 0x0a, 0xb7, 0x13, 0xda, 0x29, 0x26, 0x5b, 0x30, 0xdb, 0x0b,
	0x0c, 0xea, 0xa5, 0xe4, 0x87, 0x0c, 0x64, 0x9c, 0xf4, 0x9a, 0xbf, 0x6a, 0xf0, 0xd6, 0x58, 0x91,
	0xaa, 0x58, 0xac, 0x29, 0xc8, 0xd7, 0x61, 0x7e, 0x28, 0x12, 0x52, 0x00, 0xe6, 0xdc, 0x50, 0x1e,
	0xd2, 0x70, 0xa3, 0x6d, 0x58, 0xa6, 0x7e, 0x8b, 0xf8, 0x76, 0xe3, 0xd2, 0x66, 0x41, 0x13, 0xaf,
	0x49, 0x84, 0x08, 0xcc, 0xd5, 0xf3, 0xc2, 0x51, 0xbd, 0x3c, 0x51, 0x66, 0xf3, 0x39, 0xdc, 0x99,
	0x08, 0x6f, 0x9c, 0xa9, 0x9e, 0xc2, 0xf4, 0x07, 0x0d, 0x8c, 0x43, 0xc2, 0xf7, 0xa9, 0xc7, 0x1c,
	0xc6, 0x89, 0xd7, 0xbc, 0xbc, 0xca, 0x7c, 0xee, 0x43, 0xbe, 0xed, 0xf8, 0x8c, 0xdb, 0x43, 0x3a,
	0x72, 0x48, 0x8b, 0xc2, 0x7c, 0x1a, 0x72, 0x2a, 0x43, 0x81, 0x91, 0x26, 0xf5, 0x5a, 0x76, 0x9c,
	0xf7, 0x92, 0xb4, 0x87, 0x91, 0xe6, 0x01, 0xac, 0x27, 0xc2, 0xb8, 0xde, 0xdc, 0x2e, 0x60, 0xf5,
	0x90, 0x70, 0x79, 0xee, 0xfe, 0xcb, 0xb8, 0xf4, 0xc8, 0xb8, 0x12, 0x27, 0xa2, 0x27, 0x4f, 0xe4,
	0x00, 0xd6, 0xc6, 0x3a, 0x2b, 0xec, 0xd7, 0x10, 0x88, 0x2f, 0x23, 0x55, 0xc4, 0x61, 0xbf, 0xe6,
	0xa6, 0xe8, 0x91, 0x4d, 0x31, 0x9f, 0x89, 0xdd, 0x8b, 0x15, 0xbc, 0x3e, 0xae, 0xc7, 0xb0, 0x71,
	0x48, 0x78, 0x48, 0x56, 0x68, 0xc5, 0x3e, 0xed, 0x7b, 0x3c, 0x1d, 0x9c, 0xf9, 0x31, 0x6c, 0x4e,
	0x48, 0x53, 0x10, 0x42, 0xf4, 0xcd, 0xc0, 0x3a, 0xba, 0xe7, 0x22, 0xcc, 0xfc, 0x40, 0xe4, 0xd7,
	0x30, 0x27, 0x8c, 0x9f, 0x38, 0x1d, 0x4f, 0x28, 0x4c, 0x9d, 0xd2, 0x69, 0x7d, 0xb1, 0xd8, 0xde,
	0xc4, 0x3c, 0xd5, 0xf8, 0x13, 0xc8, 0x33, 0xe1, 0x10, 0x1f, 0x1a, 0x3e, 0xa5, 0x7c, 0x5c, 0x26,
	0xa3, 0x99, 0x8b, 0x6c, 0xf4, 0xd1, 0x74, 0xc5, 0xa4, 0x9e, 0x79, 0xdc, 0xbf, 0x7c, 0xea, 0xb5,
	0xfe, 0x6f, 0x4d, 0x3b, 0x13, 0x63, 0x8c, 0x75, 0xbb, 0xd6, 0x6a, 0x0c, 0x2e, 0x14, 0x3d, 0xf5,
	0x42, 0xd9, 0xfd, 0x13, 0x20, 0x77, 0xaa, 0x5c, 0x35, 0xda, 0x41, 0x1e, 0xcc, 0x0f, 0x2e, 0x18,
	0x64, 0xc4, 0x04, 0x7f, 0xe4, 0x1e, 0x33, 0xd6, 0x13, 0x7d, 0x12, 0xa3, 0x59, 0xfe, 0xfe, 0xef,
	0x7f, 0x7e, 0xca, 0x98, 0xe6, 0xa6, 0x75, 0xbe, 0xd3, 0x20, 0x1c, 0xef, 0x58, 0x2e, 0xed, 0x30,
	0xeb, 0xb5, 0x7c, 0x4f, 0x6f, 0x2c, 0x79, 0xcc, 0xf6, 0xb4, 0x6d, 0xf4, 0xbb, 0x06, 0xcb, 0x63,
	0xd2, 0x86, 0xcc, 0x61, 0xf1, 0x49, 0x57, 0x89, 0x71, 0x2f, 0x35, 0x46, 0x01, 0xa9, 0x0a, 0x20,
	0x4f, 0xd0, 0x5e, 0x2a, 0x10, 0xeb, 0xf5, 0x70, 0x52, 0x6f, 0xf6, 0x9c, 0xb0, 0x94, 0x2d, 0xdf,
	0xe4, 0x1f, 0x9a, 0x98, 0x7d, 0x92, 0xfa, 0xa2, 0x72, 0x0a, 0x88, 0x88, 0x20, 0x19, 0x0f, 0xaf,
	0x10, 0xa9, 0x40, 0x7f, 0x28, 0x40, 0xef, 0x20, 0x2b, 0xfd, 0xed, 0x0d, 0x71, 0x36, 0xe4, 0xb7,
	0x21, 0xfa, 0x59, 0x83, 0x95, 0x04, 0x55, 0x45, 0x6f, 0x47, 0x7a, 0x4f, 0xd0, 0x7e, 0x63, 0x6b,
	0x4a, 0x94, 0x42, 0xf7, 0x9e, 0x40, 0xb7, 0x8d, 0xca, 0xc9, 0xe8, 0xf6, 0x9a, 0xc3, 0x44, 0xf5,
	0x02, 0x7f, 0xd1, 0xa4, 0x4c, 0x8f, 0xef, 0x27, 0x7a, 0x10, 0xe9, 0x39, 0x79, 0xf3, 0x8d, 0xf2,
	0xf4, 0x40, 0x85, 0xef, 0x1d, 0x81, 0x6f, 0x0b, 0xdd, 0x9b, 0xf0, 0xf6, 0x82, 0xe5, 0x67, 0x7b,
	0xae, 0xa8, 0x80, 0x7e, 0xd3, 0xe0, 0x56, 0xa2, 0x64, 0xa1, 0xfb, 0x91, 0x86, 0x13, 0xa5, 0xd0,
	0x78, 0x30, 0x35, 0x4e, 0xe1, 0x7a, 0x2c, 0x70, 0x59, 0xe8, 0xdd, 0xf4, 0xa9, 0x86, 0x17, 0x4f,
	0x4b, 0x8a, 0x24, 0xfa, 0x51, 0x83, 0x42, 0x5c, 0x0b, 0xd0, 0xdd, 0x48, 0xd3, 0x24, 0x55, 0x32,
	0xcc, 0xb4, 0x10, 0x05, 0x69, 0x57, 0x40, 0x7a, 0x84, 0xb6, 0xaf, 0xbe, 0x1d, 0xa8, 0x06, 0xb9,
	0x91, 0x4f, 0x46, 0xb4, 0x31, 0x2e, 0x03, 0xc3, 0x4f, 0x68, 0x63, 0x73, 0x82, 0x57, 0xf5, 0xbf,
	0x81, 0xbe, 0x15, 0xe4, 0x22, 0xf7, 0x55, 0x8c, 0x5c, 0xd2, 0xe5, 0x18, 0x23, 0x97, 0x78, 0xdd,
	0x99, 0x37, 0xd0, 0xd7, 0x90, 0x8f, 0xdd, 0xd1, 0xa8, 0x94, 0x98, 0x38, 0xba, 0xa7, 0x77, 0x53,
	0x22, 0xc2, 0xca, 0xd5, 0x2f, 0xe0, 0x76, 0x93, 0x76, 0xc3, 0x7f, 0x14, 0xd1, 0xbf, 0xa8, 0xd5,
	0x95, 0x11, 0x3d, 0x7d, 0xda, 0x73, 0x8e, 0x03, 0xe3, 0xb1, 0xf6, 0x8d, 0xd1, 0x71, 0xf8, 0x59,
	0xbf, 0x51, 0x69, 0xd2, 0xae, 0xa5, 0xfe, 0x8d, 0x86, 0x89, 0x8d, 0xac, 0xc8, 0x7c, 0xff, 0xdf,
	0x00, 0x00, 0x00, 0xff, 0xff, 0x55, 0x3d, 0x5c, 0x09, 0x10, 0x0f, 0x00, 0x00,
}
